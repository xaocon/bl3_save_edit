// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `oak_save.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct PlayerClassSaveGameData {
    // message fields
    pub player_class_path: ::std::string::String,
    pub dlc_package_id: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlayerClassSaveGameData {
    fn default() -> &'a PlayerClassSaveGameData {
        <PlayerClassSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl PlayerClassSaveGameData {
    pub fn new() -> PlayerClassSaveGameData {
        ::std::default::Default::default()
    }

    // string player_class_path = 1;


    pub fn get_player_class_path(&self) -> &str {
        &self.player_class_path
    }
    pub fn clear_player_class_path(&mut self) {
        self.player_class_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_class_path(&mut self, v: ::std::string::String) {
        self.player_class_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_class_path(&mut self) -> &mut ::std::string::String {
        &mut self.player_class_path
    }

    // Take field
    pub fn take_player_class_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.player_class_path, ::std::string::String::new())
    }

    // uint32 dlc_package_id = 2;


    pub fn get_dlc_package_id(&self) -> u32 {
        self.dlc_package_id
    }
    pub fn clear_dlc_package_id(&mut self) {
        self.dlc_package_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_dlc_package_id(&mut self, v: u32) {
        self.dlc_package_id = v;
    }
}

impl ::protobuf::Message for PlayerClassSaveGameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.player_class_path)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dlc_package_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.player_class_path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.player_class_path);
        }
        if self.dlc_package_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.dlc_package_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.player_class_path.is_empty() {
            os.write_string(1, &self.player_class_path)?;
        }
        if self.dlc_package_id != 0 {
            os.write_uint32(2, self.dlc_package_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayerClassSaveGameData {
        PlayerClassSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "player_class_path",
                |m: &PlayerClassSaveGameData| { &m.player_class_path },
                |m: &mut PlayerClassSaveGameData| { &mut m.player_class_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "dlc_package_id",
                |m: &PlayerClassSaveGameData| { &m.dlc_package_id },
                |m: &mut PlayerClassSaveGameData| { &mut m.dlc_package_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlayerClassSaveGameData>(
                "PlayerClassSaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayerClassSaveGameData {
        static instance: ::protobuf::rt::LazyV2<PlayerClassSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlayerClassSaveGameData::new)
    }
}

impl ::protobuf::Clear for PlayerClassSaveGameData {
    fn clear(&mut self) {
        self.player_class_path.clear();
        self.dlc_package_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayerClassSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerClassSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourcePoolSavegameData {
    // message fields
    pub amount: f32,
    pub resource_path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResourcePoolSavegameData {
    fn default() -> &'a ResourcePoolSavegameData {
        <ResourcePoolSavegameData as ::protobuf::Message>::default_instance()
    }
}

impl ResourcePoolSavegameData {
    pub fn new() -> ResourcePoolSavegameData {
        ::std::default::Default::default()
    }

    // float amount = 1;


    pub fn get_amount(&self) -> f32 {
        self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount = 0.;
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: f32) {
        self.amount = v;
    }

    // string resource_path = 2;


    pub fn get_resource_path(&self) -> &str {
        &self.resource_path
    }
    pub fn clear_resource_path(&mut self) {
        self.resource_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_resource_path(&mut self, v: ::std::string::String) {
        self.resource_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource_path(&mut self) -> &mut ::std::string::String {
        &mut self.resource_path
    }

    // Take field
    pub fn take_resource_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.resource_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ResourcePoolSavegameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.amount = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.resource_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.amount != 0. {
            my_size += 5;
        }
        if !self.resource_path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.resource_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.amount != 0. {
            os.write_float(1, self.amount)?;
        }
        if !self.resource_path.is_empty() {
            os.write_string(2, &self.resource_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResourcePoolSavegameData {
        ResourcePoolSavegameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "amount",
                |m: &ResourcePoolSavegameData| { &m.amount },
                |m: &mut ResourcePoolSavegameData| { &mut m.amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "resource_path",
                |m: &ResourcePoolSavegameData| { &m.resource_path },
                |m: &mut ResourcePoolSavegameData| { &mut m.resource_path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResourcePoolSavegameData>(
                "ResourcePoolSavegameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResourcePoolSavegameData {
        static instance: ::protobuf::rt::LazyV2<ResourcePoolSavegameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResourcePoolSavegameData::new)
    }
}

impl ::protobuf::Clear for ResourcePoolSavegameData {
    fn clear(&mut self) {
        self.amount = 0.;
        self.resource_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourcePoolSavegameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourcePoolSavegameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RegionSaveGameData {
    // message fields
    pub game_stage: i32,
    pub play_through_idx: i32,
    pub region_path: ::std::string::String,
    pub dlc_package_id: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegionSaveGameData {
    fn default() -> &'a RegionSaveGameData {
        <RegionSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl RegionSaveGameData {
    pub fn new() -> RegionSaveGameData {
        ::std::default::Default::default()
    }

    // int32 game_stage = 1;


    pub fn get_game_stage(&self) -> i32 {
        self.game_stage
    }
    pub fn clear_game_stage(&mut self) {
        self.game_stage = 0;
    }

    // Param is passed by value, moved
    pub fn set_game_stage(&mut self, v: i32) {
        self.game_stage = v;
    }

    // int32 play_through_idx = 2;


    pub fn get_play_through_idx(&self) -> i32 {
        self.play_through_idx
    }
    pub fn clear_play_through_idx(&mut self) {
        self.play_through_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_play_through_idx(&mut self, v: i32) {
        self.play_through_idx = v;
    }

    // string region_path = 3;


    pub fn get_region_path(&self) -> &str {
        &self.region_path
    }
    pub fn clear_region_path(&mut self) {
        self.region_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_region_path(&mut self, v: ::std::string::String) {
        self.region_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_path(&mut self) -> &mut ::std::string::String {
        &mut self.region_path
    }

    // Take field
    pub fn take_region_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.region_path, ::std::string::String::new())
    }

    // uint32 dlc_package_id = 4;


    pub fn get_dlc_package_id(&self) -> u32 {
        self.dlc_package_id
    }
    pub fn clear_dlc_package_id(&mut self) {
        self.dlc_package_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_dlc_package_id(&mut self, v: u32) {
        self.dlc_package_id = v;
    }
}

impl ::protobuf::Message for RegionSaveGameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.game_stage = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.play_through_idx = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.region_path)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dlc_package_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.game_stage != 0 {
            my_size += ::protobuf::rt::value_size(1, self.game_stage, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.play_through_idx != 0 {
            my_size += ::protobuf::rt::value_size(2, self.play_through_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.region_path.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.region_path);
        }
        if self.dlc_package_id != 0 {
            my_size += ::protobuf::rt::value_size(4, self.dlc_package_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.game_stage != 0 {
            os.write_int32(1, self.game_stage)?;
        }
        if self.play_through_idx != 0 {
            os.write_int32(2, self.play_through_idx)?;
        }
        if !self.region_path.is_empty() {
            os.write_string(3, &self.region_path)?;
        }
        if self.dlc_package_id != 0 {
            os.write_uint32(4, self.dlc_package_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RegionSaveGameData {
        RegionSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "game_stage",
                |m: &RegionSaveGameData| { &m.game_stage },
                |m: &mut RegionSaveGameData| { &mut m.game_stage },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "play_through_idx",
                |m: &RegionSaveGameData| { &m.play_through_idx },
                |m: &mut RegionSaveGameData| { &mut m.play_through_idx },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "region_path",
                |m: &RegionSaveGameData| { &m.region_path },
                |m: &mut RegionSaveGameData| { &mut m.region_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "dlc_package_id",
                |m: &RegionSaveGameData| { &m.dlc_package_id },
                |m: &mut RegionSaveGameData| { &mut m.dlc_package_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RegionSaveGameData>(
                "RegionSaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RegionSaveGameData {
        static instance: ::protobuf::rt::LazyV2<RegionSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RegionSaveGameData::new)
    }
}

impl ::protobuf::Clear for RegionSaveGameData {
    fn clear(&mut self) {
        self.game_stage = 0;
        self.play_through_idx = 0;
        self.region_path.clear();
        self.dlc_package_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RegionSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegionSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InventoryBalanceStateInitializationData {
    // message fields
    pub game_stage: i32,
    pub inventory_data: ::std::string::String,
    pub inventory_balance_data: ::std::string::String,
    pub manufacturer_data: ::std::string::String,
    pub part_list: ::protobuf::RepeatedField<::std::string::String>,
    pub generic_part_list: ::protobuf::RepeatedField<::std::string::String>,
    pub additional_data: ::std::vec::Vec<u8>,
    pub customization_part_list: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InventoryBalanceStateInitializationData {
    fn default() -> &'a InventoryBalanceStateInitializationData {
        <InventoryBalanceStateInitializationData as ::protobuf::Message>::default_instance()
    }
}

impl InventoryBalanceStateInitializationData {
    pub fn new() -> InventoryBalanceStateInitializationData {
        ::std::default::Default::default()
    }

    // int32 game_stage = 1;


    pub fn get_game_stage(&self) -> i32 {
        self.game_stage
    }
    pub fn clear_game_stage(&mut self) {
        self.game_stage = 0;
    }

    // Param is passed by value, moved
    pub fn set_game_stage(&mut self, v: i32) {
        self.game_stage = v;
    }

    // string inventory_data = 2;


    pub fn get_inventory_data(&self) -> &str {
        &self.inventory_data
    }
    pub fn clear_inventory_data(&mut self) {
        self.inventory_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_inventory_data(&mut self, v: ::std::string::String) {
        self.inventory_data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inventory_data(&mut self) -> &mut ::std::string::String {
        &mut self.inventory_data
    }

    // Take field
    pub fn take_inventory_data(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.inventory_data, ::std::string::String::new())
    }

    // string inventory_balance_data = 3;


    pub fn get_inventory_balance_data(&self) -> &str {
        &self.inventory_balance_data
    }
    pub fn clear_inventory_balance_data(&mut self) {
        self.inventory_balance_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_inventory_balance_data(&mut self, v: ::std::string::String) {
        self.inventory_balance_data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inventory_balance_data(&mut self) -> &mut ::std::string::String {
        &mut self.inventory_balance_data
    }

    // Take field
    pub fn take_inventory_balance_data(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.inventory_balance_data, ::std::string::String::new())
    }

    // string manufacturer_data = 4;


    pub fn get_manufacturer_data(&self) -> &str {
        &self.manufacturer_data
    }
    pub fn clear_manufacturer_data(&mut self) {
        self.manufacturer_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_manufacturer_data(&mut self, v: ::std::string::String) {
        self.manufacturer_data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_manufacturer_data(&mut self) -> &mut ::std::string::String {
        &mut self.manufacturer_data
    }

    // Take field
    pub fn take_manufacturer_data(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.manufacturer_data, ::std::string::String::new())
    }

    // repeated string part_list = 5;


    pub fn get_part_list(&self) -> &[::std::string::String] {
        &self.part_list
    }
    pub fn clear_part_list(&mut self) {
        self.part_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_part_list(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.part_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_part_list(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.part_list
    }

    // Take field
    pub fn take_part_list(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.part_list, ::protobuf::RepeatedField::new())
    }

    // repeated string generic_part_list = 6;


    pub fn get_generic_part_list(&self) -> &[::std::string::String] {
        &self.generic_part_list
    }
    pub fn clear_generic_part_list(&mut self) {
        self.generic_part_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_generic_part_list(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.generic_part_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_generic_part_list(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.generic_part_list
    }

    // Take field
    pub fn take_generic_part_list(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.generic_part_list, ::protobuf::RepeatedField::new())
    }

    // bytes additional_data = 7;


    pub fn get_additional_data(&self) -> &[u8] {
        &self.additional_data
    }
    pub fn clear_additional_data(&mut self) {
        self.additional_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_additional_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.additional_data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_additional_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.additional_data
    }

    // Take field
    pub fn take_additional_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.additional_data, ::std::vec::Vec::new())
    }

    // repeated string customization_part_list = 8;


    pub fn get_customization_part_list(&self) -> &[::std::string::String] {
        &self.customization_part_list
    }
    pub fn clear_customization_part_list(&mut self) {
        self.customization_part_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_customization_part_list(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.customization_part_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_customization_part_list(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.customization_part_list
    }

    // Take field
    pub fn take_customization_part_list(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.customization_part_list, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for InventoryBalanceStateInitializationData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.game_stage = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.inventory_data)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.inventory_balance_data)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.manufacturer_data)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.part_list)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.generic_part_list)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.additional_data)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.customization_part_list)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.game_stage != 0 {
            my_size += ::protobuf::rt::value_size(1, self.game_stage, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.inventory_data.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.inventory_data);
        }
        if !self.inventory_balance_data.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.inventory_balance_data);
        }
        if !self.manufacturer_data.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.manufacturer_data);
        }
        for value in &self.part_list {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.generic_part_list {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if !self.additional_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.additional_data);
        }
        for value in &self.customization_part_list {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.game_stage != 0 {
            os.write_int32(1, self.game_stage)?;
        }
        if !self.inventory_data.is_empty() {
            os.write_string(2, &self.inventory_data)?;
        }
        if !self.inventory_balance_data.is_empty() {
            os.write_string(3, &self.inventory_balance_data)?;
        }
        if !self.manufacturer_data.is_empty() {
            os.write_string(4, &self.manufacturer_data)?;
        }
        for v in &self.part_list {
            os.write_string(5, &v)?;
        };
        for v in &self.generic_part_list {
            os.write_string(6, &v)?;
        };
        if !self.additional_data.is_empty() {
            os.write_bytes(7, &self.additional_data)?;
        }
        for v in &self.customization_part_list {
            os.write_string(8, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InventoryBalanceStateInitializationData {
        InventoryBalanceStateInitializationData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "game_stage",
                |m: &InventoryBalanceStateInitializationData| { &m.game_stage },
                |m: &mut InventoryBalanceStateInitializationData| { &mut m.game_stage },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "inventory_data",
                |m: &InventoryBalanceStateInitializationData| { &m.inventory_data },
                |m: &mut InventoryBalanceStateInitializationData| { &mut m.inventory_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "inventory_balance_data",
                |m: &InventoryBalanceStateInitializationData| { &m.inventory_balance_data },
                |m: &mut InventoryBalanceStateInitializationData| { &mut m.inventory_balance_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "manufacturer_data",
                |m: &InventoryBalanceStateInitializationData| { &m.manufacturer_data },
                |m: &mut InventoryBalanceStateInitializationData| { &mut m.manufacturer_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "part_list",
                |m: &InventoryBalanceStateInitializationData| { &m.part_list },
                |m: &mut InventoryBalanceStateInitializationData| { &mut m.part_list },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "generic_part_list",
                |m: &InventoryBalanceStateInitializationData| { &m.generic_part_list },
                |m: &mut InventoryBalanceStateInitializationData| { &mut m.generic_part_list },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "additional_data",
                |m: &InventoryBalanceStateInitializationData| { &m.additional_data },
                |m: &mut InventoryBalanceStateInitializationData| { &mut m.additional_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "customization_part_list",
                |m: &InventoryBalanceStateInitializationData| { &m.customization_part_list },
                |m: &mut InventoryBalanceStateInitializationData| { &mut m.customization_part_list },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InventoryBalanceStateInitializationData>(
                "InventoryBalanceStateInitializationData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InventoryBalanceStateInitializationData {
        static instance: ::protobuf::rt::LazyV2<InventoryBalanceStateInitializationData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InventoryBalanceStateInitializationData::new)
    }
}

impl ::protobuf::Clear for InventoryBalanceStateInitializationData {
    fn clear(&mut self) {
        self.game_stage = 0;
        self.inventory_data.clear();
        self.inventory_balance_data.clear();
        self.manufacturer_data.clear();
        self.part_list.clear();
        self.generic_part_list.clear();
        self.additional_data.clear();
        self.customization_part_list.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InventoryBalanceStateInitializationData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InventoryBalanceStateInitializationData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OakInventoryItemSaveGameData {
    // message fields
    pub item_serial_number: ::std::vec::Vec<u8>,
    pub pickup_order_index: i32,
    pub flags: i32,
    pub weapon_skin_path: ::std::string::String,
    pub development_save_data: ::protobuf::SingularPtrField<InventoryBalanceStateInitializationData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OakInventoryItemSaveGameData {
    fn default() -> &'a OakInventoryItemSaveGameData {
        <OakInventoryItemSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl OakInventoryItemSaveGameData {
    pub fn new() -> OakInventoryItemSaveGameData {
        ::std::default::Default::default()
    }

    // bytes item_serial_number = 1;


    pub fn get_item_serial_number(&self) -> &[u8] {
        &self.item_serial_number
    }
    pub fn clear_item_serial_number(&mut self) {
        self.item_serial_number.clear();
    }

    // Param is passed by value, moved
    pub fn set_item_serial_number(&mut self, v: ::std::vec::Vec<u8>) {
        self.item_serial_number = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item_serial_number(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.item_serial_number
    }

    // Take field
    pub fn take_item_serial_number(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.item_serial_number, ::std::vec::Vec::new())
    }

    // int32 pickup_order_index = 2;


    pub fn get_pickup_order_index(&self) -> i32 {
        self.pickup_order_index
    }
    pub fn clear_pickup_order_index(&mut self) {
        self.pickup_order_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_pickup_order_index(&mut self, v: i32) {
        self.pickup_order_index = v;
    }

    // int32 flags = 3;


    pub fn get_flags(&self) -> i32 {
        self.flags
    }
    pub fn clear_flags(&mut self) {
        self.flags = 0;
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: i32) {
        self.flags = v;
    }

    // string weapon_skin_path = 4;


    pub fn get_weapon_skin_path(&self) -> &str {
        &self.weapon_skin_path
    }
    pub fn clear_weapon_skin_path(&mut self) {
        self.weapon_skin_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_weapon_skin_path(&mut self, v: ::std::string::String) {
        self.weapon_skin_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_weapon_skin_path(&mut self) -> &mut ::std::string::String {
        &mut self.weapon_skin_path
    }

    // Take field
    pub fn take_weapon_skin_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.weapon_skin_path, ::std::string::String::new())
    }

    // .OakSave.InventoryBalanceStateInitializationData development_save_data = 5;


    pub fn get_development_save_data(&self) -> &InventoryBalanceStateInitializationData {
        self.development_save_data.as_ref().unwrap_or_else(|| <InventoryBalanceStateInitializationData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_development_save_data(&mut self) {
        self.development_save_data.clear();
    }

    pub fn has_development_save_data(&self) -> bool {
        self.development_save_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_development_save_data(&mut self, v: InventoryBalanceStateInitializationData) {
        self.development_save_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_development_save_data(&mut self) -> &mut InventoryBalanceStateInitializationData {
        if self.development_save_data.is_none() {
            self.development_save_data.set_default();
        }
        self.development_save_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_development_save_data(&mut self) -> InventoryBalanceStateInitializationData {
        self.development_save_data.take().unwrap_or_else(|| InventoryBalanceStateInitializationData::new())
    }
}

impl ::protobuf::Message for OakInventoryItemSaveGameData {
    fn is_initialized(&self) -> bool {
        for v in &self.development_save_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.item_serial_number)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pickup_order_index = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.flags = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.weapon_skin_path)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.development_save_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.item_serial_number.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.item_serial_number);
        }
        if self.pickup_order_index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.pickup_order_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.flags != 0 {
            my_size += ::protobuf::rt::value_size(3, self.flags, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.weapon_skin_path.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.weapon_skin_path);
        }
        if let Some(ref v) = self.development_save_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.item_serial_number.is_empty() {
            os.write_bytes(1, &self.item_serial_number)?;
        }
        if self.pickup_order_index != 0 {
            os.write_int32(2, self.pickup_order_index)?;
        }
        if self.flags != 0 {
            os.write_int32(3, self.flags)?;
        }
        if !self.weapon_skin_path.is_empty() {
            os.write_string(4, &self.weapon_skin_path)?;
        }
        if let Some(ref v) = self.development_save_data.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OakInventoryItemSaveGameData {
        OakInventoryItemSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "item_serial_number",
                |m: &OakInventoryItemSaveGameData| { &m.item_serial_number },
                |m: &mut OakInventoryItemSaveGameData| { &mut m.item_serial_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "pickup_order_index",
                |m: &OakInventoryItemSaveGameData| { &m.pickup_order_index },
                |m: &mut OakInventoryItemSaveGameData| { &mut m.pickup_order_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "flags",
                |m: &OakInventoryItemSaveGameData| { &m.flags },
                |m: &mut OakInventoryItemSaveGameData| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "weapon_skin_path",
                |m: &OakInventoryItemSaveGameData| { &m.weapon_skin_path },
                |m: &mut OakInventoryItemSaveGameData| { &mut m.weapon_skin_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InventoryBalanceStateInitializationData>>(
                "development_save_data",
                |m: &OakInventoryItemSaveGameData| { &m.development_save_data },
                |m: &mut OakInventoryItemSaveGameData| { &mut m.development_save_data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OakInventoryItemSaveGameData>(
                "OakInventoryItemSaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OakInventoryItemSaveGameData {
        static instance: ::protobuf::rt::LazyV2<OakInventoryItemSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OakInventoryItemSaveGameData::new)
    }
}

impl ::protobuf::Clear for OakInventoryItemSaveGameData {
    fn clear(&mut self) {
        self.item_serial_number.clear();
        self.pickup_order_index = 0;
        self.flags = 0;
        self.weapon_skin_path.clear();
        self.development_save_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OakInventoryItemSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OakInventoryItemSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EquippedInventorySaveGameData {
    // message fields
    pub inventory_list_index: i32,
    pub enabled: bool,
    pub slot_data_path: ::std::string::String,
    pub trinket_data_path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EquippedInventorySaveGameData {
    fn default() -> &'a EquippedInventorySaveGameData {
        <EquippedInventorySaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl EquippedInventorySaveGameData {
    pub fn new() -> EquippedInventorySaveGameData {
        ::std::default::Default::default()
    }

    // int32 inventory_list_index = 1;


    pub fn get_inventory_list_index(&self) -> i32 {
        self.inventory_list_index
    }
    pub fn clear_inventory_list_index(&mut self) {
        self.inventory_list_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_inventory_list_index(&mut self, v: i32) {
        self.inventory_list_index = v;
    }

    // bool enabled = 2;


    pub fn get_enabled(&self) -> bool {
        self.enabled
    }
    pub fn clear_enabled(&mut self) {
        self.enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = v;
    }

    // string slot_data_path = 3;


    pub fn get_slot_data_path(&self) -> &str {
        &self.slot_data_path
    }
    pub fn clear_slot_data_path(&mut self) {
        self.slot_data_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_slot_data_path(&mut self, v: ::std::string::String) {
        self.slot_data_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_slot_data_path(&mut self) -> &mut ::std::string::String {
        &mut self.slot_data_path
    }

    // Take field
    pub fn take_slot_data_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.slot_data_path, ::std::string::String::new())
    }

    // string trinket_data_path = 4;


    pub fn get_trinket_data_path(&self) -> &str {
        &self.trinket_data_path
    }
    pub fn clear_trinket_data_path(&mut self) {
        self.trinket_data_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_trinket_data_path(&mut self, v: ::std::string::String) {
        self.trinket_data_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trinket_data_path(&mut self) -> &mut ::std::string::String {
        &mut self.trinket_data_path
    }

    // Take field
    pub fn take_trinket_data_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trinket_data_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for EquippedInventorySaveGameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.inventory_list_index = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enabled = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.slot_data_path)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trinket_data_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.inventory_list_index != 0 {
            my_size += ::protobuf::rt::value_size(1, self.inventory_list_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.enabled != false {
            my_size += 2;
        }
        if !self.slot_data_path.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.slot_data_path);
        }
        if !self.trinket_data_path.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.trinket_data_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.inventory_list_index != 0 {
            os.write_int32(1, self.inventory_list_index)?;
        }
        if self.enabled != false {
            os.write_bool(2, self.enabled)?;
        }
        if !self.slot_data_path.is_empty() {
            os.write_string(3, &self.slot_data_path)?;
        }
        if !self.trinket_data_path.is_empty() {
            os.write_string(4, &self.trinket_data_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EquippedInventorySaveGameData {
        EquippedInventorySaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "inventory_list_index",
                |m: &EquippedInventorySaveGameData| { &m.inventory_list_index },
                |m: &mut EquippedInventorySaveGameData| { &mut m.inventory_list_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enabled",
                |m: &EquippedInventorySaveGameData| { &m.enabled },
                |m: &mut EquippedInventorySaveGameData| { &mut m.enabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "slot_data_path",
                |m: &EquippedInventorySaveGameData| { &m.slot_data_path },
                |m: &mut EquippedInventorySaveGameData| { &mut m.slot_data_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "trinket_data_path",
                |m: &EquippedInventorySaveGameData| { &m.trinket_data_path },
                |m: &mut EquippedInventorySaveGameData| { &mut m.trinket_data_path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EquippedInventorySaveGameData>(
                "EquippedInventorySaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EquippedInventorySaveGameData {
        static instance: ::protobuf::rt::LazyV2<EquippedInventorySaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EquippedInventorySaveGameData::new)
    }
}

impl ::protobuf::Clear for EquippedInventorySaveGameData {
    fn clear(&mut self) {
        self.inventory_list_index = 0;
        self.enabled = false;
        self.slot_data_path.clear();
        self.trinket_data_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EquippedInventorySaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EquippedInventorySaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OakAbilityTreeItemSaveGameData {
    // message fields
    pub item_asset_path: ::std::string::String,
    pub points: i32,
    pub max_points: i32,
    pub tree_identifier: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OakAbilityTreeItemSaveGameData {
    fn default() -> &'a OakAbilityTreeItemSaveGameData {
        <OakAbilityTreeItemSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl OakAbilityTreeItemSaveGameData {
    pub fn new() -> OakAbilityTreeItemSaveGameData {
        ::std::default::Default::default()
    }

    // string item_asset_path = 1;


    pub fn get_item_asset_path(&self) -> &str {
        &self.item_asset_path
    }
    pub fn clear_item_asset_path(&mut self) {
        self.item_asset_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_item_asset_path(&mut self, v: ::std::string::String) {
        self.item_asset_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item_asset_path(&mut self) -> &mut ::std::string::String {
        &mut self.item_asset_path
    }

    // Take field
    pub fn take_item_asset_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.item_asset_path, ::std::string::String::new())
    }

    // int32 points = 2;


    pub fn get_points(&self) -> i32 {
        self.points
    }
    pub fn clear_points(&mut self) {
        self.points = 0;
    }

    // Param is passed by value, moved
    pub fn set_points(&mut self, v: i32) {
        self.points = v;
    }

    // int32 max_points = 3;


    pub fn get_max_points(&self) -> i32 {
        self.max_points
    }
    pub fn clear_max_points(&mut self) {
        self.max_points = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_points(&mut self, v: i32) {
        self.max_points = v;
    }

    // int32 tree_identifier = 4;


    pub fn get_tree_identifier(&self) -> i32 {
        self.tree_identifier
    }
    pub fn clear_tree_identifier(&mut self) {
        self.tree_identifier = 0;
    }

    // Param is passed by value, moved
    pub fn set_tree_identifier(&mut self, v: i32) {
        self.tree_identifier = v;
    }
}

impl ::protobuf::Message for OakAbilityTreeItemSaveGameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.item_asset_path)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.points = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_points = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.tree_identifier = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.item_asset_path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.item_asset_path);
        }
        if self.points != 0 {
            my_size += ::protobuf::rt::value_size(2, self.points, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_points != 0 {
            my_size += ::protobuf::rt::value_size(3, self.max_points, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tree_identifier != 0 {
            my_size += ::protobuf::rt::value_size(4, self.tree_identifier, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.item_asset_path.is_empty() {
            os.write_string(1, &self.item_asset_path)?;
        }
        if self.points != 0 {
            os.write_int32(2, self.points)?;
        }
        if self.max_points != 0 {
            os.write_int32(3, self.max_points)?;
        }
        if self.tree_identifier != 0 {
            os.write_int32(4, self.tree_identifier)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OakAbilityTreeItemSaveGameData {
        OakAbilityTreeItemSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "item_asset_path",
                |m: &OakAbilityTreeItemSaveGameData| { &m.item_asset_path },
                |m: &mut OakAbilityTreeItemSaveGameData| { &mut m.item_asset_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "points",
                |m: &OakAbilityTreeItemSaveGameData| { &m.points },
                |m: &mut OakAbilityTreeItemSaveGameData| { &mut m.points },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_points",
                |m: &OakAbilityTreeItemSaveGameData| { &m.max_points },
                |m: &mut OakAbilityTreeItemSaveGameData| { &mut m.max_points },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "tree_identifier",
                |m: &OakAbilityTreeItemSaveGameData| { &m.tree_identifier },
                |m: &mut OakAbilityTreeItemSaveGameData| { &mut m.tree_identifier },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OakAbilityTreeItemSaveGameData>(
                "OakAbilityTreeItemSaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OakAbilityTreeItemSaveGameData {
        static instance: ::protobuf::rt::LazyV2<OakAbilityTreeItemSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OakAbilityTreeItemSaveGameData::new)
    }
}

impl ::protobuf::Clear for OakAbilityTreeItemSaveGameData {
    fn clear(&mut self) {
        self.item_asset_path.clear();
        self.points = 0;
        self.max_points = 0;
        self.tree_identifier = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OakAbilityTreeItemSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OakAbilityTreeItemSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OakAbilitySlotSaveGameData {
    // message fields
    pub ability_class_path: ::std::string::String,
    pub slot_asset_path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OakAbilitySlotSaveGameData {
    fn default() -> &'a OakAbilitySlotSaveGameData {
        <OakAbilitySlotSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl OakAbilitySlotSaveGameData {
    pub fn new() -> OakAbilitySlotSaveGameData {
        ::std::default::Default::default()
    }

    // string ability_class_path = 1;


    pub fn get_ability_class_path(&self) -> &str {
        &self.ability_class_path
    }
    pub fn clear_ability_class_path(&mut self) {
        self.ability_class_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_ability_class_path(&mut self, v: ::std::string::String) {
        self.ability_class_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ability_class_path(&mut self) -> &mut ::std::string::String {
        &mut self.ability_class_path
    }

    // Take field
    pub fn take_ability_class_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ability_class_path, ::std::string::String::new())
    }

    // string slot_asset_path = 2;


    pub fn get_slot_asset_path(&self) -> &str {
        &self.slot_asset_path
    }
    pub fn clear_slot_asset_path(&mut self) {
        self.slot_asset_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_slot_asset_path(&mut self, v: ::std::string::String) {
        self.slot_asset_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_slot_asset_path(&mut self) -> &mut ::std::string::String {
        &mut self.slot_asset_path
    }

    // Take field
    pub fn take_slot_asset_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.slot_asset_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OakAbilitySlotSaveGameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ability_class_path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.slot_asset_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ability_class_path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ability_class_path);
        }
        if !self.slot_asset_path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.slot_asset_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.ability_class_path.is_empty() {
            os.write_string(1, &self.ability_class_path)?;
        }
        if !self.slot_asset_path.is_empty() {
            os.write_string(2, &self.slot_asset_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OakAbilitySlotSaveGameData {
        OakAbilitySlotSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ability_class_path",
                |m: &OakAbilitySlotSaveGameData| { &m.ability_class_path },
                |m: &mut OakAbilitySlotSaveGameData| { &mut m.ability_class_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "slot_asset_path",
                |m: &OakAbilitySlotSaveGameData| { &m.slot_asset_path },
                |m: &mut OakAbilitySlotSaveGameData| { &mut m.slot_asset_path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OakAbilitySlotSaveGameData>(
                "OakAbilitySlotSaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OakAbilitySlotSaveGameData {
        static instance: ::protobuf::rt::LazyV2<OakAbilitySlotSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OakAbilitySlotSaveGameData::new)
    }
}

impl ::protobuf::Clear for OakAbilitySlotSaveGameData {
    fn clear(&mut self) {
        self.ability_class_path.clear();
        self.slot_asset_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OakAbilitySlotSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OakAbilitySlotSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OakActionAbilityAugmentSaveGameData {
    // message fields
    pub action_ability_class_path: ::std::string::String,
    pub slot_asset_path: ::std::string::String,
    pub augment_asset_path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OakActionAbilityAugmentSaveGameData {
    fn default() -> &'a OakActionAbilityAugmentSaveGameData {
        <OakActionAbilityAugmentSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl OakActionAbilityAugmentSaveGameData {
    pub fn new() -> OakActionAbilityAugmentSaveGameData {
        ::std::default::Default::default()
    }

    // string action_ability_class_path = 1;


    pub fn get_action_ability_class_path(&self) -> &str {
        &self.action_ability_class_path
    }
    pub fn clear_action_ability_class_path(&mut self) {
        self.action_ability_class_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_action_ability_class_path(&mut self, v: ::std::string::String) {
        self.action_ability_class_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action_ability_class_path(&mut self) -> &mut ::std::string::String {
        &mut self.action_ability_class_path
    }

    // Take field
    pub fn take_action_ability_class_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action_ability_class_path, ::std::string::String::new())
    }

    // string slot_asset_path = 2;


    pub fn get_slot_asset_path(&self) -> &str {
        &self.slot_asset_path
    }
    pub fn clear_slot_asset_path(&mut self) {
        self.slot_asset_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_slot_asset_path(&mut self, v: ::std::string::String) {
        self.slot_asset_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_slot_asset_path(&mut self) -> &mut ::std::string::String {
        &mut self.slot_asset_path
    }

    // Take field
    pub fn take_slot_asset_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.slot_asset_path, ::std::string::String::new())
    }

    // string augment_asset_path = 3;


    pub fn get_augment_asset_path(&self) -> &str {
        &self.augment_asset_path
    }
    pub fn clear_augment_asset_path(&mut self) {
        self.augment_asset_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_augment_asset_path(&mut self, v: ::std::string::String) {
        self.augment_asset_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_augment_asset_path(&mut self) -> &mut ::std::string::String {
        &mut self.augment_asset_path
    }

    // Take field
    pub fn take_augment_asset_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.augment_asset_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OakActionAbilityAugmentSaveGameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action_ability_class_path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.slot_asset_path)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.augment_asset_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.action_ability_class_path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.action_ability_class_path);
        }
        if !self.slot_asset_path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.slot_asset_path);
        }
        if !self.augment_asset_path.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.augment_asset_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.action_ability_class_path.is_empty() {
            os.write_string(1, &self.action_ability_class_path)?;
        }
        if !self.slot_asset_path.is_empty() {
            os.write_string(2, &self.slot_asset_path)?;
        }
        if !self.augment_asset_path.is_empty() {
            os.write_string(3, &self.augment_asset_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OakActionAbilityAugmentSaveGameData {
        OakActionAbilityAugmentSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action_ability_class_path",
                |m: &OakActionAbilityAugmentSaveGameData| { &m.action_ability_class_path },
                |m: &mut OakActionAbilityAugmentSaveGameData| { &mut m.action_ability_class_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "slot_asset_path",
                |m: &OakActionAbilityAugmentSaveGameData| { &m.slot_asset_path },
                |m: &mut OakActionAbilityAugmentSaveGameData| { &mut m.slot_asset_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "augment_asset_path",
                |m: &OakActionAbilityAugmentSaveGameData| { &m.augment_asset_path },
                |m: &mut OakActionAbilityAugmentSaveGameData| { &mut m.augment_asset_path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OakActionAbilityAugmentSaveGameData>(
                "OakActionAbilityAugmentSaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OakActionAbilityAugmentSaveGameData {
        static instance: ::protobuf::rt::LazyV2<OakActionAbilityAugmentSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OakActionAbilityAugmentSaveGameData::new)
    }
}

impl ::protobuf::Clear for OakActionAbilityAugmentSaveGameData {
    fn clear(&mut self) {
        self.action_ability_class_path.clear();
        self.slot_asset_path.clear();
        self.augment_asset_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OakActionAbilityAugmentSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OakActionAbilityAugmentSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OakActionAbilityAugmentConfigurationSaveGameData {
    // message fields
    pub ability_class_path: ::std::string::String,
    pub augment_asset_path: ::std::string::String,
    pub mod_slot_asset_path: ::std::string::String,
    pub mod_asset_path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OakActionAbilityAugmentConfigurationSaveGameData {
    fn default() -> &'a OakActionAbilityAugmentConfigurationSaveGameData {
        <OakActionAbilityAugmentConfigurationSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl OakActionAbilityAugmentConfigurationSaveGameData {
    pub fn new() -> OakActionAbilityAugmentConfigurationSaveGameData {
        ::std::default::Default::default()
    }

    // string ability_class_path = 1;


    pub fn get_ability_class_path(&self) -> &str {
        &self.ability_class_path
    }
    pub fn clear_ability_class_path(&mut self) {
        self.ability_class_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_ability_class_path(&mut self, v: ::std::string::String) {
        self.ability_class_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ability_class_path(&mut self) -> &mut ::std::string::String {
        &mut self.ability_class_path
    }

    // Take field
    pub fn take_ability_class_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ability_class_path, ::std::string::String::new())
    }

    // string augment_asset_path = 2;


    pub fn get_augment_asset_path(&self) -> &str {
        &self.augment_asset_path
    }
    pub fn clear_augment_asset_path(&mut self) {
        self.augment_asset_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_augment_asset_path(&mut self, v: ::std::string::String) {
        self.augment_asset_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_augment_asset_path(&mut self) -> &mut ::std::string::String {
        &mut self.augment_asset_path
    }

    // Take field
    pub fn take_augment_asset_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.augment_asset_path, ::std::string::String::new())
    }

    // string mod_slot_asset_path = 3;


    pub fn get_mod_slot_asset_path(&self) -> &str {
        &self.mod_slot_asset_path
    }
    pub fn clear_mod_slot_asset_path(&mut self) {
        self.mod_slot_asset_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_mod_slot_asset_path(&mut self, v: ::std::string::String) {
        self.mod_slot_asset_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mod_slot_asset_path(&mut self) -> &mut ::std::string::String {
        &mut self.mod_slot_asset_path
    }

    // Take field
    pub fn take_mod_slot_asset_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mod_slot_asset_path, ::std::string::String::new())
    }

    // string mod_asset_path = 4;


    pub fn get_mod_asset_path(&self) -> &str {
        &self.mod_asset_path
    }
    pub fn clear_mod_asset_path(&mut self) {
        self.mod_asset_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_mod_asset_path(&mut self, v: ::std::string::String) {
        self.mod_asset_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mod_asset_path(&mut self) -> &mut ::std::string::String {
        &mut self.mod_asset_path
    }

    // Take field
    pub fn take_mod_asset_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mod_asset_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OakActionAbilityAugmentConfigurationSaveGameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ability_class_path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.augment_asset_path)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mod_slot_asset_path)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mod_asset_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ability_class_path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ability_class_path);
        }
        if !self.augment_asset_path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.augment_asset_path);
        }
        if !self.mod_slot_asset_path.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.mod_slot_asset_path);
        }
        if !self.mod_asset_path.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.mod_asset_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.ability_class_path.is_empty() {
            os.write_string(1, &self.ability_class_path)?;
        }
        if !self.augment_asset_path.is_empty() {
            os.write_string(2, &self.augment_asset_path)?;
        }
        if !self.mod_slot_asset_path.is_empty() {
            os.write_string(3, &self.mod_slot_asset_path)?;
        }
        if !self.mod_asset_path.is_empty() {
            os.write_string(4, &self.mod_asset_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OakActionAbilityAugmentConfigurationSaveGameData {
        OakActionAbilityAugmentConfigurationSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ability_class_path",
                |m: &OakActionAbilityAugmentConfigurationSaveGameData| { &m.ability_class_path },
                |m: &mut OakActionAbilityAugmentConfigurationSaveGameData| { &mut m.ability_class_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "augment_asset_path",
                |m: &OakActionAbilityAugmentConfigurationSaveGameData| { &m.augment_asset_path },
                |m: &mut OakActionAbilityAugmentConfigurationSaveGameData| { &mut m.augment_asset_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mod_slot_asset_path",
                |m: &OakActionAbilityAugmentConfigurationSaveGameData| { &m.mod_slot_asset_path },
                |m: &mut OakActionAbilityAugmentConfigurationSaveGameData| { &mut m.mod_slot_asset_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mod_asset_path",
                |m: &OakActionAbilityAugmentConfigurationSaveGameData| { &m.mod_asset_path },
                |m: &mut OakActionAbilityAugmentConfigurationSaveGameData| { &mut m.mod_asset_path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OakActionAbilityAugmentConfigurationSaveGameData>(
                "OakActionAbilityAugmentConfigurationSaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OakActionAbilityAugmentConfigurationSaveGameData {
        static instance: ::protobuf::rt::LazyV2<OakActionAbilityAugmentConfigurationSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OakActionAbilityAugmentConfigurationSaveGameData::new)
    }
}

impl ::protobuf::Clear for OakActionAbilityAugmentConfigurationSaveGameData {
    fn clear(&mut self) {
        self.ability_class_path.clear();
        self.augment_asset_path.clear();
        self.mod_slot_asset_path.clear();
        self.mod_asset_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OakActionAbilityAugmentConfigurationSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OakActionAbilityAugmentConfigurationSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OakPlayerAbilitySaveGameData {
    // message fields
    pub ability_points: i32,
    pub tree_item_list: ::protobuf::RepeatedField<OakAbilityTreeItemSaveGameData>,
    pub ability_slot_list: ::protobuf::RepeatedField<OakAbilitySlotSaveGameData>,
    pub augment_slot_list: ::protobuf::RepeatedField<OakActionAbilityAugmentSaveGameData>,
    pub augment_configuration_list: ::protobuf::RepeatedField<OakActionAbilityAugmentConfigurationSaveGameData>,
    pub tree_grade: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OakPlayerAbilitySaveGameData {
    fn default() -> &'a OakPlayerAbilitySaveGameData {
        <OakPlayerAbilitySaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl OakPlayerAbilitySaveGameData {
    pub fn new() -> OakPlayerAbilitySaveGameData {
        ::std::default::Default::default()
    }

    // int32 ability_points = 1;


    pub fn get_ability_points(&self) -> i32 {
        self.ability_points
    }
    pub fn clear_ability_points(&mut self) {
        self.ability_points = 0;
    }

    // Param is passed by value, moved
    pub fn set_ability_points(&mut self, v: i32) {
        self.ability_points = v;
    }

    // repeated .OakSave.OakAbilityTreeItemSaveGameData tree_item_list = 2;


    pub fn get_tree_item_list(&self) -> &[OakAbilityTreeItemSaveGameData] {
        &self.tree_item_list
    }
    pub fn clear_tree_item_list(&mut self) {
        self.tree_item_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_tree_item_list(&mut self, v: ::protobuf::RepeatedField<OakAbilityTreeItemSaveGameData>) {
        self.tree_item_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tree_item_list(&mut self) -> &mut ::protobuf::RepeatedField<OakAbilityTreeItemSaveGameData> {
        &mut self.tree_item_list
    }

    // Take field
    pub fn take_tree_item_list(&mut self) -> ::protobuf::RepeatedField<OakAbilityTreeItemSaveGameData> {
        ::std::mem::replace(&mut self.tree_item_list, ::protobuf::RepeatedField::new())
    }

    // repeated .OakSave.OakAbilitySlotSaveGameData ability_slot_list = 3;


    pub fn get_ability_slot_list(&self) -> &[OakAbilitySlotSaveGameData] {
        &self.ability_slot_list
    }
    pub fn clear_ability_slot_list(&mut self) {
        self.ability_slot_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_ability_slot_list(&mut self, v: ::protobuf::RepeatedField<OakAbilitySlotSaveGameData>) {
        self.ability_slot_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ability_slot_list(&mut self) -> &mut ::protobuf::RepeatedField<OakAbilitySlotSaveGameData> {
        &mut self.ability_slot_list
    }

    // Take field
    pub fn take_ability_slot_list(&mut self) -> ::protobuf::RepeatedField<OakAbilitySlotSaveGameData> {
        ::std::mem::replace(&mut self.ability_slot_list, ::protobuf::RepeatedField::new())
    }

    // repeated .OakSave.OakActionAbilityAugmentSaveGameData augment_slot_list = 4;


    pub fn get_augment_slot_list(&self) -> &[OakActionAbilityAugmentSaveGameData] {
        &self.augment_slot_list
    }
    pub fn clear_augment_slot_list(&mut self) {
        self.augment_slot_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_augment_slot_list(&mut self, v: ::protobuf::RepeatedField<OakActionAbilityAugmentSaveGameData>) {
        self.augment_slot_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_augment_slot_list(&mut self) -> &mut ::protobuf::RepeatedField<OakActionAbilityAugmentSaveGameData> {
        &mut self.augment_slot_list
    }

    // Take field
    pub fn take_augment_slot_list(&mut self) -> ::protobuf::RepeatedField<OakActionAbilityAugmentSaveGameData> {
        ::std::mem::replace(&mut self.augment_slot_list, ::protobuf::RepeatedField::new())
    }

    // repeated .OakSave.OakActionAbilityAugmentConfigurationSaveGameData augment_configuration_list = 5;


    pub fn get_augment_configuration_list(&self) -> &[OakActionAbilityAugmentConfigurationSaveGameData] {
        &self.augment_configuration_list
    }
    pub fn clear_augment_configuration_list(&mut self) {
        self.augment_configuration_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_augment_configuration_list(&mut self, v: ::protobuf::RepeatedField<OakActionAbilityAugmentConfigurationSaveGameData>) {
        self.augment_configuration_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_augment_configuration_list(&mut self) -> &mut ::protobuf::RepeatedField<OakActionAbilityAugmentConfigurationSaveGameData> {
        &mut self.augment_configuration_list
    }

    // Take field
    pub fn take_augment_configuration_list(&mut self) -> ::protobuf::RepeatedField<OakActionAbilityAugmentConfigurationSaveGameData> {
        ::std::mem::replace(&mut self.augment_configuration_list, ::protobuf::RepeatedField::new())
    }

    // int32 tree_grade = 6;


    pub fn get_tree_grade(&self) -> i32 {
        self.tree_grade
    }
    pub fn clear_tree_grade(&mut self) {
        self.tree_grade = 0;
    }

    // Param is passed by value, moved
    pub fn set_tree_grade(&mut self, v: i32) {
        self.tree_grade = v;
    }
}

impl ::protobuf::Message for OakPlayerAbilitySaveGameData {
    fn is_initialized(&self) -> bool {
        for v in &self.tree_item_list {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ability_slot_list {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.augment_slot_list {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.augment_configuration_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ability_points = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tree_item_list)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ability_slot_list)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.augment_slot_list)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.augment_configuration_list)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.tree_grade = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ability_points != 0 {
            my_size += ::protobuf::rt::value_size(1, self.ability_points, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.tree_item_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.ability_slot_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.augment_slot_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.augment_configuration_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.tree_grade != 0 {
            my_size += ::protobuf::rt::value_size(6, self.tree_grade, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ability_points != 0 {
            os.write_int32(1, self.ability_points)?;
        }
        for v in &self.tree_item_list {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.ability_slot_list {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.augment_slot_list {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.augment_configuration_list {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.tree_grade != 0 {
            os.write_int32(6, self.tree_grade)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OakPlayerAbilitySaveGameData {
        OakPlayerAbilitySaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "ability_points",
                |m: &OakPlayerAbilitySaveGameData| { &m.ability_points },
                |m: &mut OakPlayerAbilitySaveGameData| { &mut m.ability_points },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OakAbilityTreeItemSaveGameData>>(
                "tree_item_list",
                |m: &OakPlayerAbilitySaveGameData| { &m.tree_item_list },
                |m: &mut OakPlayerAbilitySaveGameData| { &mut m.tree_item_list },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OakAbilitySlotSaveGameData>>(
                "ability_slot_list",
                |m: &OakPlayerAbilitySaveGameData| { &m.ability_slot_list },
                |m: &mut OakPlayerAbilitySaveGameData| { &mut m.ability_slot_list },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OakActionAbilityAugmentSaveGameData>>(
                "augment_slot_list",
                |m: &OakPlayerAbilitySaveGameData| { &m.augment_slot_list },
                |m: &mut OakPlayerAbilitySaveGameData| { &mut m.augment_slot_list },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OakActionAbilityAugmentConfigurationSaveGameData>>(
                "augment_configuration_list",
                |m: &OakPlayerAbilitySaveGameData| { &m.augment_configuration_list },
                |m: &mut OakPlayerAbilitySaveGameData| { &mut m.augment_configuration_list },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "tree_grade",
                |m: &OakPlayerAbilitySaveGameData| { &m.tree_grade },
                |m: &mut OakPlayerAbilitySaveGameData| { &mut m.tree_grade },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OakPlayerAbilitySaveGameData>(
                "OakPlayerAbilitySaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OakPlayerAbilitySaveGameData {
        static instance: ::protobuf::rt::LazyV2<OakPlayerAbilitySaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OakPlayerAbilitySaveGameData::new)
    }
}

impl ::protobuf::Clear for OakPlayerAbilitySaveGameData {
    fn clear(&mut self) {
        self.ability_points = 0;
        self.tree_item_list.clear();
        self.ability_slot_list.clear();
        self.augment_slot_list.clear();
        self.augment_configuration_list.clear();
        self.tree_grade = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OakPlayerAbilitySaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OakPlayerAbilitySaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MissionStatusPlayerSaveGameData {
    // message fields
    pub status: MissionStatusPlayerSaveGameData_MissionState,
    pub has_been_viewed_in_log: bool,
    pub objectives_progress: ::std::vec::Vec<i32>,
    pub mission_class_path: ::std::string::String,
    pub active_objective_set_path: ::std::string::String,
    pub dlc_package_id: u32,
    pub kickoff_played: bool,
    pub league_instance: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MissionStatusPlayerSaveGameData {
    fn default() -> &'a MissionStatusPlayerSaveGameData {
        <MissionStatusPlayerSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl MissionStatusPlayerSaveGameData {
    pub fn new() -> MissionStatusPlayerSaveGameData {
        ::std::default::Default::default()
    }

    // .OakSave.MissionStatusPlayerSaveGameData.MissionState status = 1;


    pub fn get_status(&self) -> MissionStatusPlayerSaveGameData_MissionState {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = MissionStatusPlayerSaveGameData_MissionState::MS_NotStarted;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: MissionStatusPlayerSaveGameData_MissionState) {
        self.status = v;
    }

    // bool has_been_viewed_in_log = 2;


    pub fn get_has_been_viewed_in_log(&self) -> bool {
        self.has_been_viewed_in_log
    }
    pub fn clear_has_been_viewed_in_log(&mut self) {
        self.has_been_viewed_in_log = false;
    }

    // Param is passed by value, moved
    pub fn set_has_been_viewed_in_log(&mut self, v: bool) {
        self.has_been_viewed_in_log = v;
    }

    // repeated int32 objectives_progress = 3;


    pub fn get_objectives_progress(&self) -> &[i32] {
        &self.objectives_progress
    }
    pub fn clear_objectives_progress(&mut self) {
        self.objectives_progress.clear();
    }

    // Param is passed by value, moved
    pub fn set_objectives_progress(&mut self, v: ::std::vec::Vec<i32>) {
        self.objectives_progress = v;
    }

    // Mutable pointer to the field.
    pub fn mut_objectives_progress(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.objectives_progress
    }

    // Take field
    pub fn take_objectives_progress(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.objectives_progress, ::std::vec::Vec::new())
    }

    // string mission_class_path = 4;


    pub fn get_mission_class_path(&self) -> &str {
        &self.mission_class_path
    }
    pub fn clear_mission_class_path(&mut self) {
        self.mission_class_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_mission_class_path(&mut self, v: ::std::string::String) {
        self.mission_class_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mission_class_path(&mut self) -> &mut ::std::string::String {
        &mut self.mission_class_path
    }

    // Take field
    pub fn take_mission_class_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mission_class_path, ::std::string::String::new())
    }

    // string active_objective_set_path = 5;


    pub fn get_active_objective_set_path(&self) -> &str {
        &self.active_objective_set_path
    }
    pub fn clear_active_objective_set_path(&mut self) {
        self.active_objective_set_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_active_objective_set_path(&mut self, v: ::std::string::String) {
        self.active_objective_set_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_active_objective_set_path(&mut self) -> &mut ::std::string::String {
        &mut self.active_objective_set_path
    }

    // Take field
    pub fn take_active_objective_set_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.active_objective_set_path, ::std::string::String::new())
    }

    // uint32 dlc_package_id = 6;


    pub fn get_dlc_package_id(&self) -> u32 {
        self.dlc_package_id
    }
    pub fn clear_dlc_package_id(&mut self) {
        self.dlc_package_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_dlc_package_id(&mut self, v: u32) {
        self.dlc_package_id = v;
    }

    // bool kickoff_played = 7;


    pub fn get_kickoff_played(&self) -> bool {
        self.kickoff_played
    }
    pub fn clear_kickoff_played(&mut self) {
        self.kickoff_played = false;
    }

    // Param is passed by value, moved
    pub fn set_kickoff_played(&mut self, v: bool) {
        self.kickoff_played = v;
    }

    // uint32 league_instance = 8;


    pub fn get_league_instance(&self) -> u32 {
        self.league_instance
    }
    pub fn clear_league_instance(&mut self) {
        self.league_instance = 0;
    }

    // Param is passed by value, moved
    pub fn set_league_instance(&mut self, v: u32) {
        self.league_instance = v;
    }
}

impl ::protobuf::Message for MissionStatusPlayerSaveGameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_been_viewed_in_log = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.objectives_progress)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mission_class_path)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.active_objective_set_path)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dlc_package_id = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.kickoff_played = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_instance = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.status != MissionStatusPlayerSaveGameData_MissionState::MS_NotStarted {
            my_size += ::protobuf::rt::enum_size(1, self.status);
        }
        if self.has_been_viewed_in_log != false {
            my_size += 2;
        }
        for value in &self.objectives_progress {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if !self.mission_class_path.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.mission_class_path);
        }
        if !self.active_objective_set_path.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.active_objective_set_path);
        }
        if self.dlc_package_id != 0 {
            my_size += ::protobuf::rt::value_size(6, self.dlc_package_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.kickoff_played != false {
            my_size += 2;
        }
        if self.league_instance != 0 {
            my_size += ::protobuf::rt::value_size(8, self.league_instance, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.status != MissionStatusPlayerSaveGameData_MissionState::MS_NotStarted {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        if self.has_been_viewed_in_log != false {
            os.write_bool(2, self.has_been_viewed_in_log)?;
        }
        for v in &self.objectives_progress {
            os.write_int32(3, *v)?;
        };
        if !self.mission_class_path.is_empty() {
            os.write_string(4, &self.mission_class_path)?;
        }
        if !self.active_objective_set_path.is_empty() {
            os.write_string(5, &self.active_objective_set_path)?;
        }
        if self.dlc_package_id != 0 {
            os.write_uint32(6, self.dlc_package_id)?;
        }
        if self.kickoff_played != false {
            os.write_bool(7, self.kickoff_played)?;
        }
        if self.league_instance != 0 {
            os.write_uint32(8, self.league_instance)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MissionStatusPlayerSaveGameData {
        MissionStatusPlayerSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MissionStatusPlayerSaveGameData_MissionState>>(
                "status",
                |m: &MissionStatusPlayerSaveGameData| { &m.status },
                |m: &mut MissionStatusPlayerSaveGameData| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_been_viewed_in_log",
                |m: &MissionStatusPlayerSaveGameData| { &m.has_been_viewed_in_log },
                |m: &mut MissionStatusPlayerSaveGameData| { &mut m.has_been_viewed_in_log },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "objectives_progress",
                |m: &MissionStatusPlayerSaveGameData| { &m.objectives_progress },
                |m: &mut MissionStatusPlayerSaveGameData| { &mut m.objectives_progress },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mission_class_path",
                |m: &MissionStatusPlayerSaveGameData| { &m.mission_class_path },
                |m: &mut MissionStatusPlayerSaveGameData| { &mut m.mission_class_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "active_objective_set_path",
                |m: &MissionStatusPlayerSaveGameData| { &m.active_objective_set_path },
                |m: &mut MissionStatusPlayerSaveGameData| { &mut m.active_objective_set_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "dlc_package_id",
                |m: &MissionStatusPlayerSaveGameData| { &m.dlc_package_id },
                |m: &mut MissionStatusPlayerSaveGameData| { &mut m.dlc_package_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "kickoff_played",
                |m: &MissionStatusPlayerSaveGameData| { &m.kickoff_played },
                |m: &mut MissionStatusPlayerSaveGameData| { &mut m.kickoff_played },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "league_instance",
                |m: &MissionStatusPlayerSaveGameData| { &m.league_instance },
                |m: &mut MissionStatusPlayerSaveGameData| { &mut m.league_instance },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MissionStatusPlayerSaveGameData>(
                "MissionStatusPlayerSaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MissionStatusPlayerSaveGameData {
        static instance: ::protobuf::rt::LazyV2<MissionStatusPlayerSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MissionStatusPlayerSaveGameData::new)
    }
}

impl ::protobuf::Clear for MissionStatusPlayerSaveGameData {
    fn clear(&mut self) {
        self.status = MissionStatusPlayerSaveGameData_MissionState::MS_NotStarted;
        self.has_been_viewed_in_log = false;
        self.objectives_progress.clear();
        self.mission_class_path.clear();
        self.active_objective_set_path.clear();
        self.dlc_package_id = 0;
        self.kickoff_played = false;
        self.league_instance = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MissionStatusPlayerSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MissionStatusPlayerSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MissionStatusPlayerSaveGameData_MissionState {
    MS_NotStarted = 0,
    MS_Active = 1,
    MS_Complete = 2,
    MS_Failed = 3,
    MS_Unknown = 4,
}

impl ::protobuf::ProtobufEnum for MissionStatusPlayerSaveGameData_MissionState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MissionStatusPlayerSaveGameData_MissionState> {
        match value {
            0 => ::std::option::Option::Some(MissionStatusPlayerSaveGameData_MissionState::MS_NotStarted),
            1 => ::std::option::Option::Some(MissionStatusPlayerSaveGameData_MissionState::MS_Active),
            2 => ::std::option::Option::Some(MissionStatusPlayerSaveGameData_MissionState::MS_Complete),
            3 => ::std::option::Option::Some(MissionStatusPlayerSaveGameData_MissionState::MS_Failed),
            4 => ::std::option::Option::Some(MissionStatusPlayerSaveGameData_MissionState::MS_Unknown),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MissionStatusPlayerSaveGameData_MissionState] = &[
            MissionStatusPlayerSaveGameData_MissionState::MS_NotStarted,
            MissionStatusPlayerSaveGameData_MissionState::MS_Active,
            MissionStatusPlayerSaveGameData_MissionState::MS_Complete,
            MissionStatusPlayerSaveGameData_MissionState::MS_Failed,
            MissionStatusPlayerSaveGameData_MissionState::MS_Unknown,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<MissionStatusPlayerSaveGameData_MissionState>("MissionStatusPlayerSaveGameData.MissionState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for MissionStatusPlayerSaveGameData_MissionState {
}

impl ::std::default::Default for MissionStatusPlayerSaveGameData_MissionState {
    fn default() -> Self {
        MissionStatusPlayerSaveGameData_MissionState::MS_NotStarted
    }
}

impl ::protobuf::reflect::ProtobufValue for MissionStatusPlayerSaveGameData_MissionState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MissionPlaythroughSaveGameData {
    // message fields
    pub mission_list: ::protobuf::RepeatedField<MissionStatusPlayerSaveGameData>,
    pub tracked_mission_class_path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MissionPlaythroughSaveGameData {
    fn default() -> &'a MissionPlaythroughSaveGameData {
        <MissionPlaythroughSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl MissionPlaythroughSaveGameData {
    pub fn new() -> MissionPlaythroughSaveGameData {
        ::std::default::Default::default()
    }

    // repeated .OakSave.MissionStatusPlayerSaveGameData mission_list = 1;


    pub fn get_mission_list(&self) -> &[MissionStatusPlayerSaveGameData] {
        &self.mission_list
    }
    pub fn clear_mission_list(&mut self) {
        self.mission_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_mission_list(&mut self, v: ::protobuf::RepeatedField<MissionStatusPlayerSaveGameData>) {
        self.mission_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mission_list(&mut self) -> &mut ::protobuf::RepeatedField<MissionStatusPlayerSaveGameData> {
        &mut self.mission_list
    }

    // Take field
    pub fn take_mission_list(&mut self) -> ::protobuf::RepeatedField<MissionStatusPlayerSaveGameData> {
        ::std::mem::replace(&mut self.mission_list, ::protobuf::RepeatedField::new())
    }

    // string tracked_mission_class_path = 2;


    pub fn get_tracked_mission_class_path(&self) -> &str {
        &self.tracked_mission_class_path
    }
    pub fn clear_tracked_mission_class_path(&mut self) {
        self.tracked_mission_class_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_tracked_mission_class_path(&mut self, v: ::std::string::String) {
        self.tracked_mission_class_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tracked_mission_class_path(&mut self) -> &mut ::std::string::String {
        &mut self.tracked_mission_class_path
    }

    // Take field
    pub fn take_tracked_mission_class_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tracked_mission_class_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MissionPlaythroughSaveGameData {
    fn is_initialized(&self) -> bool {
        for v in &self.mission_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.mission_list)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tracked_mission_class_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.mission_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.tracked_mission_class_path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.tracked_mission_class_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.mission_list {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.tracked_mission_class_path.is_empty() {
            os.write_string(2, &self.tracked_mission_class_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MissionPlaythroughSaveGameData {
        MissionPlaythroughSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MissionStatusPlayerSaveGameData>>(
                "mission_list",
                |m: &MissionPlaythroughSaveGameData| { &m.mission_list },
                |m: &mut MissionPlaythroughSaveGameData| { &mut m.mission_list },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tracked_mission_class_path",
                |m: &MissionPlaythroughSaveGameData| { &m.tracked_mission_class_path },
                |m: &mut MissionPlaythroughSaveGameData| { &mut m.tracked_mission_class_path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MissionPlaythroughSaveGameData>(
                "MissionPlaythroughSaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MissionPlaythroughSaveGameData {
        static instance: ::protobuf::rt::LazyV2<MissionPlaythroughSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MissionPlaythroughSaveGameData::new)
    }
}

impl ::protobuf::Clear for MissionPlaythroughSaveGameData {
    fn clear(&mut self) {
        self.mission_list.clear();
        self.tracked_mission_class_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MissionPlaythroughSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MissionPlaythroughSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActiveFastTravelSaveData {
    // message fields
    pub active_travel_station_name: ::std::string::String,
    pub blacklisted: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActiveFastTravelSaveData {
    fn default() -> &'a ActiveFastTravelSaveData {
        <ActiveFastTravelSaveData as ::protobuf::Message>::default_instance()
    }
}

impl ActiveFastTravelSaveData {
    pub fn new() -> ActiveFastTravelSaveData {
        ::std::default::Default::default()
    }

    // string active_travel_station_name = 1;


    pub fn get_active_travel_station_name(&self) -> &str {
        &self.active_travel_station_name
    }
    pub fn clear_active_travel_station_name(&mut self) {
        self.active_travel_station_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_active_travel_station_name(&mut self, v: ::std::string::String) {
        self.active_travel_station_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_active_travel_station_name(&mut self) -> &mut ::std::string::String {
        &mut self.active_travel_station_name
    }

    // Take field
    pub fn take_active_travel_station_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.active_travel_station_name, ::std::string::String::new())
    }

    // bool blacklisted = 2;


    pub fn get_blacklisted(&self) -> bool {
        self.blacklisted
    }
    pub fn clear_blacklisted(&mut self) {
        self.blacklisted = false;
    }

    // Param is passed by value, moved
    pub fn set_blacklisted(&mut self, v: bool) {
        self.blacklisted = v;
    }
}

impl ::protobuf::Message for ActiveFastTravelSaveData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.active_travel_station_name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.blacklisted = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.active_travel_station_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.active_travel_station_name);
        }
        if self.blacklisted != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.active_travel_station_name.is_empty() {
            os.write_string(1, &self.active_travel_station_name)?;
        }
        if self.blacklisted != false {
            os.write_bool(2, self.blacklisted)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActiveFastTravelSaveData {
        ActiveFastTravelSaveData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "active_travel_station_name",
                |m: &ActiveFastTravelSaveData| { &m.active_travel_station_name },
                |m: &mut ActiveFastTravelSaveData| { &mut m.active_travel_station_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "blacklisted",
                |m: &ActiveFastTravelSaveData| { &m.blacklisted },
                |m: &mut ActiveFastTravelSaveData| { &mut m.blacklisted },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActiveFastTravelSaveData>(
                "ActiveFastTravelSaveData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActiveFastTravelSaveData {
        static instance: ::protobuf::rt::LazyV2<ActiveFastTravelSaveData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActiveFastTravelSaveData::new)
    }
}

impl ::protobuf::Clear for ActiveFastTravelSaveData {
    fn clear(&mut self) {
        self.active_travel_station_name.clear();
        self.blacklisted = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActiveFastTravelSaveData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActiveFastTravelSaveData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlaythroughActiveFastTravelSaveData {
    // message fields
    pub active_travel_stations: ::protobuf::RepeatedField<ActiveFastTravelSaveData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlaythroughActiveFastTravelSaveData {
    fn default() -> &'a PlaythroughActiveFastTravelSaveData {
        <PlaythroughActiveFastTravelSaveData as ::protobuf::Message>::default_instance()
    }
}

impl PlaythroughActiveFastTravelSaveData {
    pub fn new() -> PlaythroughActiveFastTravelSaveData {
        ::std::default::Default::default()
    }

    // repeated .OakSave.ActiveFastTravelSaveData active_travel_stations = 1;


    pub fn get_active_travel_stations(&self) -> &[ActiveFastTravelSaveData] {
        &self.active_travel_stations
    }
    pub fn clear_active_travel_stations(&mut self) {
        self.active_travel_stations.clear();
    }

    // Param is passed by value, moved
    pub fn set_active_travel_stations(&mut self, v: ::protobuf::RepeatedField<ActiveFastTravelSaveData>) {
        self.active_travel_stations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_active_travel_stations(&mut self) -> &mut ::protobuf::RepeatedField<ActiveFastTravelSaveData> {
        &mut self.active_travel_stations
    }

    // Take field
    pub fn take_active_travel_stations(&mut self) -> ::protobuf::RepeatedField<ActiveFastTravelSaveData> {
        ::std::mem::replace(&mut self.active_travel_stations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PlaythroughActiveFastTravelSaveData {
    fn is_initialized(&self) -> bool {
        for v in &self.active_travel_stations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.active_travel_stations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.active_travel_stations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.active_travel_stations {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlaythroughActiveFastTravelSaveData {
        PlaythroughActiveFastTravelSaveData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ActiveFastTravelSaveData>>(
                "active_travel_stations",
                |m: &PlaythroughActiveFastTravelSaveData| { &m.active_travel_stations },
                |m: &mut PlaythroughActiveFastTravelSaveData| { &mut m.active_travel_stations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlaythroughActiveFastTravelSaveData>(
                "PlaythroughActiveFastTravelSaveData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlaythroughActiveFastTravelSaveData {
        static instance: ::protobuf::rt::LazyV2<PlaythroughActiveFastTravelSaveData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlaythroughActiveFastTravelSaveData::new)
    }
}

impl ::protobuf::Clear for PlaythroughActiveFastTravelSaveData {
    fn clear(&mut self) {
        self.active_travel_stations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlaythroughActiveFastTravelSaveData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlaythroughActiveFastTravelSaveData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DiscoveredAreaInfo {
    // message fields
    pub discovered_area_name: ::std::string::String,
    pub discovered_playthroughs: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DiscoveredAreaInfo {
    fn default() -> &'a DiscoveredAreaInfo {
        <DiscoveredAreaInfo as ::protobuf::Message>::default_instance()
    }
}

impl DiscoveredAreaInfo {
    pub fn new() -> DiscoveredAreaInfo {
        ::std::default::Default::default()
    }

    // string discovered_area_name = 1;


    pub fn get_discovered_area_name(&self) -> &str {
        &self.discovered_area_name
    }
    pub fn clear_discovered_area_name(&mut self) {
        self.discovered_area_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_discovered_area_name(&mut self, v: ::std::string::String) {
        self.discovered_area_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_discovered_area_name(&mut self) -> &mut ::std::string::String {
        &mut self.discovered_area_name
    }

    // Take field
    pub fn take_discovered_area_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.discovered_area_name, ::std::string::String::new())
    }

    // uint32 discovered_playthroughs = 2;


    pub fn get_discovered_playthroughs(&self) -> u32 {
        self.discovered_playthroughs
    }
    pub fn clear_discovered_playthroughs(&mut self) {
        self.discovered_playthroughs = 0;
    }

    // Param is passed by value, moved
    pub fn set_discovered_playthroughs(&mut self, v: u32) {
        self.discovered_playthroughs = v;
    }
}

impl ::protobuf::Message for DiscoveredAreaInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.discovered_area_name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.discovered_playthroughs = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.discovered_area_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.discovered_area_name);
        }
        if self.discovered_playthroughs != 0 {
            my_size += ::protobuf::rt::value_size(2, self.discovered_playthroughs, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.discovered_area_name.is_empty() {
            os.write_string(1, &self.discovered_area_name)?;
        }
        if self.discovered_playthroughs != 0 {
            os.write_uint32(2, self.discovered_playthroughs)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DiscoveredAreaInfo {
        DiscoveredAreaInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "discovered_area_name",
                |m: &DiscoveredAreaInfo| { &m.discovered_area_name },
                |m: &mut DiscoveredAreaInfo| { &mut m.discovered_area_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "discovered_playthroughs",
                |m: &DiscoveredAreaInfo| { &m.discovered_playthroughs },
                |m: &mut DiscoveredAreaInfo| { &mut m.discovered_playthroughs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DiscoveredAreaInfo>(
                "DiscoveredAreaInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DiscoveredAreaInfo {
        static instance: ::protobuf::rt::LazyV2<DiscoveredAreaInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DiscoveredAreaInfo::new)
    }
}

impl ::protobuf::Clear for DiscoveredAreaInfo {
    fn clear(&mut self) {
        self.discovered_area_name.clear();
        self.discovered_playthroughs = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DiscoveredAreaInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DiscoveredAreaInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DiscoveredLevelInfo {
    // message fields
    pub discovered_level_name: ::std::string::String,
    pub discovered_playthroughs: u32,
    pub discovered_area_info: ::protobuf::RepeatedField<DiscoveredAreaInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DiscoveredLevelInfo {
    fn default() -> &'a DiscoveredLevelInfo {
        <DiscoveredLevelInfo as ::protobuf::Message>::default_instance()
    }
}

impl DiscoveredLevelInfo {
    pub fn new() -> DiscoveredLevelInfo {
        ::std::default::Default::default()
    }

    // string discovered_level_name = 1;


    pub fn get_discovered_level_name(&self) -> &str {
        &self.discovered_level_name
    }
    pub fn clear_discovered_level_name(&mut self) {
        self.discovered_level_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_discovered_level_name(&mut self, v: ::std::string::String) {
        self.discovered_level_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_discovered_level_name(&mut self) -> &mut ::std::string::String {
        &mut self.discovered_level_name
    }

    // Take field
    pub fn take_discovered_level_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.discovered_level_name, ::std::string::String::new())
    }

    // uint32 discovered_playthroughs = 3;


    pub fn get_discovered_playthroughs(&self) -> u32 {
        self.discovered_playthroughs
    }
    pub fn clear_discovered_playthroughs(&mut self) {
        self.discovered_playthroughs = 0;
    }

    // Param is passed by value, moved
    pub fn set_discovered_playthroughs(&mut self, v: u32) {
        self.discovered_playthroughs = v;
    }

    // repeated .OakSave.DiscoveredAreaInfo discovered_area_info = 4;


    pub fn get_discovered_area_info(&self) -> &[DiscoveredAreaInfo] {
        &self.discovered_area_info
    }
    pub fn clear_discovered_area_info(&mut self) {
        self.discovered_area_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_discovered_area_info(&mut self, v: ::protobuf::RepeatedField<DiscoveredAreaInfo>) {
        self.discovered_area_info = v;
    }

    // Mutable pointer to the field.
    pub fn mut_discovered_area_info(&mut self) -> &mut ::protobuf::RepeatedField<DiscoveredAreaInfo> {
        &mut self.discovered_area_info
    }

    // Take field
    pub fn take_discovered_area_info(&mut self) -> ::protobuf::RepeatedField<DiscoveredAreaInfo> {
        ::std::mem::replace(&mut self.discovered_area_info, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DiscoveredLevelInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.discovered_area_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.discovered_level_name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.discovered_playthroughs = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.discovered_area_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.discovered_level_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.discovered_level_name);
        }
        if self.discovered_playthroughs != 0 {
            my_size += ::protobuf::rt::value_size(3, self.discovered_playthroughs, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.discovered_area_info {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.discovered_level_name.is_empty() {
            os.write_string(1, &self.discovered_level_name)?;
        }
        if self.discovered_playthroughs != 0 {
            os.write_uint32(3, self.discovered_playthroughs)?;
        }
        for v in &self.discovered_area_info {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DiscoveredLevelInfo {
        DiscoveredLevelInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "discovered_level_name",
                |m: &DiscoveredLevelInfo| { &m.discovered_level_name },
                |m: &mut DiscoveredLevelInfo| { &mut m.discovered_level_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "discovered_playthroughs",
                |m: &DiscoveredLevelInfo| { &m.discovered_playthroughs },
                |m: &mut DiscoveredLevelInfo| { &mut m.discovered_playthroughs },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DiscoveredAreaInfo>>(
                "discovered_area_info",
                |m: &DiscoveredLevelInfo| { &m.discovered_area_info },
                |m: &mut DiscoveredLevelInfo| { &mut m.discovered_area_info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DiscoveredLevelInfo>(
                "DiscoveredLevelInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DiscoveredLevelInfo {
        static instance: ::protobuf::rt::LazyV2<DiscoveredLevelInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DiscoveredLevelInfo::new)
    }
}

impl ::protobuf::Clear for DiscoveredLevelInfo {
    fn clear(&mut self) {
        self.discovered_level_name.clear();
        self.discovered_playthroughs = 0;
        self.discovered_area_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DiscoveredLevelInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DiscoveredLevelInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DiscoveredPlanetInfo {
    // message fields
    pub discovered_planet: ::std::string::String,
    pub is_new_planet: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DiscoveredPlanetInfo {
    fn default() -> &'a DiscoveredPlanetInfo {
        <DiscoveredPlanetInfo as ::protobuf::Message>::default_instance()
    }
}

impl DiscoveredPlanetInfo {
    pub fn new() -> DiscoveredPlanetInfo {
        ::std::default::Default::default()
    }

    // string discovered_planet = 1;


    pub fn get_discovered_planet(&self) -> &str {
        &self.discovered_planet
    }
    pub fn clear_discovered_planet(&mut self) {
        self.discovered_planet.clear();
    }

    // Param is passed by value, moved
    pub fn set_discovered_planet(&mut self, v: ::std::string::String) {
        self.discovered_planet = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_discovered_planet(&mut self) -> &mut ::std::string::String {
        &mut self.discovered_planet
    }

    // Take field
    pub fn take_discovered_planet(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.discovered_planet, ::std::string::String::new())
    }

    // bool is_new_planet = 2;


    pub fn get_is_new_planet(&self) -> bool {
        self.is_new_planet
    }
    pub fn clear_is_new_planet(&mut self) {
        self.is_new_planet = false;
    }

    // Param is passed by value, moved
    pub fn set_is_new_planet(&mut self, v: bool) {
        self.is_new_planet = v;
    }
}

impl ::protobuf::Message for DiscoveredPlanetInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.discovered_planet)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_new_planet = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.discovered_planet.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.discovered_planet);
        }
        if self.is_new_planet != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.discovered_planet.is_empty() {
            os.write_string(1, &self.discovered_planet)?;
        }
        if self.is_new_planet != false {
            os.write_bool(2, self.is_new_planet)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DiscoveredPlanetInfo {
        DiscoveredPlanetInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "discovered_planet",
                |m: &DiscoveredPlanetInfo| { &m.discovered_planet },
                |m: &mut DiscoveredPlanetInfo| { &mut m.discovered_planet },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_new_planet",
                |m: &DiscoveredPlanetInfo| { &m.is_new_planet },
                |m: &mut DiscoveredPlanetInfo| { &mut m.is_new_planet },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DiscoveredPlanetInfo>(
                "DiscoveredPlanetInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DiscoveredPlanetInfo {
        static instance: ::protobuf::rt::LazyV2<DiscoveredPlanetInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DiscoveredPlanetInfo::new)
    }
}

impl ::protobuf::Clear for DiscoveredPlanetInfo {
    fn clear(&mut self) {
        self.discovered_planet.clear();
        self.is_new_planet = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DiscoveredPlanetInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DiscoveredPlanetInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DiscoverySaveData {
    // message fields
    pub discovered_level_info: ::protobuf::RepeatedField<DiscoveredLevelInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DiscoverySaveData {
    fn default() -> &'a DiscoverySaveData {
        <DiscoverySaveData as ::protobuf::Message>::default_instance()
    }
}

impl DiscoverySaveData {
    pub fn new() -> DiscoverySaveData {
        ::std::default::Default::default()
    }

    // repeated .OakSave.DiscoveredLevelInfo discovered_level_info = 1;


    pub fn get_discovered_level_info(&self) -> &[DiscoveredLevelInfo] {
        &self.discovered_level_info
    }
    pub fn clear_discovered_level_info(&mut self) {
        self.discovered_level_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_discovered_level_info(&mut self, v: ::protobuf::RepeatedField<DiscoveredLevelInfo>) {
        self.discovered_level_info = v;
    }

    // Mutable pointer to the field.
    pub fn mut_discovered_level_info(&mut self) -> &mut ::protobuf::RepeatedField<DiscoveredLevelInfo> {
        &mut self.discovered_level_info
    }

    // Take field
    pub fn take_discovered_level_info(&mut self) -> ::protobuf::RepeatedField<DiscoveredLevelInfo> {
        ::std::mem::replace(&mut self.discovered_level_info, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DiscoverySaveData {
    fn is_initialized(&self) -> bool {
        for v in &self.discovered_level_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.discovered_level_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.discovered_level_info {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.discovered_level_info {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DiscoverySaveData {
        DiscoverySaveData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DiscoveredLevelInfo>>(
                "discovered_level_info",
                |m: &DiscoverySaveData| { &m.discovered_level_info },
                |m: &mut DiscoverySaveData| { &mut m.discovered_level_info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DiscoverySaveData>(
                "DiscoverySaveData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DiscoverySaveData {
        static instance: ::protobuf::rt::LazyV2<DiscoverySaveData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DiscoverySaveData::new)
    }
}

impl ::protobuf::Clear for DiscoverySaveData {
    fn clear(&mut self) {
        self.discovered_level_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DiscoverySaveData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DiscoverySaveData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VehicleUnlockedSaveGameData {
    // message fields
    pub asset_path: ::std::string::String,
    pub just_unlocked: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VehicleUnlockedSaveGameData {
    fn default() -> &'a VehicleUnlockedSaveGameData {
        <VehicleUnlockedSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl VehicleUnlockedSaveGameData {
    pub fn new() -> VehicleUnlockedSaveGameData {
        ::std::default::Default::default()
    }

    // string asset_path = 1;


    pub fn get_asset_path(&self) -> &str {
        &self.asset_path
    }
    pub fn clear_asset_path(&mut self) {
        self.asset_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_asset_path(&mut self, v: ::std::string::String) {
        self.asset_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_asset_path(&mut self) -> &mut ::std::string::String {
        &mut self.asset_path
    }

    // Take field
    pub fn take_asset_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.asset_path, ::std::string::String::new())
    }

    // bool just_unlocked = 2;


    pub fn get_just_unlocked(&self) -> bool {
        self.just_unlocked
    }
    pub fn clear_just_unlocked(&mut self) {
        self.just_unlocked = false;
    }

    // Param is passed by value, moved
    pub fn set_just_unlocked(&mut self, v: bool) {
        self.just_unlocked = v;
    }
}

impl ::protobuf::Message for VehicleUnlockedSaveGameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.asset_path)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.just_unlocked = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.asset_path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.asset_path);
        }
        if self.just_unlocked != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.asset_path.is_empty() {
            os.write_string(1, &self.asset_path)?;
        }
        if self.just_unlocked != false {
            os.write_bool(2, self.just_unlocked)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VehicleUnlockedSaveGameData {
        VehicleUnlockedSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "asset_path",
                |m: &VehicleUnlockedSaveGameData| { &m.asset_path },
                |m: &mut VehicleUnlockedSaveGameData| { &mut m.asset_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "just_unlocked",
                |m: &VehicleUnlockedSaveGameData| { &m.just_unlocked },
                |m: &mut VehicleUnlockedSaveGameData| { &mut m.just_unlocked },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VehicleUnlockedSaveGameData>(
                "VehicleUnlockedSaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VehicleUnlockedSaveGameData {
        static instance: ::protobuf::rt::LazyV2<VehicleUnlockedSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VehicleUnlockedSaveGameData::new)
    }
}

impl ::protobuf::Clear for VehicleUnlockedSaveGameData {
    fn clear(&mut self) {
        self.asset_path.clear();
        self.just_unlocked = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VehicleUnlockedSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VehicleUnlockedSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OakCARMenuVehicleConfigSaveData {
    // message fields
    pub loadout_save_name: ::std::string::String,
    pub body_asset_path: ::std::string::String,
    pub wheel_asset_path: ::std::string::String,
    pub armor_asset_path: ::std::string::String,
    pub core_mod_asset_path: ::std::string::String,
    pub gunner_weapon_asset_path: ::std::string::String,
    pub driver_weapon_asset_path: ::std::string::String,
    pub ornament_asset_path: ::std::string::String,
    pub material_decal_asset_path: ::std::string::String,
    pub material_asset_path: ::std::string::String,
    pub color_index_1: i32,
    pub color_index_2: i32,
    pub color_index_3: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OakCARMenuVehicleConfigSaveData {
    fn default() -> &'a OakCARMenuVehicleConfigSaveData {
        <OakCARMenuVehicleConfigSaveData as ::protobuf::Message>::default_instance()
    }
}

impl OakCARMenuVehicleConfigSaveData {
    pub fn new() -> OakCARMenuVehicleConfigSaveData {
        ::std::default::Default::default()
    }

    // string loadout_save_name = 1;


    pub fn get_loadout_save_name(&self) -> &str {
        &self.loadout_save_name
    }
    pub fn clear_loadout_save_name(&mut self) {
        self.loadout_save_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_loadout_save_name(&mut self, v: ::std::string::String) {
        self.loadout_save_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loadout_save_name(&mut self) -> &mut ::std::string::String {
        &mut self.loadout_save_name
    }

    // Take field
    pub fn take_loadout_save_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.loadout_save_name, ::std::string::String::new())
    }

    // string body_asset_path = 2;


    pub fn get_body_asset_path(&self) -> &str {
        &self.body_asset_path
    }
    pub fn clear_body_asset_path(&mut self) {
        self.body_asset_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_body_asset_path(&mut self, v: ::std::string::String) {
        self.body_asset_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body_asset_path(&mut self) -> &mut ::std::string::String {
        &mut self.body_asset_path
    }

    // Take field
    pub fn take_body_asset_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.body_asset_path, ::std::string::String::new())
    }

    // string wheel_asset_path = 3;


    pub fn get_wheel_asset_path(&self) -> &str {
        &self.wheel_asset_path
    }
    pub fn clear_wheel_asset_path(&mut self) {
        self.wheel_asset_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_wheel_asset_path(&mut self, v: ::std::string::String) {
        self.wheel_asset_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wheel_asset_path(&mut self) -> &mut ::std::string::String {
        &mut self.wheel_asset_path
    }

    // Take field
    pub fn take_wheel_asset_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.wheel_asset_path, ::std::string::String::new())
    }

    // string armor_asset_path = 4;


    pub fn get_armor_asset_path(&self) -> &str {
        &self.armor_asset_path
    }
    pub fn clear_armor_asset_path(&mut self) {
        self.armor_asset_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_armor_asset_path(&mut self, v: ::std::string::String) {
        self.armor_asset_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_armor_asset_path(&mut self) -> &mut ::std::string::String {
        &mut self.armor_asset_path
    }

    // Take field
    pub fn take_armor_asset_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.armor_asset_path, ::std::string::String::new())
    }

    // string core_mod_asset_path = 5;


    pub fn get_core_mod_asset_path(&self) -> &str {
        &self.core_mod_asset_path
    }
    pub fn clear_core_mod_asset_path(&mut self) {
        self.core_mod_asset_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_core_mod_asset_path(&mut self, v: ::std::string::String) {
        self.core_mod_asset_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_core_mod_asset_path(&mut self) -> &mut ::std::string::String {
        &mut self.core_mod_asset_path
    }

    // Take field
    pub fn take_core_mod_asset_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.core_mod_asset_path, ::std::string::String::new())
    }

    // string gunner_weapon_asset_path = 6;


    pub fn get_gunner_weapon_asset_path(&self) -> &str {
        &self.gunner_weapon_asset_path
    }
    pub fn clear_gunner_weapon_asset_path(&mut self) {
        self.gunner_weapon_asset_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_gunner_weapon_asset_path(&mut self, v: ::std::string::String) {
        self.gunner_weapon_asset_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gunner_weapon_asset_path(&mut self) -> &mut ::std::string::String {
        &mut self.gunner_weapon_asset_path
    }

    // Take field
    pub fn take_gunner_weapon_asset_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.gunner_weapon_asset_path, ::std::string::String::new())
    }

    // string driver_weapon_asset_path = 7;


    pub fn get_driver_weapon_asset_path(&self) -> &str {
        &self.driver_weapon_asset_path
    }
    pub fn clear_driver_weapon_asset_path(&mut self) {
        self.driver_weapon_asset_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_driver_weapon_asset_path(&mut self, v: ::std::string::String) {
        self.driver_weapon_asset_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driver_weapon_asset_path(&mut self) -> &mut ::std::string::String {
        &mut self.driver_weapon_asset_path
    }

    // Take field
    pub fn take_driver_weapon_asset_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.driver_weapon_asset_path, ::std::string::String::new())
    }

    // string ornament_asset_path = 8;


    pub fn get_ornament_asset_path(&self) -> &str {
        &self.ornament_asset_path
    }
    pub fn clear_ornament_asset_path(&mut self) {
        self.ornament_asset_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_ornament_asset_path(&mut self, v: ::std::string::String) {
        self.ornament_asset_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ornament_asset_path(&mut self) -> &mut ::std::string::String {
        &mut self.ornament_asset_path
    }

    // Take field
    pub fn take_ornament_asset_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ornament_asset_path, ::std::string::String::new())
    }

    // string material_decal_asset_path = 9;


    pub fn get_material_decal_asset_path(&self) -> &str {
        &self.material_decal_asset_path
    }
    pub fn clear_material_decal_asset_path(&mut self) {
        self.material_decal_asset_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_material_decal_asset_path(&mut self, v: ::std::string::String) {
        self.material_decal_asset_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_material_decal_asset_path(&mut self) -> &mut ::std::string::String {
        &mut self.material_decal_asset_path
    }

    // Take field
    pub fn take_material_decal_asset_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.material_decal_asset_path, ::std::string::String::new())
    }

    // string material_asset_path = 10;


    pub fn get_material_asset_path(&self) -> &str {
        &self.material_asset_path
    }
    pub fn clear_material_asset_path(&mut self) {
        self.material_asset_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_material_asset_path(&mut self, v: ::std::string::String) {
        self.material_asset_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_material_asset_path(&mut self) -> &mut ::std::string::String {
        &mut self.material_asset_path
    }

    // Take field
    pub fn take_material_asset_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.material_asset_path, ::std::string::String::new())
    }

    // int32 color_index_1 = 11;


    pub fn get_color_index_1(&self) -> i32 {
        self.color_index_1
    }
    pub fn clear_color_index_1(&mut self) {
        self.color_index_1 = 0;
    }

    // Param is passed by value, moved
    pub fn set_color_index_1(&mut self, v: i32) {
        self.color_index_1 = v;
    }

    // int32 color_index_2 = 12;


    pub fn get_color_index_2(&self) -> i32 {
        self.color_index_2
    }
    pub fn clear_color_index_2(&mut self) {
        self.color_index_2 = 0;
    }

    // Param is passed by value, moved
    pub fn set_color_index_2(&mut self, v: i32) {
        self.color_index_2 = v;
    }

    // int32 color_index_3 = 13;


    pub fn get_color_index_3(&self) -> i32 {
        self.color_index_3
    }
    pub fn clear_color_index_3(&mut self) {
        self.color_index_3 = 0;
    }

    // Param is passed by value, moved
    pub fn set_color_index_3(&mut self, v: i32) {
        self.color_index_3 = v;
    }
}

impl ::protobuf::Message for OakCARMenuVehicleConfigSaveData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.loadout_save_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.body_asset_path)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.wheel_asset_path)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.armor_asset_path)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.core_mod_asset_path)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.gunner_weapon_asset_path)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.driver_weapon_asset_path)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ornament_asset_path)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.material_decal_asset_path)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.material_asset_path)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.color_index_1 = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.color_index_2 = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.color_index_3 = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.loadout_save_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.loadout_save_name);
        }
        if !self.body_asset_path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.body_asset_path);
        }
        if !self.wheel_asset_path.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.wheel_asset_path);
        }
        if !self.armor_asset_path.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.armor_asset_path);
        }
        if !self.core_mod_asset_path.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.core_mod_asset_path);
        }
        if !self.gunner_weapon_asset_path.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.gunner_weapon_asset_path);
        }
        if !self.driver_weapon_asset_path.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.driver_weapon_asset_path);
        }
        if !self.ornament_asset_path.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.ornament_asset_path);
        }
        if !self.material_decal_asset_path.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.material_decal_asset_path);
        }
        if !self.material_asset_path.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.material_asset_path);
        }
        if self.color_index_1 != 0 {
            my_size += ::protobuf::rt::value_size(11, self.color_index_1, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.color_index_2 != 0 {
            my_size += ::protobuf::rt::value_size(12, self.color_index_2, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.color_index_3 != 0 {
            my_size += ::protobuf::rt::value_size(13, self.color_index_3, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.loadout_save_name.is_empty() {
            os.write_string(1, &self.loadout_save_name)?;
        }
        if !self.body_asset_path.is_empty() {
            os.write_string(2, &self.body_asset_path)?;
        }
        if !self.wheel_asset_path.is_empty() {
            os.write_string(3, &self.wheel_asset_path)?;
        }
        if !self.armor_asset_path.is_empty() {
            os.write_string(4, &self.armor_asset_path)?;
        }
        if !self.core_mod_asset_path.is_empty() {
            os.write_string(5, &self.core_mod_asset_path)?;
        }
        if !self.gunner_weapon_asset_path.is_empty() {
            os.write_string(6, &self.gunner_weapon_asset_path)?;
        }
        if !self.driver_weapon_asset_path.is_empty() {
            os.write_string(7, &self.driver_weapon_asset_path)?;
        }
        if !self.ornament_asset_path.is_empty() {
            os.write_string(8, &self.ornament_asset_path)?;
        }
        if !self.material_decal_asset_path.is_empty() {
            os.write_string(9, &self.material_decal_asset_path)?;
        }
        if !self.material_asset_path.is_empty() {
            os.write_string(10, &self.material_asset_path)?;
        }
        if self.color_index_1 != 0 {
            os.write_int32(11, self.color_index_1)?;
        }
        if self.color_index_2 != 0 {
            os.write_int32(12, self.color_index_2)?;
        }
        if self.color_index_3 != 0 {
            os.write_int32(13, self.color_index_3)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OakCARMenuVehicleConfigSaveData {
        OakCARMenuVehicleConfigSaveData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "loadout_save_name",
                |m: &OakCARMenuVehicleConfigSaveData| { &m.loadout_save_name },
                |m: &mut OakCARMenuVehicleConfigSaveData| { &mut m.loadout_save_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "body_asset_path",
                |m: &OakCARMenuVehicleConfigSaveData| { &m.body_asset_path },
                |m: &mut OakCARMenuVehicleConfigSaveData| { &mut m.body_asset_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "wheel_asset_path",
                |m: &OakCARMenuVehicleConfigSaveData| { &m.wheel_asset_path },
                |m: &mut OakCARMenuVehicleConfigSaveData| { &mut m.wheel_asset_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "armor_asset_path",
                |m: &OakCARMenuVehicleConfigSaveData| { &m.armor_asset_path },
                |m: &mut OakCARMenuVehicleConfigSaveData| { &mut m.armor_asset_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "core_mod_asset_path",
                |m: &OakCARMenuVehicleConfigSaveData| { &m.core_mod_asset_path },
                |m: &mut OakCARMenuVehicleConfigSaveData| { &mut m.core_mod_asset_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gunner_weapon_asset_path",
                |m: &OakCARMenuVehicleConfigSaveData| { &m.gunner_weapon_asset_path },
                |m: &mut OakCARMenuVehicleConfigSaveData| { &mut m.gunner_weapon_asset_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "driver_weapon_asset_path",
                |m: &OakCARMenuVehicleConfigSaveData| { &m.driver_weapon_asset_path },
                |m: &mut OakCARMenuVehicleConfigSaveData| { &mut m.driver_weapon_asset_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ornament_asset_path",
                |m: &OakCARMenuVehicleConfigSaveData| { &m.ornament_asset_path },
                |m: &mut OakCARMenuVehicleConfigSaveData| { &mut m.ornament_asset_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "material_decal_asset_path",
                |m: &OakCARMenuVehicleConfigSaveData| { &m.material_decal_asset_path },
                |m: &mut OakCARMenuVehicleConfigSaveData| { &mut m.material_decal_asset_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "material_asset_path",
                |m: &OakCARMenuVehicleConfigSaveData| { &m.material_asset_path },
                |m: &mut OakCARMenuVehicleConfigSaveData| { &mut m.material_asset_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "color_index_1",
                |m: &OakCARMenuVehicleConfigSaveData| { &m.color_index_1 },
                |m: &mut OakCARMenuVehicleConfigSaveData| { &mut m.color_index_1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "color_index_2",
                |m: &OakCARMenuVehicleConfigSaveData| { &m.color_index_2 },
                |m: &mut OakCARMenuVehicleConfigSaveData| { &mut m.color_index_2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "color_index_3",
                |m: &OakCARMenuVehicleConfigSaveData| { &m.color_index_3 },
                |m: &mut OakCARMenuVehicleConfigSaveData| { &mut m.color_index_3 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OakCARMenuVehicleConfigSaveData>(
                "OakCARMenuVehicleConfigSaveData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OakCARMenuVehicleConfigSaveData {
        static instance: ::protobuf::rt::LazyV2<OakCARMenuVehicleConfigSaveData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OakCARMenuVehicleConfigSaveData::new)
    }
}

impl ::protobuf::Clear for OakCARMenuVehicleConfigSaveData {
    fn clear(&mut self) {
        self.loadout_save_name.clear();
        self.body_asset_path.clear();
        self.wheel_asset_path.clear();
        self.armor_asset_path.clear();
        self.core_mod_asset_path.clear();
        self.gunner_weapon_asset_path.clear();
        self.driver_weapon_asset_path.clear();
        self.ornament_asset_path.clear();
        self.material_decal_asset_path.clear();
        self.material_asset_path.clear();
        self.color_index_1 = 0;
        self.color_index_2 = 0;
        self.color_index_3 = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OakCARMenuVehicleConfigSaveData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OakCARMenuVehicleConfigSaveData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CustomPlayerColorSaveGameData {
    // message fields
    pub color_parameter: ::std::string::String,
    pub applied_color: ::protobuf::SingularPtrField<super::oak_shared::Vec3>,
    pub split_color: ::protobuf::SingularPtrField<super::oak_shared::Vec3>,
    pub use_default_color: bool,
    pub use_default_split_color: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CustomPlayerColorSaveGameData {
    fn default() -> &'a CustomPlayerColorSaveGameData {
        <CustomPlayerColorSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl CustomPlayerColorSaveGameData {
    pub fn new() -> CustomPlayerColorSaveGameData {
        ::std::default::Default::default()
    }

    // string color_parameter = 1;


    pub fn get_color_parameter(&self) -> &str {
        &self.color_parameter
    }
    pub fn clear_color_parameter(&mut self) {
        self.color_parameter.clear();
    }

    // Param is passed by value, moved
    pub fn set_color_parameter(&mut self, v: ::std::string::String) {
        self.color_parameter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_color_parameter(&mut self) -> &mut ::std::string::String {
        &mut self.color_parameter
    }

    // Take field
    pub fn take_color_parameter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.color_parameter, ::std::string::String::new())
    }

    // .OakSave.Vec3 applied_color = 2;


    pub fn get_applied_color(&self) -> &super::oak_shared::Vec3 {
        self.applied_color.as_ref().unwrap_or_else(|| <super::oak_shared::Vec3 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_applied_color(&mut self) {
        self.applied_color.clear();
    }

    pub fn has_applied_color(&self) -> bool {
        self.applied_color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_applied_color(&mut self, v: super::oak_shared::Vec3) {
        self.applied_color = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_applied_color(&mut self) -> &mut super::oak_shared::Vec3 {
        if self.applied_color.is_none() {
            self.applied_color.set_default();
        }
        self.applied_color.as_mut().unwrap()
    }

    // Take field
    pub fn take_applied_color(&mut self) -> super::oak_shared::Vec3 {
        self.applied_color.take().unwrap_or_else(|| super::oak_shared::Vec3::new())
    }

    // .OakSave.Vec3 split_color = 3;


    pub fn get_split_color(&self) -> &super::oak_shared::Vec3 {
        self.split_color.as_ref().unwrap_or_else(|| <super::oak_shared::Vec3 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_split_color(&mut self) {
        self.split_color.clear();
    }

    pub fn has_split_color(&self) -> bool {
        self.split_color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_split_color(&mut self, v: super::oak_shared::Vec3) {
        self.split_color = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_split_color(&mut self) -> &mut super::oak_shared::Vec3 {
        if self.split_color.is_none() {
            self.split_color.set_default();
        }
        self.split_color.as_mut().unwrap()
    }

    // Take field
    pub fn take_split_color(&mut self) -> super::oak_shared::Vec3 {
        self.split_color.take().unwrap_or_else(|| super::oak_shared::Vec3::new())
    }

    // bool use_default_color = 4;


    pub fn get_use_default_color(&self) -> bool {
        self.use_default_color
    }
    pub fn clear_use_default_color(&mut self) {
        self.use_default_color = false;
    }

    // Param is passed by value, moved
    pub fn set_use_default_color(&mut self, v: bool) {
        self.use_default_color = v;
    }

    // bool use_default_split_color = 5;


    pub fn get_use_default_split_color(&self) -> bool {
        self.use_default_split_color
    }
    pub fn clear_use_default_split_color(&mut self) {
        self.use_default_split_color = false;
    }

    // Param is passed by value, moved
    pub fn set_use_default_split_color(&mut self, v: bool) {
        self.use_default_split_color = v;
    }
}

impl ::protobuf::Message for CustomPlayerColorSaveGameData {
    fn is_initialized(&self) -> bool {
        for v in &self.applied_color {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.split_color {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.color_parameter)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.applied_color)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.split_color)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_default_color = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_default_split_color = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.color_parameter.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.color_parameter);
        }
        if let Some(ref v) = self.applied_color.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.split_color.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.use_default_color != false {
            my_size += 2;
        }
        if self.use_default_split_color != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.color_parameter.is_empty() {
            os.write_string(1, &self.color_parameter)?;
        }
        if let Some(ref v) = self.applied_color.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.split_color.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.use_default_color != false {
            os.write_bool(4, self.use_default_color)?;
        }
        if self.use_default_split_color != false {
            os.write_bool(5, self.use_default_split_color)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CustomPlayerColorSaveGameData {
        CustomPlayerColorSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "color_parameter",
                |m: &CustomPlayerColorSaveGameData| { &m.color_parameter },
                |m: &mut CustomPlayerColorSaveGameData| { &mut m.color_parameter },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::oak_shared::Vec3>>(
                "applied_color",
                |m: &CustomPlayerColorSaveGameData| { &m.applied_color },
                |m: &mut CustomPlayerColorSaveGameData| { &mut m.applied_color },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::oak_shared::Vec3>>(
                "split_color",
                |m: &CustomPlayerColorSaveGameData| { &m.split_color },
                |m: &mut CustomPlayerColorSaveGameData| { &mut m.split_color },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use_default_color",
                |m: &CustomPlayerColorSaveGameData| { &m.use_default_color },
                |m: &mut CustomPlayerColorSaveGameData| { &mut m.use_default_color },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use_default_split_color",
                |m: &CustomPlayerColorSaveGameData| { &m.use_default_split_color },
                |m: &mut CustomPlayerColorSaveGameData| { &mut m.use_default_split_color },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CustomPlayerColorSaveGameData>(
                "CustomPlayerColorSaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CustomPlayerColorSaveGameData {
        static instance: ::protobuf::rt::LazyV2<CustomPlayerColorSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CustomPlayerColorSaveGameData::new)
    }
}

impl ::protobuf::Clear for CustomPlayerColorSaveGameData {
    fn clear(&mut self) {
        self.color_parameter.clear();
        self.applied_color.clear();
        self.split_color.clear();
        self.use_default_color = false;
        self.use_default_split_color = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CustomPlayerColorSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CustomPlayerColorSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GuardianRankSaveGameData {
    // message fields
    pub guardian_rank: i32,
    pub guardian_experience: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GuardianRankSaveGameData {
    fn default() -> &'a GuardianRankSaveGameData {
        <GuardianRankSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl GuardianRankSaveGameData {
    pub fn new() -> GuardianRankSaveGameData {
        ::std::default::Default::default()
    }

    // int32 guardian_rank = 1;


    pub fn get_guardian_rank(&self) -> i32 {
        self.guardian_rank
    }
    pub fn clear_guardian_rank(&mut self) {
        self.guardian_rank = 0;
    }

    // Param is passed by value, moved
    pub fn set_guardian_rank(&mut self, v: i32) {
        self.guardian_rank = v;
    }

    // int32 guardian_experience = 2;


    pub fn get_guardian_experience(&self) -> i32 {
        self.guardian_experience
    }
    pub fn clear_guardian_experience(&mut self) {
        self.guardian_experience = 0;
    }

    // Param is passed by value, moved
    pub fn set_guardian_experience(&mut self, v: i32) {
        self.guardian_experience = v;
    }
}

impl ::protobuf::Message for GuardianRankSaveGameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.guardian_rank = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.guardian_experience = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.guardian_rank != 0 {
            my_size += ::protobuf::rt::value_size(1, self.guardian_rank, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.guardian_experience != 0 {
            my_size += ::protobuf::rt::value_size(2, self.guardian_experience, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.guardian_rank != 0 {
            os.write_int32(1, self.guardian_rank)?;
        }
        if self.guardian_experience != 0 {
            os.write_int32(2, self.guardian_experience)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GuardianRankSaveGameData {
        GuardianRankSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "guardian_rank",
                |m: &GuardianRankSaveGameData| { &m.guardian_rank },
                |m: &mut GuardianRankSaveGameData| { &mut m.guardian_rank },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "guardian_experience",
                |m: &GuardianRankSaveGameData| { &m.guardian_experience },
                |m: &mut GuardianRankSaveGameData| { &mut m.guardian_experience },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GuardianRankSaveGameData>(
                "GuardianRankSaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GuardianRankSaveGameData {
        static instance: ::protobuf::rt::LazyV2<GuardianRankSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GuardianRankSaveGameData::new)
    }
}

impl ::protobuf::Clear for GuardianRankSaveGameData {
    fn clear(&mut self) {
        self.guardian_rank = 0;
        self.guardian_experience = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GuardianRankSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GuardianRankSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GuardianRankRewardCharacterSaveGameData {
    // message fields
    pub num_tokens: i32,
    pub is_enabled: bool,
    pub reward_data_path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GuardianRankRewardCharacterSaveGameData {
    fn default() -> &'a GuardianRankRewardCharacterSaveGameData {
        <GuardianRankRewardCharacterSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl GuardianRankRewardCharacterSaveGameData {
    pub fn new() -> GuardianRankRewardCharacterSaveGameData {
        ::std::default::Default::default()
    }

    // int32 num_tokens = 1;


    pub fn get_num_tokens(&self) -> i32 {
        self.num_tokens
    }
    pub fn clear_num_tokens(&mut self) {
        self.num_tokens = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_tokens(&mut self, v: i32) {
        self.num_tokens = v;
    }

    // bool is_enabled = 2;


    pub fn get_is_enabled(&self) -> bool {
        self.is_enabled
    }
    pub fn clear_is_enabled(&mut self) {
        self.is_enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_is_enabled(&mut self, v: bool) {
        self.is_enabled = v;
    }

    // string reward_data_path = 3;


    pub fn get_reward_data_path(&self) -> &str {
        &self.reward_data_path
    }
    pub fn clear_reward_data_path(&mut self) {
        self.reward_data_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_reward_data_path(&mut self, v: ::std::string::String) {
        self.reward_data_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reward_data_path(&mut self) -> &mut ::std::string::String {
        &mut self.reward_data_path
    }

    // Take field
    pub fn take_reward_data_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.reward_data_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GuardianRankRewardCharacterSaveGameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_tokens = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_enabled = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.reward_data_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.num_tokens != 0 {
            my_size += ::protobuf::rt::value_size(1, self.num_tokens, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_enabled != false {
            my_size += 2;
        }
        if !self.reward_data_path.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.reward_data_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.num_tokens != 0 {
            os.write_int32(1, self.num_tokens)?;
        }
        if self.is_enabled != false {
            os.write_bool(2, self.is_enabled)?;
        }
        if !self.reward_data_path.is_empty() {
            os.write_string(3, &self.reward_data_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GuardianRankRewardCharacterSaveGameData {
        GuardianRankRewardCharacterSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "num_tokens",
                |m: &GuardianRankRewardCharacterSaveGameData| { &m.num_tokens },
                |m: &mut GuardianRankRewardCharacterSaveGameData| { &mut m.num_tokens },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_enabled",
                |m: &GuardianRankRewardCharacterSaveGameData| { &m.is_enabled },
                |m: &mut GuardianRankRewardCharacterSaveGameData| { &mut m.is_enabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reward_data_path",
                |m: &GuardianRankRewardCharacterSaveGameData| { &m.reward_data_path },
                |m: &mut GuardianRankRewardCharacterSaveGameData| { &mut m.reward_data_path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GuardianRankRewardCharacterSaveGameData>(
                "GuardianRankRewardCharacterSaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GuardianRankRewardCharacterSaveGameData {
        static instance: ::protobuf::rt::LazyV2<GuardianRankRewardCharacterSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GuardianRankRewardCharacterSaveGameData::new)
    }
}

impl ::protobuf::Clear for GuardianRankRewardCharacterSaveGameData {
    fn clear(&mut self) {
        self.num_tokens = 0;
        self.is_enabled = false;
        self.reward_data_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GuardianRankRewardCharacterSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GuardianRankRewardCharacterSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GuardianRankPerkCharacterSaveGameData {
    // message fields
    pub is_enabled: bool,
    pub perk_data_path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GuardianRankPerkCharacterSaveGameData {
    fn default() -> &'a GuardianRankPerkCharacterSaveGameData {
        <GuardianRankPerkCharacterSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl GuardianRankPerkCharacterSaveGameData {
    pub fn new() -> GuardianRankPerkCharacterSaveGameData {
        ::std::default::Default::default()
    }

    // bool is_enabled = 1;


    pub fn get_is_enabled(&self) -> bool {
        self.is_enabled
    }
    pub fn clear_is_enabled(&mut self) {
        self.is_enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_is_enabled(&mut self, v: bool) {
        self.is_enabled = v;
    }

    // string perk_data_path = 2;


    pub fn get_perk_data_path(&self) -> &str {
        &self.perk_data_path
    }
    pub fn clear_perk_data_path(&mut self) {
        self.perk_data_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_perk_data_path(&mut self, v: ::std::string::String) {
        self.perk_data_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_perk_data_path(&mut self) -> &mut ::std::string::String {
        &mut self.perk_data_path
    }

    // Take field
    pub fn take_perk_data_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.perk_data_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GuardianRankPerkCharacterSaveGameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_enabled = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.perk_data_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_enabled != false {
            my_size += 2;
        }
        if !self.perk_data_path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.perk_data_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.is_enabled != false {
            os.write_bool(1, self.is_enabled)?;
        }
        if !self.perk_data_path.is_empty() {
            os.write_string(2, &self.perk_data_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GuardianRankPerkCharacterSaveGameData {
        GuardianRankPerkCharacterSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_enabled",
                |m: &GuardianRankPerkCharacterSaveGameData| { &m.is_enabled },
                |m: &mut GuardianRankPerkCharacterSaveGameData| { &mut m.is_enabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "perk_data_path",
                |m: &GuardianRankPerkCharacterSaveGameData| { &m.perk_data_path },
                |m: &mut GuardianRankPerkCharacterSaveGameData| { &mut m.perk_data_path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GuardianRankPerkCharacterSaveGameData>(
                "GuardianRankPerkCharacterSaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GuardianRankPerkCharacterSaveGameData {
        static instance: ::protobuf::rt::LazyV2<GuardianRankPerkCharacterSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GuardianRankPerkCharacterSaveGameData::new)
    }
}

impl ::protobuf::Clear for GuardianRankPerkCharacterSaveGameData {
    fn clear(&mut self) {
        self.is_enabled = false;
        self.perk_data_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GuardianRankPerkCharacterSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GuardianRankPerkCharacterSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GuardianRankCharacterSaveGameData {
    // message fields
    pub guardian_available_tokens: i32,
    pub guardian_rank: i32,
    pub guardian_experience: i32,
    pub rank_rewards: ::protobuf::RepeatedField<GuardianRankRewardCharacterSaveGameData>,
    pub rank_perks: ::protobuf::RepeatedField<GuardianRankPerkCharacterSaveGameData>,
    pub guardian_reward_random_seed: i32,
    pub new_guardian_experience: i64,
    pub is_rank_system_enabled: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GuardianRankCharacterSaveGameData {
    fn default() -> &'a GuardianRankCharacterSaveGameData {
        <GuardianRankCharacterSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl GuardianRankCharacterSaveGameData {
    pub fn new() -> GuardianRankCharacterSaveGameData {
        ::std::default::Default::default()
    }

    // int32 guardian_available_tokens = 1;


    pub fn get_guardian_available_tokens(&self) -> i32 {
        self.guardian_available_tokens
    }
    pub fn clear_guardian_available_tokens(&mut self) {
        self.guardian_available_tokens = 0;
    }

    // Param is passed by value, moved
    pub fn set_guardian_available_tokens(&mut self, v: i32) {
        self.guardian_available_tokens = v;
    }

    // int32 guardian_rank = 2;


    pub fn get_guardian_rank(&self) -> i32 {
        self.guardian_rank
    }
    pub fn clear_guardian_rank(&mut self) {
        self.guardian_rank = 0;
    }

    // Param is passed by value, moved
    pub fn set_guardian_rank(&mut self, v: i32) {
        self.guardian_rank = v;
    }

    // int32 guardian_experience = 3;


    pub fn get_guardian_experience(&self) -> i32 {
        self.guardian_experience
    }
    pub fn clear_guardian_experience(&mut self) {
        self.guardian_experience = 0;
    }

    // Param is passed by value, moved
    pub fn set_guardian_experience(&mut self, v: i32) {
        self.guardian_experience = v;
    }

    // repeated .OakSave.GuardianRankRewardCharacterSaveGameData rank_rewards = 4;


    pub fn get_rank_rewards(&self) -> &[GuardianRankRewardCharacterSaveGameData] {
        &self.rank_rewards
    }
    pub fn clear_rank_rewards(&mut self) {
        self.rank_rewards.clear();
    }

    // Param is passed by value, moved
    pub fn set_rank_rewards(&mut self, v: ::protobuf::RepeatedField<GuardianRankRewardCharacterSaveGameData>) {
        self.rank_rewards = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rank_rewards(&mut self) -> &mut ::protobuf::RepeatedField<GuardianRankRewardCharacterSaveGameData> {
        &mut self.rank_rewards
    }

    // Take field
    pub fn take_rank_rewards(&mut self) -> ::protobuf::RepeatedField<GuardianRankRewardCharacterSaveGameData> {
        ::std::mem::replace(&mut self.rank_rewards, ::protobuf::RepeatedField::new())
    }

    // repeated .OakSave.GuardianRankPerkCharacterSaveGameData rank_perks = 5;


    pub fn get_rank_perks(&self) -> &[GuardianRankPerkCharacterSaveGameData] {
        &self.rank_perks
    }
    pub fn clear_rank_perks(&mut self) {
        self.rank_perks.clear();
    }

    // Param is passed by value, moved
    pub fn set_rank_perks(&mut self, v: ::protobuf::RepeatedField<GuardianRankPerkCharacterSaveGameData>) {
        self.rank_perks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rank_perks(&mut self) -> &mut ::protobuf::RepeatedField<GuardianRankPerkCharacterSaveGameData> {
        &mut self.rank_perks
    }

    // Take field
    pub fn take_rank_perks(&mut self) -> ::protobuf::RepeatedField<GuardianRankPerkCharacterSaveGameData> {
        ::std::mem::replace(&mut self.rank_perks, ::protobuf::RepeatedField::new())
    }

    // int32 guardian_reward_random_seed = 6;


    pub fn get_guardian_reward_random_seed(&self) -> i32 {
        self.guardian_reward_random_seed
    }
    pub fn clear_guardian_reward_random_seed(&mut self) {
        self.guardian_reward_random_seed = 0;
    }

    // Param is passed by value, moved
    pub fn set_guardian_reward_random_seed(&mut self, v: i32) {
        self.guardian_reward_random_seed = v;
    }

    // int64 new_guardian_experience = 7;


    pub fn get_new_guardian_experience(&self) -> i64 {
        self.new_guardian_experience
    }
    pub fn clear_new_guardian_experience(&mut self) {
        self.new_guardian_experience = 0;
    }

    // Param is passed by value, moved
    pub fn set_new_guardian_experience(&mut self, v: i64) {
        self.new_guardian_experience = v;
    }

    // bool is_rank_system_enabled = 8;


    pub fn get_is_rank_system_enabled(&self) -> bool {
        self.is_rank_system_enabled
    }
    pub fn clear_is_rank_system_enabled(&mut self) {
        self.is_rank_system_enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_is_rank_system_enabled(&mut self, v: bool) {
        self.is_rank_system_enabled = v;
    }
}

impl ::protobuf::Message for GuardianRankCharacterSaveGameData {
    fn is_initialized(&self) -> bool {
        for v in &self.rank_rewards {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rank_perks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.guardian_available_tokens = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.guardian_rank = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.guardian_experience = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rank_rewards)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rank_perks)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.guardian_reward_random_seed = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.new_guardian_experience = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_rank_system_enabled = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.guardian_available_tokens != 0 {
            my_size += ::protobuf::rt::value_size(1, self.guardian_available_tokens, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.guardian_rank != 0 {
            my_size += ::protobuf::rt::value_size(2, self.guardian_rank, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.guardian_experience != 0 {
            my_size += ::protobuf::rt::value_size(3, self.guardian_experience, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.rank_rewards {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.rank_perks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.guardian_reward_random_seed != 0 {
            my_size += ::protobuf::rt::value_size(6, self.guardian_reward_random_seed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.new_guardian_experience != 0 {
            my_size += ::protobuf::rt::value_size(7, self.new_guardian_experience, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_rank_system_enabled != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.guardian_available_tokens != 0 {
            os.write_int32(1, self.guardian_available_tokens)?;
        }
        if self.guardian_rank != 0 {
            os.write_int32(2, self.guardian_rank)?;
        }
        if self.guardian_experience != 0 {
            os.write_int32(3, self.guardian_experience)?;
        }
        for v in &self.rank_rewards {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.rank_perks {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.guardian_reward_random_seed != 0 {
            os.write_int32(6, self.guardian_reward_random_seed)?;
        }
        if self.new_guardian_experience != 0 {
            os.write_int64(7, self.new_guardian_experience)?;
        }
        if self.is_rank_system_enabled != false {
            os.write_bool(8, self.is_rank_system_enabled)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GuardianRankCharacterSaveGameData {
        GuardianRankCharacterSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "guardian_available_tokens",
                |m: &GuardianRankCharacterSaveGameData| { &m.guardian_available_tokens },
                |m: &mut GuardianRankCharacterSaveGameData| { &mut m.guardian_available_tokens },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "guardian_rank",
                |m: &GuardianRankCharacterSaveGameData| { &m.guardian_rank },
                |m: &mut GuardianRankCharacterSaveGameData| { &mut m.guardian_rank },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "guardian_experience",
                |m: &GuardianRankCharacterSaveGameData| { &m.guardian_experience },
                |m: &mut GuardianRankCharacterSaveGameData| { &mut m.guardian_experience },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GuardianRankRewardCharacterSaveGameData>>(
                "rank_rewards",
                |m: &GuardianRankCharacterSaveGameData| { &m.rank_rewards },
                |m: &mut GuardianRankCharacterSaveGameData| { &mut m.rank_rewards },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GuardianRankPerkCharacterSaveGameData>>(
                "rank_perks",
                |m: &GuardianRankCharacterSaveGameData| { &m.rank_perks },
                |m: &mut GuardianRankCharacterSaveGameData| { &mut m.rank_perks },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "guardian_reward_random_seed",
                |m: &GuardianRankCharacterSaveGameData| { &m.guardian_reward_random_seed },
                |m: &mut GuardianRankCharacterSaveGameData| { &mut m.guardian_reward_random_seed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "new_guardian_experience",
                |m: &GuardianRankCharacterSaveGameData| { &m.new_guardian_experience },
                |m: &mut GuardianRankCharacterSaveGameData| { &mut m.new_guardian_experience },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_rank_system_enabled",
                |m: &GuardianRankCharacterSaveGameData| { &m.is_rank_system_enabled },
                |m: &mut GuardianRankCharacterSaveGameData| { &mut m.is_rank_system_enabled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GuardianRankCharacterSaveGameData>(
                "GuardianRankCharacterSaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GuardianRankCharacterSaveGameData {
        static instance: ::protobuf::rt::LazyV2<GuardianRankCharacterSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GuardianRankCharacterSaveGameData::new)
    }
}

impl ::protobuf::Clear for GuardianRankCharacterSaveGameData {
    fn clear(&mut self) {
        self.guardian_available_tokens = 0;
        self.guardian_rank = 0;
        self.guardian_experience = 0;
        self.rank_rewards.clear();
        self.rank_perks.clear();
        self.guardian_reward_random_seed = 0;
        self.new_guardian_experience = 0;
        self.is_rank_system_enabled = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GuardianRankCharacterSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GuardianRankCharacterSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CrewQuartersDecorationSaveData {
    // message fields
    pub decoration_index: i32,
    pub decoration_data_path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CrewQuartersDecorationSaveData {
    fn default() -> &'a CrewQuartersDecorationSaveData {
        <CrewQuartersDecorationSaveData as ::protobuf::Message>::default_instance()
    }
}

impl CrewQuartersDecorationSaveData {
    pub fn new() -> CrewQuartersDecorationSaveData {
        ::std::default::Default::default()
    }

    // int32 decoration_index = 1;


    pub fn get_decoration_index(&self) -> i32 {
        self.decoration_index
    }
    pub fn clear_decoration_index(&mut self) {
        self.decoration_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_decoration_index(&mut self, v: i32) {
        self.decoration_index = v;
    }

    // string decoration_data_path = 2;


    pub fn get_decoration_data_path(&self) -> &str {
        &self.decoration_data_path
    }
    pub fn clear_decoration_data_path(&mut self) {
        self.decoration_data_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_decoration_data_path(&mut self, v: ::std::string::String) {
        self.decoration_data_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_decoration_data_path(&mut self) -> &mut ::std::string::String {
        &mut self.decoration_data_path
    }

    // Take field
    pub fn take_decoration_data_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.decoration_data_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CrewQuartersDecorationSaveData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.decoration_index = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.decoration_data_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.decoration_index != 0 {
            my_size += ::protobuf::rt::value_size(1, self.decoration_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.decoration_data_path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.decoration_data_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.decoration_index != 0 {
            os.write_int32(1, self.decoration_index)?;
        }
        if !self.decoration_data_path.is_empty() {
            os.write_string(2, &self.decoration_data_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CrewQuartersDecorationSaveData {
        CrewQuartersDecorationSaveData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "decoration_index",
                |m: &CrewQuartersDecorationSaveData| { &m.decoration_index },
                |m: &mut CrewQuartersDecorationSaveData| { &mut m.decoration_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "decoration_data_path",
                |m: &CrewQuartersDecorationSaveData| { &m.decoration_data_path },
                |m: &mut CrewQuartersDecorationSaveData| { &mut m.decoration_data_path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CrewQuartersDecorationSaveData>(
                "CrewQuartersDecorationSaveData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CrewQuartersDecorationSaveData {
        static instance: ::protobuf::rt::LazyV2<CrewQuartersDecorationSaveData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CrewQuartersDecorationSaveData::new)
    }
}

impl ::protobuf::Clear for CrewQuartersDecorationSaveData {
    fn clear(&mut self) {
        self.decoration_index = 0;
        self.decoration_data_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CrewQuartersDecorationSaveData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CrewQuartersDecorationSaveData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CrewQuartersSaveData {
    // message fields
    pub preferred_room_assignment: i32,
    pub decorations: ::protobuf::RepeatedField<CrewQuartersDecorationSaveData>,
    pub room_data_path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CrewQuartersSaveData {
    fn default() -> &'a CrewQuartersSaveData {
        <CrewQuartersSaveData as ::protobuf::Message>::default_instance()
    }
}

impl CrewQuartersSaveData {
    pub fn new() -> CrewQuartersSaveData {
        ::std::default::Default::default()
    }

    // int32 preferred_room_assignment = 1;


    pub fn get_preferred_room_assignment(&self) -> i32 {
        self.preferred_room_assignment
    }
    pub fn clear_preferred_room_assignment(&mut self) {
        self.preferred_room_assignment = 0;
    }

    // Param is passed by value, moved
    pub fn set_preferred_room_assignment(&mut self, v: i32) {
        self.preferred_room_assignment = v;
    }

    // repeated .OakSave.CrewQuartersDecorationSaveData decorations = 2;


    pub fn get_decorations(&self) -> &[CrewQuartersDecorationSaveData] {
        &self.decorations
    }
    pub fn clear_decorations(&mut self) {
        self.decorations.clear();
    }

    // Param is passed by value, moved
    pub fn set_decorations(&mut self, v: ::protobuf::RepeatedField<CrewQuartersDecorationSaveData>) {
        self.decorations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_decorations(&mut self) -> &mut ::protobuf::RepeatedField<CrewQuartersDecorationSaveData> {
        &mut self.decorations
    }

    // Take field
    pub fn take_decorations(&mut self) -> ::protobuf::RepeatedField<CrewQuartersDecorationSaveData> {
        ::std::mem::replace(&mut self.decorations, ::protobuf::RepeatedField::new())
    }

    // string room_data_path = 3;


    pub fn get_room_data_path(&self) -> &str {
        &self.room_data_path
    }
    pub fn clear_room_data_path(&mut self) {
        self.room_data_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_room_data_path(&mut self, v: ::std::string::String) {
        self.room_data_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_room_data_path(&mut self) -> &mut ::std::string::String {
        &mut self.room_data_path
    }

    // Take field
    pub fn take_room_data_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.room_data_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CrewQuartersSaveData {
    fn is_initialized(&self) -> bool {
        for v in &self.decorations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.preferred_room_assignment = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.decorations)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.room_data_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.preferred_room_assignment != 0 {
            my_size += ::protobuf::rt::value_size(1, self.preferred_room_assignment, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.decorations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.room_data_path.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.room_data_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.preferred_room_assignment != 0 {
            os.write_int32(1, self.preferred_room_assignment)?;
        }
        for v in &self.decorations {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.room_data_path.is_empty() {
            os.write_string(3, &self.room_data_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CrewQuartersSaveData {
        CrewQuartersSaveData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "preferred_room_assignment",
                |m: &CrewQuartersSaveData| { &m.preferred_room_assignment },
                |m: &mut CrewQuartersSaveData| { &mut m.preferred_room_assignment },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CrewQuartersDecorationSaveData>>(
                "decorations",
                |m: &CrewQuartersSaveData| { &m.decorations },
                |m: &mut CrewQuartersSaveData| { &mut m.decorations },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "room_data_path",
                |m: &CrewQuartersSaveData| { &m.room_data_path },
                |m: &mut CrewQuartersSaveData| { &mut m.room_data_path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CrewQuartersSaveData>(
                "CrewQuartersSaveData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CrewQuartersSaveData {
        static instance: ::protobuf::rt::LazyV2<CrewQuartersSaveData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CrewQuartersSaveData::new)
    }
}

impl ::protobuf::Clear for CrewQuartersSaveData {
    fn clear(&mut self) {
        self.preferred_room_assignment = 0;
        self.decorations.clear();
        self.room_data_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CrewQuartersSaveData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CrewQuartersSaveData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CrewQuartersGunRackItemSaveData {
    // message fields
    pub encrypted_serial_number: ::std::vec::Vec<u8>,
    pub slot_asset_path: ::std::string::String,
    pub development_save_data: ::protobuf::SingularPtrField<InventoryBalanceStateInitializationData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CrewQuartersGunRackItemSaveData {
    fn default() -> &'a CrewQuartersGunRackItemSaveData {
        <CrewQuartersGunRackItemSaveData as ::protobuf::Message>::default_instance()
    }
}

impl CrewQuartersGunRackItemSaveData {
    pub fn new() -> CrewQuartersGunRackItemSaveData {
        ::std::default::Default::default()
    }

    // bytes encrypted_serial_number = 1;


    pub fn get_encrypted_serial_number(&self) -> &[u8] {
        &self.encrypted_serial_number
    }
    pub fn clear_encrypted_serial_number(&mut self) {
        self.encrypted_serial_number.clear();
    }

    // Param is passed by value, moved
    pub fn set_encrypted_serial_number(&mut self, v: ::std::vec::Vec<u8>) {
        self.encrypted_serial_number = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encrypted_serial_number(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.encrypted_serial_number
    }

    // Take field
    pub fn take_encrypted_serial_number(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.encrypted_serial_number, ::std::vec::Vec::new())
    }

    // string slot_asset_path = 2;


    pub fn get_slot_asset_path(&self) -> &str {
        &self.slot_asset_path
    }
    pub fn clear_slot_asset_path(&mut self) {
        self.slot_asset_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_slot_asset_path(&mut self, v: ::std::string::String) {
        self.slot_asset_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_slot_asset_path(&mut self) -> &mut ::std::string::String {
        &mut self.slot_asset_path
    }

    // Take field
    pub fn take_slot_asset_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.slot_asset_path, ::std::string::String::new())
    }

    // .OakSave.InventoryBalanceStateInitializationData development_save_data = 3;


    pub fn get_development_save_data(&self) -> &InventoryBalanceStateInitializationData {
        self.development_save_data.as_ref().unwrap_or_else(|| <InventoryBalanceStateInitializationData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_development_save_data(&mut self) {
        self.development_save_data.clear();
    }

    pub fn has_development_save_data(&self) -> bool {
        self.development_save_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_development_save_data(&mut self, v: InventoryBalanceStateInitializationData) {
        self.development_save_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_development_save_data(&mut self) -> &mut InventoryBalanceStateInitializationData {
        if self.development_save_data.is_none() {
            self.development_save_data.set_default();
        }
        self.development_save_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_development_save_data(&mut self) -> InventoryBalanceStateInitializationData {
        self.development_save_data.take().unwrap_or_else(|| InventoryBalanceStateInitializationData::new())
    }
}

impl ::protobuf::Message for CrewQuartersGunRackItemSaveData {
    fn is_initialized(&self) -> bool {
        for v in &self.development_save_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.encrypted_serial_number)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.slot_asset_path)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.development_save_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.encrypted_serial_number.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.encrypted_serial_number);
        }
        if !self.slot_asset_path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.slot_asset_path);
        }
        if let Some(ref v) = self.development_save_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.encrypted_serial_number.is_empty() {
            os.write_bytes(1, &self.encrypted_serial_number)?;
        }
        if !self.slot_asset_path.is_empty() {
            os.write_string(2, &self.slot_asset_path)?;
        }
        if let Some(ref v) = self.development_save_data.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CrewQuartersGunRackItemSaveData {
        CrewQuartersGunRackItemSaveData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "encrypted_serial_number",
                |m: &CrewQuartersGunRackItemSaveData| { &m.encrypted_serial_number },
                |m: &mut CrewQuartersGunRackItemSaveData| { &mut m.encrypted_serial_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "slot_asset_path",
                |m: &CrewQuartersGunRackItemSaveData| { &m.slot_asset_path },
                |m: &mut CrewQuartersGunRackItemSaveData| { &mut m.slot_asset_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InventoryBalanceStateInitializationData>>(
                "development_save_data",
                |m: &CrewQuartersGunRackItemSaveData| { &m.development_save_data },
                |m: &mut CrewQuartersGunRackItemSaveData| { &mut m.development_save_data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CrewQuartersGunRackItemSaveData>(
                "CrewQuartersGunRackItemSaveData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CrewQuartersGunRackItemSaveData {
        static instance: ::protobuf::rt::LazyV2<CrewQuartersGunRackItemSaveData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CrewQuartersGunRackItemSaveData::new)
    }
}

impl ::protobuf::Clear for CrewQuartersGunRackItemSaveData {
    fn clear(&mut self) {
        self.encrypted_serial_number.clear();
        self.slot_asset_path.clear();
        self.development_save_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CrewQuartersGunRackItemSaveData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CrewQuartersGunRackItemSaveData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CrewQuartersGunRackSaveData {
    // message fields
    pub rack_save_data: ::protobuf::RepeatedField<CrewQuartersGunRackItemSaveData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CrewQuartersGunRackSaveData {
    fn default() -> &'a CrewQuartersGunRackSaveData {
        <CrewQuartersGunRackSaveData as ::protobuf::Message>::default_instance()
    }
}

impl CrewQuartersGunRackSaveData {
    pub fn new() -> CrewQuartersGunRackSaveData {
        ::std::default::Default::default()
    }

    // repeated .OakSave.CrewQuartersGunRackItemSaveData rack_save_data = 1;


    pub fn get_rack_save_data(&self) -> &[CrewQuartersGunRackItemSaveData] {
        &self.rack_save_data
    }
    pub fn clear_rack_save_data(&mut self) {
        self.rack_save_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_rack_save_data(&mut self, v: ::protobuf::RepeatedField<CrewQuartersGunRackItemSaveData>) {
        self.rack_save_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rack_save_data(&mut self) -> &mut ::protobuf::RepeatedField<CrewQuartersGunRackItemSaveData> {
        &mut self.rack_save_data
    }

    // Take field
    pub fn take_rack_save_data(&mut self) -> ::protobuf::RepeatedField<CrewQuartersGunRackItemSaveData> {
        ::std::mem::replace(&mut self.rack_save_data, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CrewQuartersGunRackSaveData {
    fn is_initialized(&self) -> bool {
        for v in &self.rack_save_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rack_save_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.rack_save_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.rack_save_data {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CrewQuartersGunRackSaveData {
        CrewQuartersGunRackSaveData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CrewQuartersGunRackItemSaveData>>(
                "rack_save_data",
                |m: &CrewQuartersGunRackSaveData| { &m.rack_save_data },
                |m: &mut CrewQuartersGunRackSaveData| { &mut m.rack_save_data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CrewQuartersGunRackSaveData>(
                "CrewQuartersGunRackSaveData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CrewQuartersGunRackSaveData {
        static instance: ::protobuf::rt::LazyV2<CrewQuartersGunRackSaveData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CrewQuartersGunRackSaveData::new)
    }
}

impl ::protobuf::Clear for CrewQuartersGunRackSaveData {
    fn clear(&mut self) {
        self.rack_save_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CrewQuartersGunRackSaveData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CrewQuartersGunRackSaveData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EchoLogSaveGameData {
    // message fields
    pub has_been_seen_in_log: bool,
    pub echo_log_path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EchoLogSaveGameData {
    fn default() -> &'a EchoLogSaveGameData {
        <EchoLogSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl EchoLogSaveGameData {
    pub fn new() -> EchoLogSaveGameData {
        ::std::default::Default::default()
    }

    // bool has_been_seen_in_log = 1;


    pub fn get_has_been_seen_in_log(&self) -> bool {
        self.has_been_seen_in_log
    }
    pub fn clear_has_been_seen_in_log(&mut self) {
        self.has_been_seen_in_log = false;
    }

    // Param is passed by value, moved
    pub fn set_has_been_seen_in_log(&mut self, v: bool) {
        self.has_been_seen_in_log = v;
    }

    // string echo_log_path = 2;


    pub fn get_echo_log_path(&self) -> &str {
        &self.echo_log_path
    }
    pub fn clear_echo_log_path(&mut self) {
        self.echo_log_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_echo_log_path(&mut self, v: ::std::string::String) {
        self.echo_log_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_echo_log_path(&mut self) -> &mut ::std::string::String {
        &mut self.echo_log_path
    }

    // Take field
    pub fn take_echo_log_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.echo_log_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for EchoLogSaveGameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_been_seen_in_log = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.echo_log_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.has_been_seen_in_log != false {
            my_size += 2;
        }
        if !self.echo_log_path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.echo_log_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.has_been_seen_in_log != false {
            os.write_bool(1, self.has_been_seen_in_log)?;
        }
        if !self.echo_log_path.is_empty() {
            os.write_string(2, &self.echo_log_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EchoLogSaveGameData {
        EchoLogSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_been_seen_in_log",
                |m: &EchoLogSaveGameData| { &m.has_been_seen_in_log },
                |m: &mut EchoLogSaveGameData| { &mut m.has_been_seen_in_log },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "echo_log_path",
                |m: &EchoLogSaveGameData| { &m.echo_log_path },
                |m: &mut EchoLogSaveGameData| { &mut m.echo_log_path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EchoLogSaveGameData>(
                "EchoLogSaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EchoLogSaveGameData {
        static instance: ::protobuf::rt::LazyV2<EchoLogSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EchoLogSaveGameData::new)
    }
}

impl ::protobuf::Clear for EchoLogSaveGameData {
    fn clear(&mut self) {
        self.has_been_seen_in_log = false;
        self.echo_log_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EchoLogSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EchoLogSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MapIDData {
    // message fields
    pub zone_name_id: u32,
    pub map_name_id: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MapIDData {
    fn default() -> &'a MapIDData {
        <MapIDData as ::protobuf::Message>::default_instance()
    }
}

impl MapIDData {
    pub fn new() -> MapIDData {
        ::std::default::Default::default()
    }

    // uint32 zone_name_id = 1;


    pub fn get_zone_name_id(&self) -> u32 {
        self.zone_name_id
    }
    pub fn clear_zone_name_id(&mut self) {
        self.zone_name_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_zone_name_id(&mut self, v: u32) {
        self.zone_name_id = v;
    }

    // uint32 map_name_id = 2;


    pub fn get_map_name_id(&self) -> u32 {
        self.map_name_id
    }
    pub fn clear_map_name_id(&mut self) {
        self.map_name_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_map_name_id(&mut self, v: u32) {
        self.map_name_id = v;
    }
}

impl ::protobuf::Message for MapIDData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.zone_name_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.map_name_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.zone_name_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.zone_name_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.map_name_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.map_name_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.zone_name_id != 0 {
            os.write_uint32(1, self.zone_name_id)?;
        }
        if self.map_name_id != 0 {
            os.write_uint32(2, self.map_name_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MapIDData {
        MapIDData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "zone_name_id",
                |m: &MapIDData| { &m.zone_name_id },
                |m: &mut MapIDData| { &mut m.zone_name_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "map_name_id",
                |m: &MapIDData| { &m.map_name_id },
                |m: &mut MapIDData| { &mut m.map_name_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MapIDData>(
                "MapIDData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MapIDData {
        static instance: ::protobuf::rt::LazyV2<MapIDData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MapIDData::new)
    }
}

impl ::protobuf::Clear for MapIDData {
    fn clear(&mut self) {
        self.zone_name_id = 0;
        self.map_name_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MapIDData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MapIDData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GameStateSaveData {
    // message fields
    pub last_traveled_map_id: ::protobuf::SingularPtrField<MapIDData>,
    pub mayhem_level: i32,
    pub mayhem_random_seed: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GameStateSaveData {
    fn default() -> &'a GameStateSaveData {
        <GameStateSaveData as ::protobuf::Message>::default_instance()
    }
}

impl GameStateSaveData {
    pub fn new() -> GameStateSaveData {
        ::std::default::Default::default()
    }

    // .OakSave.MapIDData last_traveled_map_id = 1;


    pub fn get_last_traveled_map_id(&self) -> &MapIDData {
        self.last_traveled_map_id.as_ref().unwrap_or_else(|| <MapIDData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_last_traveled_map_id(&mut self) {
        self.last_traveled_map_id.clear();
    }

    pub fn has_last_traveled_map_id(&self) -> bool {
        self.last_traveled_map_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_traveled_map_id(&mut self, v: MapIDData) {
        self.last_traveled_map_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_traveled_map_id(&mut self) -> &mut MapIDData {
        if self.last_traveled_map_id.is_none() {
            self.last_traveled_map_id.set_default();
        }
        self.last_traveled_map_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_traveled_map_id(&mut self) -> MapIDData {
        self.last_traveled_map_id.take().unwrap_or_else(|| MapIDData::new())
    }

    // int32 mayhem_level = 2;


    pub fn get_mayhem_level(&self) -> i32 {
        self.mayhem_level
    }
    pub fn clear_mayhem_level(&mut self) {
        self.mayhem_level = 0;
    }

    // Param is passed by value, moved
    pub fn set_mayhem_level(&mut self, v: i32) {
        self.mayhem_level = v;
    }

    // int32 mayhem_random_seed = 3;


    pub fn get_mayhem_random_seed(&self) -> i32 {
        self.mayhem_random_seed
    }
    pub fn clear_mayhem_random_seed(&mut self) {
        self.mayhem_random_seed = 0;
    }

    // Param is passed by value, moved
    pub fn set_mayhem_random_seed(&mut self, v: i32) {
        self.mayhem_random_seed = v;
    }
}

impl ::protobuf::Message for GameStateSaveData {
    fn is_initialized(&self) -> bool {
        for v in &self.last_traveled_map_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last_traveled_map_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mayhem_level = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mayhem_random_seed = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.last_traveled_map_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.mayhem_level != 0 {
            my_size += ::protobuf::rt::value_size(2, self.mayhem_level, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.mayhem_random_seed != 0 {
            my_size += ::protobuf::rt::value_size(3, self.mayhem_random_seed, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.last_traveled_map_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.mayhem_level != 0 {
            os.write_int32(2, self.mayhem_level)?;
        }
        if self.mayhem_random_seed != 0 {
            os.write_int32(3, self.mayhem_random_seed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GameStateSaveData {
        GameStateSaveData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MapIDData>>(
                "last_traveled_map_id",
                |m: &GameStateSaveData| { &m.last_traveled_map_id },
                |m: &mut GameStateSaveData| { &mut m.last_traveled_map_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "mayhem_level",
                |m: &GameStateSaveData| { &m.mayhem_level },
                |m: &mut GameStateSaveData| { &mut m.mayhem_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "mayhem_random_seed",
                |m: &GameStateSaveData| { &m.mayhem_random_seed },
                |m: &mut GameStateSaveData| { &mut m.mayhem_random_seed },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GameStateSaveData>(
                "GameStateSaveData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GameStateSaveData {
        static instance: ::protobuf::rt::LazyV2<GameStateSaveData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GameStateSaveData::new)
    }
}

impl ::protobuf::Clear for GameStateSaveData {
    fn clear(&mut self) {
        self.last_traveled_map_id.clear();
        self.mayhem_level = 0;
        self.mayhem_random_seed = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GameStateSaveData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GameStateSaveData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChallengeCategoryProgressSaveData {
    // message fields
    pub category_progress: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChallengeCategoryProgressSaveData {
    fn default() -> &'a ChallengeCategoryProgressSaveData {
        <ChallengeCategoryProgressSaveData as ::protobuf::Message>::default_instance()
    }
}

impl ChallengeCategoryProgressSaveData {
    pub fn new() -> ChallengeCategoryProgressSaveData {
        ::std::default::Default::default()
    }

    // bytes category_progress = 1;


    pub fn get_category_progress(&self) -> &[u8] {
        &self.category_progress
    }
    pub fn clear_category_progress(&mut self) {
        self.category_progress.clear();
    }

    // Param is passed by value, moved
    pub fn set_category_progress(&mut self, v: ::std::vec::Vec<u8>) {
        self.category_progress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_category_progress(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.category_progress
    }

    // Take field
    pub fn take_category_progress(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.category_progress, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ChallengeCategoryProgressSaveData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.category_progress)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.category_progress.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.category_progress);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.category_progress.is_empty() {
            os.write_bytes(1, &self.category_progress)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChallengeCategoryProgressSaveData {
        ChallengeCategoryProgressSaveData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "category_progress",
                |m: &ChallengeCategoryProgressSaveData| { &m.category_progress },
                |m: &mut ChallengeCategoryProgressSaveData| { &mut m.category_progress },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChallengeCategoryProgressSaveData>(
                "ChallengeCategoryProgressSaveData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChallengeCategoryProgressSaveData {
        static instance: ::protobuf::rt::LazyV2<ChallengeCategoryProgressSaveData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChallengeCategoryProgressSaveData::new)
    }
}

impl ::protobuf::Clear for ChallengeCategoryProgressSaveData {
    fn clear(&mut self) {
        self.category_progress.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChallengeCategoryProgressSaveData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChallengeCategoryProgressSaveData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OakPlayerCharacterAugmentSaveGameData {
    // message fields
    pub slot_asset_path: ::std::string::String,
    pub augment_asset_path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OakPlayerCharacterAugmentSaveGameData {
    fn default() -> &'a OakPlayerCharacterAugmentSaveGameData {
        <OakPlayerCharacterAugmentSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl OakPlayerCharacterAugmentSaveGameData {
    pub fn new() -> OakPlayerCharacterAugmentSaveGameData {
        ::std::default::Default::default()
    }

    // string slot_asset_path = 1;


    pub fn get_slot_asset_path(&self) -> &str {
        &self.slot_asset_path
    }
    pub fn clear_slot_asset_path(&mut self) {
        self.slot_asset_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_slot_asset_path(&mut self, v: ::std::string::String) {
        self.slot_asset_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_slot_asset_path(&mut self) -> &mut ::std::string::String {
        &mut self.slot_asset_path
    }

    // Take field
    pub fn take_slot_asset_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.slot_asset_path, ::std::string::String::new())
    }

    // string augment_asset_path = 2;


    pub fn get_augment_asset_path(&self) -> &str {
        &self.augment_asset_path
    }
    pub fn clear_augment_asset_path(&mut self) {
        self.augment_asset_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_augment_asset_path(&mut self, v: ::std::string::String) {
        self.augment_asset_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_augment_asset_path(&mut self) -> &mut ::std::string::String {
        &mut self.augment_asset_path
    }

    // Take field
    pub fn take_augment_asset_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.augment_asset_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OakPlayerCharacterAugmentSaveGameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.slot_asset_path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.augment_asset_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.slot_asset_path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.slot_asset_path);
        }
        if !self.augment_asset_path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.augment_asset_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.slot_asset_path.is_empty() {
            os.write_string(1, &self.slot_asset_path)?;
        }
        if !self.augment_asset_path.is_empty() {
            os.write_string(2, &self.augment_asset_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OakPlayerCharacterAugmentSaveGameData {
        OakPlayerCharacterAugmentSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "slot_asset_path",
                |m: &OakPlayerCharacterAugmentSaveGameData| { &m.slot_asset_path },
                |m: &mut OakPlayerCharacterAugmentSaveGameData| { &mut m.slot_asset_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "augment_asset_path",
                |m: &OakPlayerCharacterAugmentSaveGameData| { &m.augment_asset_path },
                |m: &mut OakPlayerCharacterAugmentSaveGameData| { &mut m.augment_asset_path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OakPlayerCharacterAugmentSaveGameData>(
                "OakPlayerCharacterAugmentSaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OakPlayerCharacterAugmentSaveGameData {
        static instance: ::protobuf::rt::LazyV2<OakPlayerCharacterAugmentSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OakPlayerCharacterAugmentSaveGameData::new)
    }
}

impl ::protobuf::Clear for OakPlayerCharacterAugmentSaveGameData {
    fn clear(&mut self) {
        self.slot_asset_path.clear();
        self.augment_asset_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OakPlayerCharacterAugmentSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OakPlayerCharacterAugmentSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OakPlayerCharacterSlotSaveGameData {
    // message fields
    pub augment_slot_list: ::protobuf::RepeatedField<OakPlayerCharacterAugmentSaveGameData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OakPlayerCharacterSlotSaveGameData {
    fn default() -> &'a OakPlayerCharacterSlotSaveGameData {
        <OakPlayerCharacterSlotSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl OakPlayerCharacterSlotSaveGameData {
    pub fn new() -> OakPlayerCharacterSlotSaveGameData {
        ::std::default::Default::default()
    }

    // repeated .OakSave.OakPlayerCharacterAugmentSaveGameData augment_slot_list = 1;


    pub fn get_augment_slot_list(&self) -> &[OakPlayerCharacterAugmentSaveGameData] {
        &self.augment_slot_list
    }
    pub fn clear_augment_slot_list(&mut self) {
        self.augment_slot_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_augment_slot_list(&mut self, v: ::protobuf::RepeatedField<OakPlayerCharacterAugmentSaveGameData>) {
        self.augment_slot_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_augment_slot_list(&mut self) -> &mut ::protobuf::RepeatedField<OakPlayerCharacterAugmentSaveGameData> {
        &mut self.augment_slot_list
    }

    // Take field
    pub fn take_augment_slot_list(&mut self) -> ::protobuf::RepeatedField<OakPlayerCharacterAugmentSaveGameData> {
        ::std::mem::replace(&mut self.augment_slot_list, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for OakPlayerCharacterSlotSaveGameData {
    fn is_initialized(&self) -> bool {
        for v in &self.augment_slot_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.augment_slot_list)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.augment_slot_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.augment_slot_list {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OakPlayerCharacterSlotSaveGameData {
        OakPlayerCharacterSlotSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OakPlayerCharacterAugmentSaveGameData>>(
                "augment_slot_list",
                |m: &OakPlayerCharacterSlotSaveGameData| { &m.augment_slot_list },
                |m: &mut OakPlayerCharacterSlotSaveGameData| { &mut m.augment_slot_list },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OakPlayerCharacterSlotSaveGameData>(
                "OakPlayerCharacterSlotSaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OakPlayerCharacterSlotSaveGameData {
        static instance: ::protobuf::rt::LazyV2<OakPlayerCharacterSlotSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OakPlayerCharacterSlotSaveGameData::new)
    }
}

impl ::protobuf::Clear for OakPlayerCharacterSlotSaveGameData {
    fn clear(&mut self) {
        self.augment_slot_list.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OakPlayerCharacterSlotSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OakPlayerCharacterSlotSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UITrackingSaveGameData {
    // message fields
    pub has_seen_skill_menu_unlock: bool,
    pub has_seen_guardian_rank_menu_unlock: bool,
    pub has_seen_echo_boot_ammo_bar: bool,
    pub has_seen_echo_boot_shield_bar: bool,
    pub has_seen_echo_boot_grenades: bool,
    pub highest_thvm_breadcrumb_seen: i32,
    pub inventory_slot_unlocks_seen: ::protobuf::RepeatedField<::std::string::String>,
    pub saved_spin_offset: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UITrackingSaveGameData {
    fn default() -> &'a UITrackingSaveGameData {
        <UITrackingSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl UITrackingSaveGameData {
    pub fn new() -> UITrackingSaveGameData {
        ::std::default::Default::default()
    }

    // bool has_seen_skill_menu_unlock = 1;


    pub fn get_has_seen_skill_menu_unlock(&self) -> bool {
        self.has_seen_skill_menu_unlock
    }
    pub fn clear_has_seen_skill_menu_unlock(&mut self) {
        self.has_seen_skill_menu_unlock = false;
    }

    // Param is passed by value, moved
    pub fn set_has_seen_skill_menu_unlock(&mut self, v: bool) {
        self.has_seen_skill_menu_unlock = v;
    }

    // bool has_seen_guardian_rank_menu_unlock = 2;


    pub fn get_has_seen_guardian_rank_menu_unlock(&self) -> bool {
        self.has_seen_guardian_rank_menu_unlock
    }
    pub fn clear_has_seen_guardian_rank_menu_unlock(&mut self) {
        self.has_seen_guardian_rank_menu_unlock = false;
    }

    // Param is passed by value, moved
    pub fn set_has_seen_guardian_rank_menu_unlock(&mut self, v: bool) {
        self.has_seen_guardian_rank_menu_unlock = v;
    }

    // bool has_seen_echo_boot_ammo_bar = 3;


    pub fn get_has_seen_echo_boot_ammo_bar(&self) -> bool {
        self.has_seen_echo_boot_ammo_bar
    }
    pub fn clear_has_seen_echo_boot_ammo_bar(&mut self) {
        self.has_seen_echo_boot_ammo_bar = false;
    }

    // Param is passed by value, moved
    pub fn set_has_seen_echo_boot_ammo_bar(&mut self, v: bool) {
        self.has_seen_echo_boot_ammo_bar = v;
    }

    // bool has_seen_echo_boot_shield_bar = 4;


    pub fn get_has_seen_echo_boot_shield_bar(&self) -> bool {
        self.has_seen_echo_boot_shield_bar
    }
    pub fn clear_has_seen_echo_boot_shield_bar(&mut self) {
        self.has_seen_echo_boot_shield_bar = false;
    }

    // Param is passed by value, moved
    pub fn set_has_seen_echo_boot_shield_bar(&mut self, v: bool) {
        self.has_seen_echo_boot_shield_bar = v;
    }

    // bool has_seen_echo_boot_grenades = 5;


    pub fn get_has_seen_echo_boot_grenades(&self) -> bool {
        self.has_seen_echo_boot_grenades
    }
    pub fn clear_has_seen_echo_boot_grenades(&mut self) {
        self.has_seen_echo_boot_grenades = false;
    }

    // Param is passed by value, moved
    pub fn set_has_seen_echo_boot_grenades(&mut self, v: bool) {
        self.has_seen_echo_boot_grenades = v;
    }

    // int32 highest_thvm_breadcrumb_seen = 6;


    pub fn get_highest_thvm_breadcrumb_seen(&self) -> i32 {
        self.highest_thvm_breadcrumb_seen
    }
    pub fn clear_highest_thvm_breadcrumb_seen(&mut self) {
        self.highest_thvm_breadcrumb_seen = 0;
    }

    // Param is passed by value, moved
    pub fn set_highest_thvm_breadcrumb_seen(&mut self, v: i32) {
        self.highest_thvm_breadcrumb_seen = v;
    }

    // repeated string inventory_slot_unlocks_seen = 7;


    pub fn get_inventory_slot_unlocks_seen(&self) -> &[::std::string::String] {
        &self.inventory_slot_unlocks_seen
    }
    pub fn clear_inventory_slot_unlocks_seen(&mut self) {
        self.inventory_slot_unlocks_seen.clear();
    }

    // Param is passed by value, moved
    pub fn set_inventory_slot_unlocks_seen(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.inventory_slot_unlocks_seen = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inventory_slot_unlocks_seen(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.inventory_slot_unlocks_seen
    }

    // Take field
    pub fn take_inventory_slot_unlocks_seen(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.inventory_slot_unlocks_seen, ::protobuf::RepeatedField::new())
    }

    // int32 saved_spin_offset = 8;


    pub fn get_saved_spin_offset(&self) -> i32 {
        self.saved_spin_offset
    }
    pub fn clear_saved_spin_offset(&mut self) {
        self.saved_spin_offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_saved_spin_offset(&mut self, v: i32) {
        self.saved_spin_offset = v;
    }
}

impl ::protobuf::Message for UITrackingSaveGameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_seen_skill_menu_unlock = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_seen_guardian_rank_menu_unlock = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_seen_echo_boot_ammo_bar = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_seen_echo_boot_shield_bar = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_seen_echo_boot_grenades = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.highest_thvm_breadcrumb_seen = tmp;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.inventory_slot_unlocks_seen)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.saved_spin_offset = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.has_seen_skill_menu_unlock != false {
            my_size += 2;
        }
        if self.has_seen_guardian_rank_menu_unlock != false {
            my_size += 2;
        }
        if self.has_seen_echo_boot_ammo_bar != false {
            my_size += 2;
        }
        if self.has_seen_echo_boot_shield_bar != false {
            my_size += 2;
        }
        if self.has_seen_echo_boot_grenades != false {
            my_size += 2;
        }
        if self.highest_thvm_breadcrumb_seen != 0 {
            my_size += ::protobuf::rt::value_size(6, self.highest_thvm_breadcrumb_seen, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.inventory_slot_unlocks_seen {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if self.saved_spin_offset != 0 {
            my_size += ::protobuf::rt::value_size(8, self.saved_spin_offset, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.has_seen_skill_menu_unlock != false {
            os.write_bool(1, self.has_seen_skill_menu_unlock)?;
        }
        if self.has_seen_guardian_rank_menu_unlock != false {
            os.write_bool(2, self.has_seen_guardian_rank_menu_unlock)?;
        }
        if self.has_seen_echo_boot_ammo_bar != false {
            os.write_bool(3, self.has_seen_echo_boot_ammo_bar)?;
        }
        if self.has_seen_echo_boot_shield_bar != false {
            os.write_bool(4, self.has_seen_echo_boot_shield_bar)?;
        }
        if self.has_seen_echo_boot_grenades != false {
            os.write_bool(5, self.has_seen_echo_boot_grenades)?;
        }
        if self.highest_thvm_breadcrumb_seen != 0 {
            os.write_int32(6, self.highest_thvm_breadcrumb_seen)?;
        }
        for v in &self.inventory_slot_unlocks_seen {
            os.write_string(7, &v)?;
        };
        if self.saved_spin_offset != 0 {
            os.write_int32(8, self.saved_spin_offset)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UITrackingSaveGameData {
        UITrackingSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_seen_skill_menu_unlock",
                |m: &UITrackingSaveGameData| { &m.has_seen_skill_menu_unlock },
                |m: &mut UITrackingSaveGameData| { &mut m.has_seen_skill_menu_unlock },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_seen_guardian_rank_menu_unlock",
                |m: &UITrackingSaveGameData| { &m.has_seen_guardian_rank_menu_unlock },
                |m: &mut UITrackingSaveGameData| { &mut m.has_seen_guardian_rank_menu_unlock },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_seen_echo_boot_ammo_bar",
                |m: &UITrackingSaveGameData| { &m.has_seen_echo_boot_ammo_bar },
                |m: &mut UITrackingSaveGameData| { &mut m.has_seen_echo_boot_ammo_bar },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_seen_echo_boot_shield_bar",
                |m: &UITrackingSaveGameData| { &m.has_seen_echo_boot_shield_bar },
                |m: &mut UITrackingSaveGameData| { &mut m.has_seen_echo_boot_shield_bar },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_seen_echo_boot_grenades",
                |m: &UITrackingSaveGameData| { &m.has_seen_echo_boot_grenades },
                |m: &mut UITrackingSaveGameData| { &mut m.has_seen_echo_boot_grenades },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "highest_thvm_breadcrumb_seen",
                |m: &UITrackingSaveGameData| { &m.highest_thvm_breadcrumb_seen },
                |m: &mut UITrackingSaveGameData| { &mut m.highest_thvm_breadcrumb_seen },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "inventory_slot_unlocks_seen",
                |m: &UITrackingSaveGameData| { &m.inventory_slot_unlocks_seen },
                |m: &mut UITrackingSaveGameData| { &mut m.inventory_slot_unlocks_seen },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "saved_spin_offset",
                |m: &UITrackingSaveGameData| { &m.saved_spin_offset },
                |m: &mut UITrackingSaveGameData| { &mut m.saved_spin_offset },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UITrackingSaveGameData>(
                "UITrackingSaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UITrackingSaveGameData {
        static instance: ::protobuf::rt::LazyV2<UITrackingSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UITrackingSaveGameData::new)
    }
}

impl ::protobuf::Clear for UITrackingSaveGameData {
    fn clear(&mut self) {
        self.has_seen_skill_menu_unlock = false;
        self.has_seen_guardian_rank_menu_unlock = false;
        self.has_seen_echo_boot_ammo_bar = false;
        self.has_seen_echo_boot_shield_bar = false;
        self.has_seen_echo_boot_grenades = false;
        self.highest_thvm_breadcrumb_seen = 0;
        self.inventory_slot_unlocks_seen.clear();
        self.saved_spin_offset = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UITrackingSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UITrackingSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlanetCycleInfo {
    // message fields
    pub planet_name: ::std::string::String,
    pub cycle_length: f32,
    pub last_cached_time: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlanetCycleInfo {
    fn default() -> &'a PlanetCycleInfo {
        <PlanetCycleInfo as ::protobuf::Message>::default_instance()
    }
}

impl PlanetCycleInfo {
    pub fn new() -> PlanetCycleInfo {
        ::std::default::Default::default()
    }

    // string planet_name = 1;


    pub fn get_planet_name(&self) -> &str {
        &self.planet_name
    }
    pub fn clear_planet_name(&mut self) {
        self.planet_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_planet_name(&mut self, v: ::std::string::String) {
        self.planet_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_planet_name(&mut self) -> &mut ::std::string::String {
        &mut self.planet_name
    }

    // Take field
    pub fn take_planet_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.planet_name, ::std::string::String::new())
    }

    // float cycle_length = 2;


    pub fn get_cycle_length(&self) -> f32 {
        self.cycle_length
    }
    pub fn clear_cycle_length(&mut self) {
        self.cycle_length = 0.;
    }

    // Param is passed by value, moved
    pub fn set_cycle_length(&mut self, v: f32) {
        self.cycle_length = v;
    }

    // float last_cached_time = 3;


    pub fn get_last_cached_time(&self) -> f32 {
        self.last_cached_time
    }
    pub fn clear_last_cached_time(&mut self) {
        self.last_cached_time = 0.;
    }

    // Param is passed by value, moved
    pub fn set_last_cached_time(&mut self, v: f32) {
        self.last_cached_time = v;
    }
}

impl ::protobuf::Message for PlanetCycleInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.planet_name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.cycle_length = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.last_cached_time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.planet_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.planet_name);
        }
        if self.cycle_length != 0. {
            my_size += 5;
        }
        if self.last_cached_time != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.planet_name.is_empty() {
            os.write_string(1, &self.planet_name)?;
        }
        if self.cycle_length != 0. {
            os.write_float(2, self.cycle_length)?;
        }
        if self.last_cached_time != 0. {
            os.write_float(3, self.last_cached_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlanetCycleInfo {
        PlanetCycleInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "planet_name",
                |m: &PlanetCycleInfo| { &m.planet_name },
                |m: &mut PlanetCycleInfo| { &mut m.planet_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "cycle_length",
                |m: &PlanetCycleInfo| { &m.cycle_length },
                |m: &mut PlanetCycleInfo| { &mut m.cycle_length },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "last_cached_time",
                |m: &PlanetCycleInfo| { &m.last_cached_time },
                |m: &mut PlanetCycleInfo| { &mut m.last_cached_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlanetCycleInfo>(
                "PlanetCycleInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlanetCycleInfo {
        static instance: ::protobuf::rt::LazyV2<PlanetCycleInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlanetCycleInfo::new)
    }
}

impl ::protobuf::Clear for PlanetCycleInfo {
    fn clear(&mut self) {
        self.planet_name.clear();
        self.cycle_length = 0.;
        self.last_cached_time = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlanetCycleInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlanetCycleInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TimeOfDaySaveGameData {
    // message fields
    pub planet_cycle_info: ::protobuf::RepeatedField<PlanetCycleInfo>,
    pub planet_cycle: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TimeOfDaySaveGameData {
    fn default() -> &'a TimeOfDaySaveGameData {
        <TimeOfDaySaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl TimeOfDaySaveGameData {
    pub fn new() -> TimeOfDaySaveGameData {
        ::std::default::Default::default()
    }

    // repeated .OakSave.PlanetCycleInfo planet_cycle_info = 1;


    pub fn get_planet_cycle_info(&self) -> &[PlanetCycleInfo] {
        &self.planet_cycle_info
    }
    pub fn clear_planet_cycle_info(&mut self) {
        self.planet_cycle_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_planet_cycle_info(&mut self, v: ::protobuf::RepeatedField<PlanetCycleInfo>) {
        self.planet_cycle_info = v;
    }

    // Mutable pointer to the field.
    pub fn mut_planet_cycle_info(&mut self) -> &mut ::protobuf::RepeatedField<PlanetCycleInfo> {
        &mut self.planet_cycle_info
    }

    // Take field
    pub fn take_planet_cycle_info(&mut self) -> ::protobuf::RepeatedField<PlanetCycleInfo> {
        ::std::mem::replace(&mut self.planet_cycle_info, ::protobuf::RepeatedField::new())
    }

    // string planet_cycle = 2;


    pub fn get_planet_cycle(&self) -> &str {
        &self.planet_cycle
    }
    pub fn clear_planet_cycle(&mut self) {
        self.planet_cycle.clear();
    }

    // Param is passed by value, moved
    pub fn set_planet_cycle(&mut self, v: ::std::string::String) {
        self.planet_cycle = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_planet_cycle(&mut self) -> &mut ::std::string::String {
        &mut self.planet_cycle
    }

    // Take field
    pub fn take_planet_cycle(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.planet_cycle, ::std::string::String::new())
    }
}

impl ::protobuf::Message for TimeOfDaySaveGameData {
    fn is_initialized(&self) -> bool {
        for v in &self.planet_cycle_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.planet_cycle_info)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.planet_cycle)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.planet_cycle_info {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.planet_cycle.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.planet_cycle);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.planet_cycle_info {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.planet_cycle.is_empty() {
            os.write_string(2, &self.planet_cycle)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimeOfDaySaveGameData {
        TimeOfDaySaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlanetCycleInfo>>(
                "planet_cycle_info",
                |m: &TimeOfDaySaveGameData| { &m.planet_cycle_info },
                |m: &mut TimeOfDaySaveGameData| { &mut m.planet_cycle_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "planet_cycle",
                |m: &TimeOfDaySaveGameData| { &m.planet_cycle },
                |m: &mut TimeOfDaySaveGameData| { &mut m.planet_cycle },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TimeOfDaySaveGameData>(
                "TimeOfDaySaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TimeOfDaySaveGameData {
        static instance: ::protobuf::rt::LazyV2<TimeOfDaySaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TimeOfDaySaveGameData::new)
    }
}

impl ::protobuf::Clear for TimeOfDaySaveGameData {
    fn clear(&mut self) {
        self.planet_cycle_info.clear();
        self.planet_cycle.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimeOfDaySaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeOfDaySaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LevelPersistence_Actor_SaveGameData {
    // message fields
    pub actor_name: ::std::string::String,
    pub timer_remaining: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LevelPersistence_Actor_SaveGameData {
    fn default() -> &'a LevelPersistence_Actor_SaveGameData {
        <LevelPersistence_Actor_SaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl LevelPersistence_Actor_SaveGameData {
    pub fn new() -> LevelPersistence_Actor_SaveGameData {
        ::std::default::Default::default()
    }

    // string actor_name = 1;


    pub fn get_actor_name(&self) -> &str {
        &self.actor_name
    }
    pub fn clear_actor_name(&mut self) {
        self.actor_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_actor_name(&mut self, v: ::std::string::String) {
        self.actor_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actor_name(&mut self) -> &mut ::std::string::String {
        &mut self.actor_name
    }

    // Take field
    pub fn take_actor_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.actor_name, ::std::string::String::new())
    }

    // int32 timer_remaining = 2;


    pub fn get_timer_remaining(&self) -> i32 {
        self.timer_remaining
    }
    pub fn clear_timer_remaining(&mut self) {
        self.timer_remaining = 0;
    }

    // Param is passed by value, moved
    pub fn set_timer_remaining(&mut self, v: i32) {
        self.timer_remaining = v;
    }
}

impl ::protobuf::Message for LevelPersistence_Actor_SaveGameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.actor_name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.timer_remaining = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.actor_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.actor_name);
        }
        if self.timer_remaining != 0 {
            my_size += ::protobuf::rt::value_size(2, self.timer_remaining, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.actor_name.is_empty() {
            os.write_string(1, &self.actor_name)?;
        }
        if self.timer_remaining != 0 {
            os.write_int32(2, self.timer_remaining)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LevelPersistence_Actor_SaveGameData {
        LevelPersistence_Actor_SaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "actor_name",
                |m: &LevelPersistence_Actor_SaveGameData| { &m.actor_name },
                |m: &mut LevelPersistence_Actor_SaveGameData| { &mut m.actor_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "timer_remaining",
                |m: &LevelPersistence_Actor_SaveGameData| { &m.timer_remaining },
                |m: &mut LevelPersistence_Actor_SaveGameData| { &mut m.timer_remaining },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LevelPersistence_Actor_SaveGameData>(
                "LevelPersistence_Actor_SaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LevelPersistence_Actor_SaveGameData {
        static instance: ::protobuf::rt::LazyV2<LevelPersistence_Actor_SaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LevelPersistence_Actor_SaveGameData::new)
    }
}

impl ::protobuf::Clear for LevelPersistence_Actor_SaveGameData {
    fn clear(&mut self) {
        self.actor_name.clear();
        self.timer_remaining = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LevelPersistence_Actor_SaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LevelPersistence_Actor_SaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LevelPersistence_Level_SaveGameData {
    // message fields
    pub level_name: ::std::string::String,
    pub saved_actors: ::protobuf::RepeatedField<LevelPersistence_Actor_SaveGameData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LevelPersistence_Level_SaveGameData {
    fn default() -> &'a LevelPersistence_Level_SaveGameData {
        <LevelPersistence_Level_SaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl LevelPersistence_Level_SaveGameData {
    pub fn new() -> LevelPersistence_Level_SaveGameData {
        ::std::default::Default::default()
    }

    // string level_name = 1;


    pub fn get_level_name(&self) -> &str {
        &self.level_name
    }
    pub fn clear_level_name(&mut self) {
        self.level_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_level_name(&mut self, v: ::std::string::String) {
        self.level_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_level_name(&mut self) -> &mut ::std::string::String {
        &mut self.level_name
    }

    // Take field
    pub fn take_level_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.level_name, ::std::string::String::new())
    }

    // repeated .OakSave.LevelPersistence_Actor_SaveGameData saved_actors = 2;


    pub fn get_saved_actors(&self) -> &[LevelPersistence_Actor_SaveGameData] {
        &self.saved_actors
    }
    pub fn clear_saved_actors(&mut self) {
        self.saved_actors.clear();
    }

    // Param is passed by value, moved
    pub fn set_saved_actors(&mut self, v: ::protobuf::RepeatedField<LevelPersistence_Actor_SaveGameData>) {
        self.saved_actors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_saved_actors(&mut self) -> &mut ::protobuf::RepeatedField<LevelPersistence_Actor_SaveGameData> {
        &mut self.saved_actors
    }

    // Take field
    pub fn take_saved_actors(&mut self) -> ::protobuf::RepeatedField<LevelPersistence_Actor_SaveGameData> {
        ::std::mem::replace(&mut self.saved_actors, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for LevelPersistence_Level_SaveGameData {
    fn is_initialized(&self) -> bool {
        for v in &self.saved_actors {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.level_name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.saved_actors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.level_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.level_name);
        }
        for value in &self.saved_actors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.level_name.is_empty() {
            os.write_string(1, &self.level_name)?;
        }
        for v in &self.saved_actors {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LevelPersistence_Level_SaveGameData {
        LevelPersistence_Level_SaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "level_name",
                |m: &LevelPersistence_Level_SaveGameData| { &m.level_name },
                |m: &mut LevelPersistence_Level_SaveGameData| { &mut m.level_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LevelPersistence_Actor_SaveGameData>>(
                "saved_actors",
                |m: &LevelPersistence_Level_SaveGameData| { &m.saved_actors },
                |m: &mut LevelPersistence_Level_SaveGameData| { &mut m.saved_actors },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LevelPersistence_Level_SaveGameData>(
                "LevelPersistence_Level_SaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LevelPersistence_Level_SaveGameData {
        static instance: ::protobuf::rt::LazyV2<LevelPersistence_Level_SaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LevelPersistence_Level_SaveGameData::new)
    }
}

impl ::protobuf::Clear for LevelPersistence_Level_SaveGameData {
    fn clear(&mut self) {
        self.level_name.clear();
        self.saved_actors.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LevelPersistence_Level_SaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LevelPersistence_Level_SaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GbxZoneMapFODSavedLevelData {
    // message fields
    pub level_name: ::std::string::String,
    pub fod_texture_size: u32,
    pub num_chunks: u32,
    pub discovery_percentage: f32,
    pub data_state: u32,
    pub data_revision: u32,
    pub fod_data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GbxZoneMapFODSavedLevelData {
    fn default() -> &'a GbxZoneMapFODSavedLevelData {
        <GbxZoneMapFODSavedLevelData as ::protobuf::Message>::default_instance()
    }
}

impl GbxZoneMapFODSavedLevelData {
    pub fn new() -> GbxZoneMapFODSavedLevelData {
        ::std::default::Default::default()
    }

    // string level_name = 1;


    pub fn get_level_name(&self) -> &str {
        &self.level_name
    }
    pub fn clear_level_name(&mut self) {
        self.level_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_level_name(&mut self, v: ::std::string::String) {
        self.level_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_level_name(&mut self) -> &mut ::std::string::String {
        &mut self.level_name
    }

    // Take field
    pub fn take_level_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.level_name, ::std::string::String::new())
    }

    // uint32 fod_texture_size = 2;


    pub fn get_fod_texture_size(&self) -> u32 {
        self.fod_texture_size
    }
    pub fn clear_fod_texture_size(&mut self) {
        self.fod_texture_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_fod_texture_size(&mut self, v: u32) {
        self.fod_texture_size = v;
    }

    // uint32 num_chunks = 3;


    pub fn get_num_chunks(&self) -> u32 {
        self.num_chunks
    }
    pub fn clear_num_chunks(&mut self) {
        self.num_chunks = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_chunks(&mut self, v: u32) {
        self.num_chunks = v;
    }

    // float discovery_percentage = 4;


    pub fn get_discovery_percentage(&self) -> f32 {
        self.discovery_percentage
    }
    pub fn clear_discovery_percentage(&mut self) {
        self.discovery_percentage = 0.;
    }

    // Param is passed by value, moved
    pub fn set_discovery_percentage(&mut self, v: f32) {
        self.discovery_percentage = v;
    }

    // uint32 data_state = 5;


    pub fn get_data_state(&self) -> u32 {
        self.data_state
    }
    pub fn clear_data_state(&mut self) {
        self.data_state = 0;
    }

    // Param is passed by value, moved
    pub fn set_data_state(&mut self, v: u32) {
        self.data_state = v;
    }

    // uint32 data_revision = 6;


    pub fn get_data_revision(&self) -> u32 {
        self.data_revision
    }
    pub fn clear_data_revision(&mut self) {
        self.data_revision = 0;
    }

    // Param is passed by value, moved
    pub fn set_data_revision(&mut self, v: u32) {
        self.data_revision = v;
    }

    // bytes fod_data = 7;


    pub fn get_fod_data(&self) -> &[u8] {
        &self.fod_data
    }
    pub fn clear_fod_data(&mut self) {
        self.fod_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_fod_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.fod_data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fod_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.fod_data
    }

    // Take field
    pub fn take_fod_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.fod_data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GbxZoneMapFODSavedLevelData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.level_name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fod_texture_size = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_chunks = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.discovery_percentage = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.data_state = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.data_revision = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.fod_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.level_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.level_name);
        }
        if self.fod_texture_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.fod_texture_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_chunks != 0 {
            my_size += ::protobuf::rt::value_size(3, self.num_chunks, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.discovery_percentage != 0. {
            my_size += 5;
        }
        if self.data_state != 0 {
            my_size += ::protobuf::rt::value_size(5, self.data_state, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.data_revision != 0 {
            my_size += ::protobuf::rt::value_size(6, self.data_revision, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.fod_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.fod_data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.level_name.is_empty() {
            os.write_string(1, &self.level_name)?;
        }
        if self.fod_texture_size != 0 {
            os.write_uint32(2, self.fod_texture_size)?;
        }
        if self.num_chunks != 0 {
            os.write_uint32(3, self.num_chunks)?;
        }
        if self.discovery_percentage != 0. {
            os.write_float(4, self.discovery_percentage)?;
        }
        if self.data_state != 0 {
            os.write_uint32(5, self.data_state)?;
        }
        if self.data_revision != 0 {
            os.write_uint32(6, self.data_revision)?;
        }
        if !self.fod_data.is_empty() {
            os.write_bytes(7, &self.fod_data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GbxZoneMapFODSavedLevelData {
        GbxZoneMapFODSavedLevelData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "level_name",
                |m: &GbxZoneMapFODSavedLevelData| { &m.level_name },
                |m: &mut GbxZoneMapFODSavedLevelData| { &mut m.level_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "fod_texture_size",
                |m: &GbxZoneMapFODSavedLevelData| { &m.fod_texture_size },
                |m: &mut GbxZoneMapFODSavedLevelData| { &mut m.fod_texture_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_chunks",
                |m: &GbxZoneMapFODSavedLevelData| { &m.num_chunks },
                |m: &mut GbxZoneMapFODSavedLevelData| { &mut m.num_chunks },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "discovery_percentage",
                |m: &GbxZoneMapFODSavedLevelData| { &m.discovery_percentage },
                |m: &mut GbxZoneMapFODSavedLevelData| { &mut m.discovery_percentage },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "data_state",
                |m: &GbxZoneMapFODSavedLevelData| { &m.data_state },
                |m: &mut GbxZoneMapFODSavedLevelData| { &mut m.data_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "data_revision",
                |m: &GbxZoneMapFODSavedLevelData| { &m.data_revision },
                |m: &mut GbxZoneMapFODSavedLevelData| { &mut m.data_revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "fod_data",
                |m: &GbxZoneMapFODSavedLevelData| { &m.fod_data },
                |m: &mut GbxZoneMapFODSavedLevelData| { &mut m.fod_data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GbxZoneMapFODSavedLevelData>(
                "GbxZoneMapFODSavedLevelData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GbxZoneMapFODSavedLevelData {
        static instance: ::protobuf::rt::LazyV2<GbxZoneMapFODSavedLevelData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GbxZoneMapFODSavedLevelData::new)
    }
}

impl ::protobuf::Clear for GbxZoneMapFODSavedLevelData {
    fn clear(&mut self) {
        self.level_name.clear();
        self.fod_texture_size = 0;
        self.num_chunks = 0;
        self.discovery_percentage = 0.;
        self.data_state = 0;
        self.data_revision = 0;
        self.fod_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GbxZoneMapFODSavedLevelData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GbxZoneMapFODSavedLevelData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GbxZoneMapFODSaveGameData {
    // message fields
    pub level_data: ::protobuf::RepeatedField<GbxZoneMapFODSavedLevelData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GbxZoneMapFODSaveGameData {
    fn default() -> &'a GbxZoneMapFODSaveGameData {
        <GbxZoneMapFODSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl GbxZoneMapFODSaveGameData {
    pub fn new() -> GbxZoneMapFODSaveGameData {
        ::std::default::Default::default()
    }

    // repeated .OakSave.GbxZoneMapFODSavedLevelData level_data = 1;


    pub fn get_level_data(&self) -> &[GbxZoneMapFODSavedLevelData] {
        &self.level_data
    }
    pub fn clear_level_data(&mut self) {
        self.level_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_level_data(&mut self, v: ::protobuf::RepeatedField<GbxZoneMapFODSavedLevelData>) {
        self.level_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_level_data(&mut self) -> &mut ::protobuf::RepeatedField<GbxZoneMapFODSavedLevelData> {
        &mut self.level_data
    }

    // Take field
    pub fn take_level_data(&mut self) -> ::protobuf::RepeatedField<GbxZoneMapFODSavedLevelData> {
        ::std::mem::replace(&mut self.level_data, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GbxZoneMapFODSaveGameData {
    fn is_initialized(&self) -> bool {
        for v in &self.level_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.level_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.level_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.level_data {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GbxZoneMapFODSaveGameData {
        GbxZoneMapFODSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GbxZoneMapFODSavedLevelData>>(
                "level_data",
                |m: &GbxZoneMapFODSaveGameData| { &m.level_data },
                |m: &mut GbxZoneMapFODSaveGameData| { &mut m.level_data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GbxZoneMapFODSaveGameData>(
                "GbxZoneMapFODSaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GbxZoneMapFODSaveGameData {
        static instance: ::protobuf::rt::LazyV2<GbxZoneMapFODSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GbxZoneMapFODSaveGameData::new)
    }
}

impl ::protobuf::Clear for GbxZoneMapFODSaveGameData {
    fn clear(&mut self) {
        self.level_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GbxZoneMapFODSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GbxZoneMapFODSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OakProfileCloudData {
    // message fields
    pub profile_stats_data: ::protobuf::RepeatedField<super::oak_shared::GameStatSaveGameData>,
    pub bank_inventory_list: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub lost_loot_inventory_list: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub npc_mail_items: ::protobuf::RepeatedField<super::oak_shared::OakMailItem>,
    pub profile_sdu_list: ::protobuf::RepeatedField<super::oak_shared::OakSDUSaveGameData>,
    pub unlocked_customizations: ::protobuf::RepeatedField<super::oak_shared::OakCustomizationSaveGameData>,
    pub unlocked_inventory_customization_parts: ::protobuf::RepeatedField<super::oak_shared::OakInventoryCustomizationPartInfo>,
    pub guardian_experience: i64,
    pub unlocked_crew_quarters_decorations: ::protobuf::RepeatedField<super::oak_shared::CrewQuartersDecorationItemSaveGameData>,
    pub unlocked_crew_quarters_rooms: ::protobuf::RepeatedField<super::oak_shared::CrewQuartersRoomItemSaveGameData>,
    pub challenge_data: ::protobuf::RepeatedField<super::oak_shared::ChallengeSaveGameData>,
    pub mail_guids: ::protobuf::RepeatedField<::std::string::String>,
    pub CitizenScienceLevelProgression: ::std::vec::Vec<i32>,
    pub CitizenScienceCSBucksAmount: i32,
    pub vault_card: ::protobuf::SingularPtrField<super::oak_shared::VaultCardSaveGameData>,
    pub bCitizenScienceHasSeenIntroVideo: bool,
    pub bCitizenScienceTutorialDone: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OakProfileCloudData {
    fn default() -> &'a OakProfileCloudData {
        <OakProfileCloudData as ::protobuf::Message>::default_instance()
    }
}

impl OakProfileCloudData {
    pub fn new() -> OakProfileCloudData {
        ::std::default::Default::default()
    }

    // repeated .OakSave.GameStatSaveGameData profile_stats_data = 1;


    pub fn get_profile_stats_data(&self) -> &[super::oak_shared::GameStatSaveGameData] {
        &self.profile_stats_data
    }
    pub fn clear_profile_stats_data(&mut self) {
        self.profile_stats_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_profile_stats_data(&mut self, v: ::protobuf::RepeatedField<super::oak_shared::GameStatSaveGameData>) {
        self.profile_stats_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_profile_stats_data(&mut self) -> &mut ::protobuf::RepeatedField<super::oak_shared::GameStatSaveGameData> {
        &mut self.profile_stats_data
    }

    // Take field
    pub fn take_profile_stats_data(&mut self) -> ::protobuf::RepeatedField<super::oak_shared::GameStatSaveGameData> {
        ::std::mem::replace(&mut self.profile_stats_data, ::protobuf::RepeatedField::new())
    }

    // repeated bytes bank_inventory_list = 2;


    pub fn get_bank_inventory_list(&self) -> &[::std::vec::Vec<u8>] {
        &self.bank_inventory_list
    }
    pub fn clear_bank_inventory_list(&mut self) {
        self.bank_inventory_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_bank_inventory_list(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.bank_inventory_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bank_inventory_list(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.bank_inventory_list
    }

    // Take field
    pub fn take_bank_inventory_list(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.bank_inventory_list, ::protobuf::RepeatedField::new())
    }

    // repeated bytes lost_loot_inventory_list = 3;


    pub fn get_lost_loot_inventory_list(&self) -> &[::std::vec::Vec<u8>] {
        &self.lost_loot_inventory_list
    }
    pub fn clear_lost_loot_inventory_list(&mut self) {
        self.lost_loot_inventory_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_lost_loot_inventory_list(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.lost_loot_inventory_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_lost_loot_inventory_list(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.lost_loot_inventory_list
    }

    // Take field
    pub fn take_lost_loot_inventory_list(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.lost_loot_inventory_list, ::protobuf::RepeatedField::new())
    }

    // repeated .OakSave.OakMailItem npc_mail_items = 4;


    pub fn get_npc_mail_items(&self) -> &[super::oak_shared::OakMailItem] {
        &self.npc_mail_items
    }
    pub fn clear_npc_mail_items(&mut self) {
        self.npc_mail_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_npc_mail_items(&mut self, v: ::protobuf::RepeatedField<super::oak_shared::OakMailItem>) {
        self.npc_mail_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_npc_mail_items(&mut self) -> &mut ::protobuf::RepeatedField<super::oak_shared::OakMailItem> {
        &mut self.npc_mail_items
    }

    // Take field
    pub fn take_npc_mail_items(&mut self) -> ::protobuf::RepeatedField<super::oak_shared::OakMailItem> {
        ::std::mem::replace(&mut self.npc_mail_items, ::protobuf::RepeatedField::new())
    }

    // repeated .OakSave.OakSDUSaveGameData profile_sdu_list = 5;


    pub fn get_profile_sdu_list(&self) -> &[super::oak_shared::OakSDUSaveGameData] {
        &self.profile_sdu_list
    }
    pub fn clear_profile_sdu_list(&mut self) {
        self.profile_sdu_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_profile_sdu_list(&mut self, v: ::protobuf::RepeatedField<super::oak_shared::OakSDUSaveGameData>) {
        self.profile_sdu_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_profile_sdu_list(&mut self) -> &mut ::protobuf::RepeatedField<super::oak_shared::OakSDUSaveGameData> {
        &mut self.profile_sdu_list
    }

    // Take field
    pub fn take_profile_sdu_list(&mut self) -> ::protobuf::RepeatedField<super::oak_shared::OakSDUSaveGameData> {
        ::std::mem::replace(&mut self.profile_sdu_list, ::protobuf::RepeatedField::new())
    }

    // repeated .OakSave.OakCustomizationSaveGameData unlocked_customizations = 6;


    pub fn get_unlocked_customizations(&self) -> &[super::oak_shared::OakCustomizationSaveGameData] {
        &self.unlocked_customizations
    }
    pub fn clear_unlocked_customizations(&mut self) {
        self.unlocked_customizations.clear();
    }

    // Param is passed by value, moved
    pub fn set_unlocked_customizations(&mut self, v: ::protobuf::RepeatedField<super::oak_shared::OakCustomizationSaveGameData>) {
        self.unlocked_customizations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unlocked_customizations(&mut self) -> &mut ::protobuf::RepeatedField<super::oak_shared::OakCustomizationSaveGameData> {
        &mut self.unlocked_customizations
    }

    // Take field
    pub fn take_unlocked_customizations(&mut self) -> ::protobuf::RepeatedField<super::oak_shared::OakCustomizationSaveGameData> {
        ::std::mem::replace(&mut self.unlocked_customizations, ::protobuf::RepeatedField::new())
    }

    // repeated .OakSave.OakInventoryCustomizationPartInfo unlocked_inventory_customization_parts = 7;


    pub fn get_unlocked_inventory_customization_parts(&self) -> &[super::oak_shared::OakInventoryCustomizationPartInfo] {
        &self.unlocked_inventory_customization_parts
    }
    pub fn clear_unlocked_inventory_customization_parts(&mut self) {
        self.unlocked_inventory_customization_parts.clear();
    }

    // Param is passed by value, moved
    pub fn set_unlocked_inventory_customization_parts(&mut self, v: ::protobuf::RepeatedField<super::oak_shared::OakInventoryCustomizationPartInfo>) {
        self.unlocked_inventory_customization_parts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unlocked_inventory_customization_parts(&mut self) -> &mut ::protobuf::RepeatedField<super::oak_shared::OakInventoryCustomizationPartInfo> {
        &mut self.unlocked_inventory_customization_parts
    }

    // Take field
    pub fn take_unlocked_inventory_customization_parts(&mut self) -> ::protobuf::RepeatedField<super::oak_shared::OakInventoryCustomizationPartInfo> {
        ::std::mem::replace(&mut self.unlocked_inventory_customization_parts, ::protobuf::RepeatedField::new())
    }

    // int64 guardian_experience = 8;


    pub fn get_guardian_experience(&self) -> i64 {
        self.guardian_experience
    }
    pub fn clear_guardian_experience(&mut self) {
        self.guardian_experience = 0;
    }

    // Param is passed by value, moved
    pub fn set_guardian_experience(&mut self, v: i64) {
        self.guardian_experience = v;
    }

    // repeated .OakSave.CrewQuartersDecorationItemSaveGameData unlocked_crew_quarters_decorations = 9;


    pub fn get_unlocked_crew_quarters_decorations(&self) -> &[super::oak_shared::CrewQuartersDecorationItemSaveGameData] {
        &self.unlocked_crew_quarters_decorations
    }
    pub fn clear_unlocked_crew_quarters_decorations(&mut self) {
        self.unlocked_crew_quarters_decorations.clear();
    }

    // Param is passed by value, moved
    pub fn set_unlocked_crew_quarters_decorations(&mut self, v: ::protobuf::RepeatedField<super::oak_shared::CrewQuartersDecorationItemSaveGameData>) {
        self.unlocked_crew_quarters_decorations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unlocked_crew_quarters_decorations(&mut self) -> &mut ::protobuf::RepeatedField<super::oak_shared::CrewQuartersDecorationItemSaveGameData> {
        &mut self.unlocked_crew_quarters_decorations
    }

    // Take field
    pub fn take_unlocked_crew_quarters_decorations(&mut self) -> ::protobuf::RepeatedField<super::oak_shared::CrewQuartersDecorationItemSaveGameData> {
        ::std::mem::replace(&mut self.unlocked_crew_quarters_decorations, ::protobuf::RepeatedField::new())
    }

    // repeated .OakSave.CrewQuartersRoomItemSaveGameData unlocked_crew_quarters_rooms = 10;


    pub fn get_unlocked_crew_quarters_rooms(&self) -> &[super::oak_shared::CrewQuartersRoomItemSaveGameData] {
        &self.unlocked_crew_quarters_rooms
    }
    pub fn clear_unlocked_crew_quarters_rooms(&mut self) {
        self.unlocked_crew_quarters_rooms.clear();
    }

    // Param is passed by value, moved
    pub fn set_unlocked_crew_quarters_rooms(&mut self, v: ::protobuf::RepeatedField<super::oak_shared::CrewQuartersRoomItemSaveGameData>) {
        self.unlocked_crew_quarters_rooms = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unlocked_crew_quarters_rooms(&mut self) -> &mut ::protobuf::RepeatedField<super::oak_shared::CrewQuartersRoomItemSaveGameData> {
        &mut self.unlocked_crew_quarters_rooms
    }

    // Take field
    pub fn take_unlocked_crew_quarters_rooms(&mut self) -> ::protobuf::RepeatedField<super::oak_shared::CrewQuartersRoomItemSaveGameData> {
        ::std::mem::replace(&mut self.unlocked_crew_quarters_rooms, ::protobuf::RepeatedField::new())
    }

    // repeated .OakSave.ChallengeSaveGameData challenge_data = 11;


    pub fn get_challenge_data(&self) -> &[super::oak_shared::ChallengeSaveGameData] {
        &self.challenge_data
    }
    pub fn clear_challenge_data(&mut self) {
        self.challenge_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_challenge_data(&mut self, v: ::protobuf::RepeatedField<super::oak_shared::ChallengeSaveGameData>) {
        self.challenge_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_challenge_data(&mut self) -> &mut ::protobuf::RepeatedField<super::oak_shared::ChallengeSaveGameData> {
        &mut self.challenge_data
    }

    // Take field
    pub fn take_challenge_data(&mut self) -> ::protobuf::RepeatedField<super::oak_shared::ChallengeSaveGameData> {
        ::std::mem::replace(&mut self.challenge_data, ::protobuf::RepeatedField::new())
    }

    // repeated string mail_guids = 12;


    pub fn get_mail_guids(&self) -> &[::std::string::String] {
        &self.mail_guids
    }
    pub fn clear_mail_guids(&mut self) {
        self.mail_guids.clear();
    }

    // Param is passed by value, moved
    pub fn set_mail_guids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.mail_guids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mail_guids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.mail_guids
    }

    // Take field
    pub fn take_mail_guids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.mail_guids, ::protobuf::RepeatedField::new())
    }

    // repeated int32 CitizenScienceLevelProgression = 13;


    pub fn get_CitizenScienceLevelProgression(&self) -> &[i32] {
        &self.CitizenScienceLevelProgression
    }
    pub fn clear_CitizenScienceLevelProgression(&mut self) {
        self.CitizenScienceLevelProgression.clear();
    }

    // Param is passed by value, moved
    pub fn set_CitizenScienceLevelProgression(&mut self, v: ::std::vec::Vec<i32>) {
        self.CitizenScienceLevelProgression = v;
    }

    // Mutable pointer to the field.
    pub fn mut_CitizenScienceLevelProgression(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.CitizenScienceLevelProgression
    }

    // Take field
    pub fn take_CitizenScienceLevelProgression(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.CitizenScienceLevelProgression, ::std::vec::Vec::new())
    }

    // int32 CitizenScienceCSBucksAmount = 14;


    pub fn get_CitizenScienceCSBucksAmount(&self) -> i32 {
        self.CitizenScienceCSBucksAmount
    }
    pub fn clear_CitizenScienceCSBucksAmount(&mut self) {
        self.CitizenScienceCSBucksAmount = 0;
    }

    // Param is passed by value, moved
    pub fn set_CitizenScienceCSBucksAmount(&mut self, v: i32) {
        self.CitizenScienceCSBucksAmount = v;
    }

    // .OakSave.VaultCardSaveGameData vault_card = 15;


    pub fn get_vault_card(&self) -> &super::oak_shared::VaultCardSaveGameData {
        self.vault_card.as_ref().unwrap_or_else(|| <super::oak_shared::VaultCardSaveGameData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_vault_card(&mut self) {
        self.vault_card.clear();
    }

    pub fn has_vault_card(&self) -> bool {
        self.vault_card.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vault_card(&mut self, v: super::oak_shared::VaultCardSaveGameData) {
        self.vault_card = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vault_card(&mut self) -> &mut super::oak_shared::VaultCardSaveGameData {
        if self.vault_card.is_none() {
            self.vault_card.set_default();
        }
        self.vault_card.as_mut().unwrap()
    }

    // Take field
    pub fn take_vault_card(&mut self) -> super::oak_shared::VaultCardSaveGameData {
        self.vault_card.take().unwrap_or_else(|| super::oak_shared::VaultCardSaveGameData::new())
    }

    // bool bCitizenScienceHasSeenIntroVideo = 25;


    pub fn get_bCitizenScienceHasSeenIntroVideo(&self) -> bool {
        self.bCitizenScienceHasSeenIntroVideo
    }
    pub fn clear_bCitizenScienceHasSeenIntroVideo(&mut self) {
        self.bCitizenScienceHasSeenIntroVideo = false;
    }

    // Param is passed by value, moved
    pub fn set_bCitizenScienceHasSeenIntroVideo(&mut self, v: bool) {
        self.bCitizenScienceHasSeenIntroVideo = v;
    }

    // bool bCitizenScienceTutorialDone = 26;


    pub fn get_bCitizenScienceTutorialDone(&self) -> bool {
        self.bCitizenScienceTutorialDone
    }
    pub fn clear_bCitizenScienceTutorialDone(&mut self) {
        self.bCitizenScienceTutorialDone = false;
    }

    // Param is passed by value, moved
    pub fn set_bCitizenScienceTutorialDone(&mut self, v: bool) {
        self.bCitizenScienceTutorialDone = v;
    }
}

impl ::protobuf::Message for OakProfileCloudData {
    fn is_initialized(&self) -> bool {
        for v in &self.profile_stats_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.npc_mail_items {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.profile_sdu_list {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unlocked_customizations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unlocked_inventory_customization_parts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unlocked_crew_quarters_decorations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unlocked_crew_quarters_rooms {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.challenge_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vault_card {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.profile_stats_data)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.bank_inventory_list)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.lost_loot_inventory_list)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.npc_mail_items)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.profile_sdu_list)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.unlocked_customizations)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.unlocked_inventory_customization_parts)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.guardian_experience = tmp;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.unlocked_crew_quarters_decorations)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.unlocked_crew_quarters_rooms)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.challenge_data)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.mail_guids)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.CitizenScienceLevelProgression)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.CitizenScienceCSBucksAmount = tmp;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.vault_card)?;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bCitizenScienceHasSeenIntroVideo = tmp;
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bCitizenScienceTutorialDone = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.profile_stats_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.bank_inventory_list {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        for value in &self.lost_loot_inventory_list {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        for value in &self.npc_mail_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.profile_sdu_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.unlocked_customizations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.unlocked_inventory_customization_parts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.guardian_experience != 0 {
            my_size += ::protobuf::rt::value_size(8, self.guardian_experience, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.unlocked_crew_quarters_decorations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.unlocked_crew_quarters_rooms {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.challenge_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.mail_guids {
            my_size += ::protobuf::rt::string_size(12, &value);
        };
        for value in &self.CitizenScienceLevelProgression {
            my_size += ::protobuf::rt::value_size(13, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.CitizenScienceCSBucksAmount != 0 {
            my_size += ::protobuf::rt::value_size(14, self.CitizenScienceCSBucksAmount, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.vault_card.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.bCitizenScienceHasSeenIntroVideo != false {
            my_size += 3;
        }
        if self.bCitizenScienceTutorialDone != false {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.profile_stats_data {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.bank_inventory_list {
            os.write_bytes(2, &v)?;
        };
        for v in &self.lost_loot_inventory_list {
            os.write_bytes(3, &v)?;
        };
        for v in &self.npc_mail_items {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.profile_sdu_list {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.unlocked_customizations {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.unlocked_inventory_customization_parts {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.guardian_experience != 0 {
            os.write_int64(8, self.guardian_experience)?;
        }
        for v in &self.unlocked_crew_quarters_decorations {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.unlocked_crew_quarters_rooms {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.challenge_data {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.mail_guids {
            os.write_string(12, &v)?;
        };
        for v in &self.CitizenScienceLevelProgression {
            os.write_int32(13, *v)?;
        };
        if self.CitizenScienceCSBucksAmount != 0 {
            os.write_int32(14, self.CitizenScienceCSBucksAmount)?;
        }
        if let Some(ref v) = self.vault_card.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.bCitizenScienceHasSeenIntroVideo != false {
            os.write_bool(25, self.bCitizenScienceHasSeenIntroVideo)?;
        }
        if self.bCitizenScienceTutorialDone != false {
            os.write_bool(26, self.bCitizenScienceTutorialDone)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OakProfileCloudData {
        OakProfileCloudData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::oak_shared::GameStatSaveGameData>>(
                "profile_stats_data",
                |m: &OakProfileCloudData| { &m.profile_stats_data },
                |m: &mut OakProfileCloudData| { &mut m.profile_stats_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "bank_inventory_list",
                |m: &OakProfileCloudData| { &m.bank_inventory_list },
                |m: &mut OakProfileCloudData| { &mut m.bank_inventory_list },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "lost_loot_inventory_list",
                |m: &OakProfileCloudData| { &m.lost_loot_inventory_list },
                |m: &mut OakProfileCloudData| { &mut m.lost_loot_inventory_list },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::oak_shared::OakMailItem>>(
                "npc_mail_items",
                |m: &OakProfileCloudData| { &m.npc_mail_items },
                |m: &mut OakProfileCloudData| { &mut m.npc_mail_items },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::oak_shared::OakSDUSaveGameData>>(
                "profile_sdu_list",
                |m: &OakProfileCloudData| { &m.profile_sdu_list },
                |m: &mut OakProfileCloudData| { &mut m.profile_sdu_list },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::oak_shared::OakCustomizationSaveGameData>>(
                "unlocked_customizations",
                |m: &OakProfileCloudData| { &m.unlocked_customizations },
                |m: &mut OakProfileCloudData| { &mut m.unlocked_customizations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::oak_shared::OakInventoryCustomizationPartInfo>>(
                "unlocked_inventory_customization_parts",
                |m: &OakProfileCloudData| { &m.unlocked_inventory_customization_parts },
                |m: &mut OakProfileCloudData| { &mut m.unlocked_inventory_customization_parts },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "guardian_experience",
                |m: &OakProfileCloudData| { &m.guardian_experience },
                |m: &mut OakProfileCloudData| { &mut m.guardian_experience },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::oak_shared::CrewQuartersDecorationItemSaveGameData>>(
                "unlocked_crew_quarters_decorations",
                |m: &OakProfileCloudData| { &m.unlocked_crew_quarters_decorations },
                |m: &mut OakProfileCloudData| { &mut m.unlocked_crew_quarters_decorations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::oak_shared::CrewQuartersRoomItemSaveGameData>>(
                "unlocked_crew_quarters_rooms",
                |m: &OakProfileCloudData| { &m.unlocked_crew_quarters_rooms },
                |m: &mut OakProfileCloudData| { &mut m.unlocked_crew_quarters_rooms },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::oak_shared::ChallengeSaveGameData>>(
                "challenge_data",
                |m: &OakProfileCloudData| { &m.challenge_data },
                |m: &mut OakProfileCloudData| { &mut m.challenge_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mail_guids",
                |m: &OakProfileCloudData| { &m.mail_guids },
                |m: &mut OakProfileCloudData| { &mut m.mail_guids },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "CitizenScienceLevelProgression",
                |m: &OakProfileCloudData| { &m.CitizenScienceLevelProgression },
                |m: &mut OakProfileCloudData| { &mut m.CitizenScienceLevelProgression },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "CitizenScienceCSBucksAmount",
                |m: &OakProfileCloudData| { &m.CitizenScienceCSBucksAmount },
                |m: &mut OakProfileCloudData| { &mut m.CitizenScienceCSBucksAmount },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::oak_shared::VaultCardSaveGameData>>(
                "vault_card",
                |m: &OakProfileCloudData| { &m.vault_card },
                |m: &mut OakProfileCloudData| { &mut m.vault_card },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "bCitizenScienceHasSeenIntroVideo",
                |m: &OakProfileCloudData| { &m.bCitizenScienceHasSeenIntroVideo },
                |m: &mut OakProfileCloudData| { &mut m.bCitizenScienceHasSeenIntroVideo },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "bCitizenScienceTutorialDone",
                |m: &OakProfileCloudData| { &m.bCitizenScienceTutorialDone },
                |m: &mut OakProfileCloudData| { &mut m.bCitizenScienceTutorialDone },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OakProfileCloudData>(
                "OakProfileCloudData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OakProfileCloudData {
        static instance: ::protobuf::rt::LazyV2<OakProfileCloudData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OakProfileCloudData::new)
    }
}

impl ::protobuf::Clear for OakProfileCloudData {
    fn clear(&mut self) {
        self.profile_stats_data.clear();
        self.bank_inventory_list.clear();
        self.lost_loot_inventory_list.clear();
        self.npc_mail_items.clear();
        self.profile_sdu_list.clear();
        self.unlocked_customizations.clear();
        self.unlocked_inventory_customization_parts.clear();
        self.guardian_experience = 0;
        self.unlocked_crew_quarters_decorations.clear();
        self.unlocked_crew_quarters_rooms.clear();
        self.challenge_data.clear();
        self.mail_guids.clear();
        self.CitizenScienceLevelProgression.clear();
        self.CitizenScienceCSBucksAmount = 0;
        self.vault_card.clear();
        self.bCitizenScienceHasSeenIntroVideo = false;
        self.bCitizenScienceTutorialDone = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OakProfileCloudData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OakProfileCloudData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Character {
    // message fields
    pub save_game_id: u32,
    pub last_save_timestamp: i64,
    pub time_played_seconds: u32,
    pub player_class_data: ::protobuf::SingularPtrField<PlayerClassSaveGameData>,
    pub resource_pools: ::protobuf::RepeatedField<ResourcePoolSavegameData>,
    pub saved_regions: ::protobuf::RepeatedField<RegionSaveGameData>,
    pub experience_points: i32,
    pub game_stats_data: ::protobuf::RepeatedField<super::oak_shared::GameStatSaveGameData>,
    pub inventory_category_list: ::protobuf::RepeatedField<super::oak_shared::InventoryCategorySaveData>,
    pub inventory_items: ::protobuf::RepeatedField<OakInventoryItemSaveGameData>,
    pub equipped_inventory_list: ::protobuf::RepeatedField<EquippedInventorySaveGameData>,
    pub active_weapon_list: ::std::vec::Vec<i32>,
    pub ability_data: ::protobuf::SingularPtrField<OakPlayerAbilitySaveGameData>,
    pub last_play_through_index: i32,
    pub playthroughs_completed: i32,
    pub show_new_playthrough_notification: bool,
    pub mission_playthroughs_data: ::protobuf::RepeatedField<MissionPlaythroughSaveGameData>,
    pub active_travel_stations: ::protobuf::RepeatedField<::std::string::String>,
    pub discovery_data: ::protobuf::SingularPtrField<DiscoverySaveData>,
    pub last_active_travel_station: ::std::string::String,
    pub vehicles_unlocked_data: ::protobuf::RepeatedField<VehicleUnlockedSaveGameData>,
    pub vehicle_parts_unlocked: ::protobuf::RepeatedField<::std::string::String>,
    pub vehicle_loadouts: ::protobuf::RepeatedField<OakCARMenuVehicleConfigSaveData>,
    pub vehicle_last_loadout_index: i32,
    pub challenge_data: ::protobuf::RepeatedField<super::oak_shared::ChallengeSaveGameData>,
    pub sdu_list: ::protobuf::RepeatedField<super::oak_shared::OakSDUSaveGameData>,
    pub selected_customizations: ::protobuf::RepeatedField<::std::string::String>,
    pub equipped_emote_customizations: ::std::vec::Vec<i32>,
    pub selected_color_customizations: ::protobuf::RepeatedField<CustomPlayerColorSaveGameData>,
    pub guardian_rank: ::protobuf::SingularPtrField<GuardianRankSaveGameData>,
    pub crew_quarters_room: ::protobuf::SingularPtrField<CrewQuartersSaveData>,
    pub crew_quarters_gun_rack: ::protobuf::SingularPtrField<CrewQuartersGunRackSaveData>,
    pub unlocked_echo_logs: ::protobuf::RepeatedField<EchoLogSaveGameData>,
    pub has_played_special_echo_log_insert_already: bool,
    pub nickname_mappings: ::protobuf::RepeatedField<Character_NicknameMappingsEntry>,
    pub last_traveled_map_id: ::protobuf::SingularPtrField<MapIDData>,
    pub challenge_category_completion_pcts: ::protobuf::SingularPtrField<ChallengeCategoryProgressSaveData>,
    pub character_slot_save_game_data: ::protobuf::SingularPtrField<OakPlayerCharacterSlotSaveGameData>,
    pub ui_tracking_save_game_data: ::protobuf::SingularPtrField<UITrackingSaveGameData>,
    pub preferred_character_name: ::std::string::String,
    pub name_character_limit: i32,
    pub preferred_group_mode: u32,
    pub time_of_day_save_game_data: ::protobuf::SingularPtrField<TimeOfDaySaveGameData>,
    pub level_persistence_data: ::protobuf::RepeatedField<LevelPersistence_Level_SaveGameData>,
    pub accumulated_level_persistence_reset_timer_seconds: u32,
    pub mayhem_level: u32,
    pub gbx_zone_map_fod_save_game_data: ::protobuf::SingularPtrField<GbxZoneMapFODSaveGameData>,
    pub active_or_blacklisted_travel_stations: ::protobuf::RepeatedField<ActiveFastTravelSaveData>,
    pub last_active_travel_station_for_playthrough: ::protobuf::RepeatedField<::std::string::String>,
    pub game_state_save_data_for_playthrough: ::protobuf::RepeatedField<GameStateSaveData>,
    pub registered_downloadable_entitlements: ::protobuf::RepeatedField<super::oak_shared::RegisteredDownloadableEntitlements>,
    pub active_travel_stations_for_playthrough: ::protobuf::RepeatedField<PlaythroughActiveFastTravelSaveData>,
    pub save_game_guid: ::std::string::String,
    pub guardian_rank_character_data: ::protobuf::SingularPtrField<GuardianRankCharacterSaveGameData>,
    pub optional_objective_reward_fixup_applied: bool,
    pub vehicle_part_rewards_fixup_applied: bool,
    pub last_active_league: u32,
    pub last_active_league_instance: u32,
    pub active_league_instance_for_event: ::protobuf::RepeatedField<Character_ActiveLeagueInstanceForEventEntry>,
    pub levelled_save_vehicle_part_rewards_fixup_applied: bool,
    pub profile_cloud_data: ::protobuf::SingularPtrField<OakProfileCloudData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Character {
    fn default() -> &'a Character {
        <Character as ::protobuf::Message>::default_instance()
    }
}

impl Character {
    pub fn new() -> Character {
        ::std::default::Default::default()
    }

    // uint32 save_game_id = 1;


    pub fn get_save_game_id(&self) -> u32 {
        self.save_game_id
    }
    pub fn clear_save_game_id(&mut self) {
        self.save_game_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_save_game_id(&mut self, v: u32) {
        self.save_game_id = v;
    }

    // int64 last_save_timestamp = 2;


    pub fn get_last_save_timestamp(&self) -> i64 {
        self.last_save_timestamp
    }
    pub fn clear_last_save_timestamp(&mut self) {
        self.last_save_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_save_timestamp(&mut self, v: i64) {
        self.last_save_timestamp = v;
    }

    // uint32 time_played_seconds = 3;


    pub fn get_time_played_seconds(&self) -> u32 {
        self.time_played_seconds
    }
    pub fn clear_time_played_seconds(&mut self) {
        self.time_played_seconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_time_played_seconds(&mut self, v: u32) {
        self.time_played_seconds = v;
    }

    // .OakSave.PlayerClassSaveGameData player_class_data = 4;


    pub fn get_player_class_data(&self) -> &PlayerClassSaveGameData {
        self.player_class_data.as_ref().unwrap_or_else(|| <PlayerClassSaveGameData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_player_class_data(&mut self) {
        self.player_class_data.clear();
    }

    pub fn has_player_class_data(&self) -> bool {
        self.player_class_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_class_data(&mut self, v: PlayerClassSaveGameData) {
        self.player_class_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_class_data(&mut self) -> &mut PlayerClassSaveGameData {
        if self.player_class_data.is_none() {
            self.player_class_data.set_default();
        }
        self.player_class_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_class_data(&mut self) -> PlayerClassSaveGameData {
        self.player_class_data.take().unwrap_or_else(|| PlayerClassSaveGameData::new())
    }

    // repeated .OakSave.ResourcePoolSavegameData resource_pools = 5;


    pub fn get_resource_pools(&self) -> &[ResourcePoolSavegameData] {
        &self.resource_pools
    }
    pub fn clear_resource_pools(&mut self) {
        self.resource_pools.clear();
    }

    // Param is passed by value, moved
    pub fn set_resource_pools(&mut self, v: ::protobuf::RepeatedField<ResourcePoolSavegameData>) {
        self.resource_pools = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resource_pools(&mut self) -> &mut ::protobuf::RepeatedField<ResourcePoolSavegameData> {
        &mut self.resource_pools
    }

    // Take field
    pub fn take_resource_pools(&mut self) -> ::protobuf::RepeatedField<ResourcePoolSavegameData> {
        ::std::mem::replace(&mut self.resource_pools, ::protobuf::RepeatedField::new())
    }

    // repeated .OakSave.RegionSaveGameData saved_regions = 6;


    pub fn get_saved_regions(&self) -> &[RegionSaveGameData] {
        &self.saved_regions
    }
    pub fn clear_saved_regions(&mut self) {
        self.saved_regions.clear();
    }

    // Param is passed by value, moved
    pub fn set_saved_regions(&mut self, v: ::protobuf::RepeatedField<RegionSaveGameData>) {
        self.saved_regions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_saved_regions(&mut self) -> &mut ::protobuf::RepeatedField<RegionSaveGameData> {
        &mut self.saved_regions
    }

    // Take field
    pub fn take_saved_regions(&mut self) -> ::protobuf::RepeatedField<RegionSaveGameData> {
        ::std::mem::replace(&mut self.saved_regions, ::protobuf::RepeatedField::new())
    }

    // int32 experience_points = 7;


    pub fn get_experience_points(&self) -> i32 {
        self.experience_points
    }
    pub fn clear_experience_points(&mut self) {
        self.experience_points = 0;
    }

    // Param is passed by value, moved
    pub fn set_experience_points(&mut self, v: i32) {
        self.experience_points = v;
    }

    // repeated .OakSave.GameStatSaveGameData game_stats_data = 8;


    pub fn get_game_stats_data(&self) -> &[super::oak_shared::GameStatSaveGameData] {
        &self.game_stats_data
    }
    pub fn clear_game_stats_data(&mut self) {
        self.game_stats_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_game_stats_data(&mut self, v: ::protobuf::RepeatedField<super::oak_shared::GameStatSaveGameData>) {
        self.game_stats_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_game_stats_data(&mut self) -> &mut ::protobuf::RepeatedField<super::oak_shared::GameStatSaveGameData> {
        &mut self.game_stats_data
    }

    // Take field
    pub fn take_game_stats_data(&mut self) -> ::protobuf::RepeatedField<super::oak_shared::GameStatSaveGameData> {
        ::std::mem::replace(&mut self.game_stats_data, ::protobuf::RepeatedField::new())
    }

    // repeated .OakSave.InventoryCategorySaveData inventory_category_list = 9;


    pub fn get_inventory_category_list(&self) -> &[super::oak_shared::InventoryCategorySaveData] {
        &self.inventory_category_list
    }
    pub fn clear_inventory_category_list(&mut self) {
        self.inventory_category_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_inventory_category_list(&mut self, v: ::protobuf::RepeatedField<super::oak_shared::InventoryCategorySaveData>) {
        self.inventory_category_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inventory_category_list(&mut self) -> &mut ::protobuf::RepeatedField<super::oak_shared::InventoryCategorySaveData> {
        &mut self.inventory_category_list
    }

    // Take field
    pub fn take_inventory_category_list(&mut self) -> ::protobuf::RepeatedField<super::oak_shared::InventoryCategorySaveData> {
        ::std::mem::replace(&mut self.inventory_category_list, ::protobuf::RepeatedField::new())
    }

    // repeated .OakSave.OakInventoryItemSaveGameData inventory_items = 10;


    pub fn get_inventory_items(&self) -> &[OakInventoryItemSaveGameData] {
        &self.inventory_items
    }
    pub fn clear_inventory_items(&mut self) {
        self.inventory_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_inventory_items(&mut self, v: ::protobuf::RepeatedField<OakInventoryItemSaveGameData>) {
        self.inventory_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inventory_items(&mut self) -> &mut ::protobuf::RepeatedField<OakInventoryItemSaveGameData> {
        &mut self.inventory_items
    }

    // Take field
    pub fn take_inventory_items(&mut self) -> ::protobuf::RepeatedField<OakInventoryItemSaveGameData> {
        ::std::mem::replace(&mut self.inventory_items, ::protobuf::RepeatedField::new())
    }

    // repeated .OakSave.EquippedInventorySaveGameData equipped_inventory_list = 11;


    pub fn get_equipped_inventory_list(&self) -> &[EquippedInventorySaveGameData] {
        &self.equipped_inventory_list
    }
    pub fn clear_equipped_inventory_list(&mut self) {
        self.equipped_inventory_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_equipped_inventory_list(&mut self, v: ::protobuf::RepeatedField<EquippedInventorySaveGameData>) {
        self.equipped_inventory_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_equipped_inventory_list(&mut self) -> &mut ::protobuf::RepeatedField<EquippedInventorySaveGameData> {
        &mut self.equipped_inventory_list
    }

    // Take field
    pub fn take_equipped_inventory_list(&mut self) -> ::protobuf::RepeatedField<EquippedInventorySaveGameData> {
        ::std::mem::replace(&mut self.equipped_inventory_list, ::protobuf::RepeatedField::new())
    }

    // repeated int32 active_weapon_list = 12;


    pub fn get_active_weapon_list(&self) -> &[i32] {
        &self.active_weapon_list
    }
    pub fn clear_active_weapon_list(&mut self) {
        self.active_weapon_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_active_weapon_list(&mut self, v: ::std::vec::Vec<i32>) {
        self.active_weapon_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_active_weapon_list(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.active_weapon_list
    }

    // Take field
    pub fn take_active_weapon_list(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.active_weapon_list, ::std::vec::Vec::new())
    }

    // .OakSave.OakPlayerAbilitySaveGameData ability_data = 13;


    pub fn get_ability_data(&self) -> &OakPlayerAbilitySaveGameData {
        self.ability_data.as_ref().unwrap_or_else(|| <OakPlayerAbilitySaveGameData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ability_data(&mut self) {
        self.ability_data.clear();
    }

    pub fn has_ability_data(&self) -> bool {
        self.ability_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_data(&mut self, v: OakPlayerAbilitySaveGameData) {
        self.ability_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ability_data(&mut self) -> &mut OakPlayerAbilitySaveGameData {
        if self.ability_data.is_none() {
            self.ability_data.set_default();
        }
        self.ability_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_ability_data(&mut self) -> OakPlayerAbilitySaveGameData {
        self.ability_data.take().unwrap_or_else(|| OakPlayerAbilitySaveGameData::new())
    }

    // int32 last_play_through_index = 14;


    pub fn get_last_play_through_index(&self) -> i32 {
        self.last_play_through_index
    }
    pub fn clear_last_play_through_index(&mut self) {
        self.last_play_through_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_play_through_index(&mut self, v: i32) {
        self.last_play_through_index = v;
    }

    // int32 playthroughs_completed = 15;


    pub fn get_playthroughs_completed(&self) -> i32 {
        self.playthroughs_completed
    }
    pub fn clear_playthroughs_completed(&mut self) {
        self.playthroughs_completed = 0;
    }

    // Param is passed by value, moved
    pub fn set_playthroughs_completed(&mut self, v: i32) {
        self.playthroughs_completed = v;
    }

    // bool show_new_playthrough_notification = 16;


    pub fn get_show_new_playthrough_notification(&self) -> bool {
        self.show_new_playthrough_notification
    }
    pub fn clear_show_new_playthrough_notification(&mut self) {
        self.show_new_playthrough_notification = false;
    }

    // Param is passed by value, moved
    pub fn set_show_new_playthrough_notification(&mut self, v: bool) {
        self.show_new_playthrough_notification = v;
    }

    // repeated .OakSave.MissionPlaythroughSaveGameData mission_playthroughs_data = 17;


    pub fn get_mission_playthroughs_data(&self) -> &[MissionPlaythroughSaveGameData] {
        &self.mission_playthroughs_data
    }
    pub fn clear_mission_playthroughs_data(&mut self) {
        self.mission_playthroughs_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_mission_playthroughs_data(&mut self, v: ::protobuf::RepeatedField<MissionPlaythroughSaveGameData>) {
        self.mission_playthroughs_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mission_playthroughs_data(&mut self) -> &mut ::protobuf::RepeatedField<MissionPlaythroughSaveGameData> {
        &mut self.mission_playthroughs_data
    }

    // Take field
    pub fn take_mission_playthroughs_data(&mut self) -> ::protobuf::RepeatedField<MissionPlaythroughSaveGameData> {
        ::std::mem::replace(&mut self.mission_playthroughs_data, ::protobuf::RepeatedField::new())
    }

    // repeated string active_travel_stations = 21;


    pub fn get_active_travel_stations(&self) -> &[::std::string::String] {
        &self.active_travel_stations
    }
    pub fn clear_active_travel_stations(&mut self) {
        self.active_travel_stations.clear();
    }

    // Param is passed by value, moved
    pub fn set_active_travel_stations(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.active_travel_stations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_active_travel_stations(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.active_travel_stations
    }

    // Take field
    pub fn take_active_travel_stations(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.active_travel_stations, ::protobuf::RepeatedField::new())
    }

    // .OakSave.DiscoverySaveData discovery_data = 22;


    pub fn get_discovery_data(&self) -> &DiscoverySaveData {
        self.discovery_data.as_ref().unwrap_or_else(|| <DiscoverySaveData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_discovery_data(&mut self) {
        self.discovery_data.clear();
    }

    pub fn has_discovery_data(&self) -> bool {
        self.discovery_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_discovery_data(&mut self, v: DiscoverySaveData) {
        self.discovery_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_discovery_data(&mut self) -> &mut DiscoverySaveData {
        if self.discovery_data.is_none() {
            self.discovery_data.set_default();
        }
        self.discovery_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_discovery_data(&mut self) -> DiscoverySaveData {
        self.discovery_data.take().unwrap_or_else(|| DiscoverySaveData::new())
    }

    // string last_active_travel_station = 23;


    pub fn get_last_active_travel_station(&self) -> &str {
        &self.last_active_travel_station
    }
    pub fn clear_last_active_travel_station(&mut self) {
        self.last_active_travel_station.clear();
    }

    // Param is passed by value, moved
    pub fn set_last_active_travel_station(&mut self, v: ::std::string::String) {
        self.last_active_travel_station = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_active_travel_station(&mut self) -> &mut ::std::string::String {
        &mut self.last_active_travel_station
    }

    // Take field
    pub fn take_last_active_travel_station(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.last_active_travel_station, ::std::string::String::new())
    }

    // repeated .OakSave.VehicleUnlockedSaveGameData vehicles_unlocked_data = 24;


    pub fn get_vehicles_unlocked_data(&self) -> &[VehicleUnlockedSaveGameData] {
        &self.vehicles_unlocked_data
    }
    pub fn clear_vehicles_unlocked_data(&mut self) {
        self.vehicles_unlocked_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_vehicles_unlocked_data(&mut self, v: ::protobuf::RepeatedField<VehicleUnlockedSaveGameData>) {
        self.vehicles_unlocked_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vehicles_unlocked_data(&mut self) -> &mut ::protobuf::RepeatedField<VehicleUnlockedSaveGameData> {
        &mut self.vehicles_unlocked_data
    }

    // Take field
    pub fn take_vehicles_unlocked_data(&mut self) -> ::protobuf::RepeatedField<VehicleUnlockedSaveGameData> {
        ::std::mem::replace(&mut self.vehicles_unlocked_data, ::protobuf::RepeatedField::new())
    }

    // repeated string vehicle_parts_unlocked = 25;


    pub fn get_vehicle_parts_unlocked(&self) -> &[::std::string::String] {
        &self.vehicle_parts_unlocked
    }
    pub fn clear_vehicle_parts_unlocked(&mut self) {
        self.vehicle_parts_unlocked.clear();
    }

    // Param is passed by value, moved
    pub fn set_vehicle_parts_unlocked(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.vehicle_parts_unlocked = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vehicle_parts_unlocked(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.vehicle_parts_unlocked
    }

    // Take field
    pub fn take_vehicle_parts_unlocked(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.vehicle_parts_unlocked, ::protobuf::RepeatedField::new())
    }

    // repeated .OakSave.OakCARMenuVehicleConfigSaveData vehicle_loadouts = 26;


    pub fn get_vehicle_loadouts(&self) -> &[OakCARMenuVehicleConfigSaveData] {
        &self.vehicle_loadouts
    }
    pub fn clear_vehicle_loadouts(&mut self) {
        self.vehicle_loadouts.clear();
    }

    // Param is passed by value, moved
    pub fn set_vehicle_loadouts(&mut self, v: ::protobuf::RepeatedField<OakCARMenuVehicleConfigSaveData>) {
        self.vehicle_loadouts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vehicle_loadouts(&mut self) -> &mut ::protobuf::RepeatedField<OakCARMenuVehicleConfigSaveData> {
        &mut self.vehicle_loadouts
    }

    // Take field
    pub fn take_vehicle_loadouts(&mut self) -> ::protobuf::RepeatedField<OakCARMenuVehicleConfigSaveData> {
        ::std::mem::replace(&mut self.vehicle_loadouts, ::protobuf::RepeatedField::new())
    }

    // int32 vehicle_last_loadout_index = 27;


    pub fn get_vehicle_last_loadout_index(&self) -> i32 {
        self.vehicle_last_loadout_index
    }
    pub fn clear_vehicle_last_loadout_index(&mut self) {
        self.vehicle_last_loadout_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_vehicle_last_loadout_index(&mut self, v: i32) {
        self.vehicle_last_loadout_index = v;
    }

    // repeated .OakSave.ChallengeSaveGameData challenge_data = 28;


    pub fn get_challenge_data(&self) -> &[super::oak_shared::ChallengeSaveGameData] {
        &self.challenge_data
    }
    pub fn clear_challenge_data(&mut self) {
        self.challenge_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_challenge_data(&mut self, v: ::protobuf::RepeatedField<super::oak_shared::ChallengeSaveGameData>) {
        self.challenge_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_challenge_data(&mut self) -> &mut ::protobuf::RepeatedField<super::oak_shared::ChallengeSaveGameData> {
        &mut self.challenge_data
    }

    // Take field
    pub fn take_challenge_data(&mut self) -> ::protobuf::RepeatedField<super::oak_shared::ChallengeSaveGameData> {
        ::std::mem::replace(&mut self.challenge_data, ::protobuf::RepeatedField::new())
    }

    // repeated .OakSave.OakSDUSaveGameData sdu_list = 29;


    pub fn get_sdu_list(&self) -> &[super::oak_shared::OakSDUSaveGameData] {
        &self.sdu_list
    }
    pub fn clear_sdu_list(&mut self) {
        self.sdu_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_sdu_list(&mut self, v: ::protobuf::RepeatedField<super::oak_shared::OakSDUSaveGameData>) {
        self.sdu_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sdu_list(&mut self) -> &mut ::protobuf::RepeatedField<super::oak_shared::OakSDUSaveGameData> {
        &mut self.sdu_list
    }

    // Take field
    pub fn take_sdu_list(&mut self) -> ::protobuf::RepeatedField<super::oak_shared::OakSDUSaveGameData> {
        ::std::mem::replace(&mut self.sdu_list, ::protobuf::RepeatedField::new())
    }

    // repeated string selected_customizations = 30;


    pub fn get_selected_customizations(&self) -> &[::std::string::String] {
        &self.selected_customizations
    }
    pub fn clear_selected_customizations(&mut self) {
        self.selected_customizations.clear();
    }

    // Param is passed by value, moved
    pub fn set_selected_customizations(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.selected_customizations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_selected_customizations(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.selected_customizations
    }

    // Take field
    pub fn take_selected_customizations(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.selected_customizations, ::protobuf::RepeatedField::new())
    }

    // repeated int32 equipped_emote_customizations = 31;


    pub fn get_equipped_emote_customizations(&self) -> &[i32] {
        &self.equipped_emote_customizations
    }
    pub fn clear_equipped_emote_customizations(&mut self) {
        self.equipped_emote_customizations.clear();
    }

    // Param is passed by value, moved
    pub fn set_equipped_emote_customizations(&mut self, v: ::std::vec::Vec<i32>) {
        self.equipped_emote_customizations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_equipped_emote_customizations(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.equipped_emote_customizations
    }

    // Take field
    pub fn take_equipped_emote_customizations(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.equipped_emote_customizations, ::std::vec::Vec::new())
    }

    // repeated .OakSave.CustomPlayerColorSaveGameData selected_color_customizations = 32;


    pub fn get_selected_color_customizations(&self) -> &[CustomPlayerColorSaveGameData] {
        &self.selected_color_customizations
    }
    pub fn clear_selected_color_customizations(&mut self) {
        self.selected_color_customizations.clear();
    }

    // Param is passed by value, moved
    pub fn set_selected_color_customizations(&mut self, v: ::protobuf::RepeatedField<CustomPlayerColorSaveGameData>) {
        self.selected_color_customizations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_selected_color_customizations(&mut self) -> &mut ::protobuf::RepeatedField<CustomPlayerColorSaveGameData> {
        &mut self.selected_color_customizations
    }

    // Take field
    pub fn take_selected_color_customizations(&mut self) -> ::protobuf::RepeatedField<CustomPlayerColorSaveGameData> {
        ::std::mem::replace(&mut self.selected_color_customizations, ::protobuf::RepeatedField::new())
    }

    // .OakSave.GuardianRankSaveGameData guardian_rank = 33;


    pub fn get_guardian_rank(&self) -> &GuardianRankSaveGameData {
        self.guardian_rank.as_ref().unwrap_or_else(|| <GuardianRankSaveGameData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_guardian_rank(&mut self) {
        self.guardian_rank.clear();
    }

    pub fn has_guardian_rank(&self) -> bool {
        self.guardian_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guardian_rank(&mut self, v: GuardianRankSaveGameData) {
        self.guardian_rank = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guardian_rank(&mut self) -> &mut GuardianRankSaveGameData {
        if self.guardian_rank.is_none() {
            self.guardian_rank.set_default();
        }
        self.guardian_rank.as_mut().unwrap()
    }

    // Take field
    pub fn take_guardian_rank(&mut self) -> GuardianRankSaveGameData {
        self.guardian_rank.take().unwrap_or_else(|| GuardianRankSaveGameData::new())
    }

    // .OakSave.CrewQuartersSaveData crew_quarters_room = 34;


    pub fn get_crew_quarters_room(&self) -> &CrewQuartersSaveData {
        self.crew_quarters_room.as_ref().unwrap_or_else(|| <CrewQuartersSaveData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_crew_quarters_room(&mut self) {
        self.crew_quarters_room.clear();
    }

    pub fn has_crew_quarters_room(&self) -> bool {
        self.crew_quarters_room.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crew_quarters_room(&mut self, v: CrewQuartersSaveData) {
        self.crew_quarters_room = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_crew_quarters_room(&mut self) -> &mut CrewQuartersSaveData {
        if self.crew_quarters_room.is_none() {
            self.crew_quarters_room.set_default();
        }
        self.crew_quarters_room.as_mut().unwrap()
    }

    // Take field
    pub fn take_crew_quarters_room(&mut self) -> CrewQuartersSaveData {
        self.crew_quarters_room.take().unwrap_or_else(|| CrewQuartersSaveData::new())
    }

    // .OakSave.CrewQuartersGunRackSaveData crew_quarters_gun_rack = 35;


    pub fn get_crew_quarters_gun_rack(&self) -> &CrewQuartersGunRackSaveData {
        self.crew_quarters_gun_rack.as_ref().unwrap_or_else(|| <CrewQuartersGunRackSaveData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_crew_quarters_gun_rack(&mut self) {
        self.crew_quarters_gun_rack.clear();
    }

    pub fn has_crew_quarters_gun_rack(&self) -> bool {
        self.crew_quarters_gun_rack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crew_quarters_gun_rack(&mut self, v: CrewQuartersGunRackSaveData) {
        self.crew_quarters_gun_rack = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_crew_quarters_gun_rack(&mut self) -> &mut CrewQuartersGunRackSaveData {
        if self.crew_quarters_gun_rack.is_none() {
            self.crew_quarters_gun_rack.set_default();
        }
        self.crew_quarters_gun_rack.as_mut().unwrap()
    }

    // Take field
    pub fn take_crew_quarters_gun_rack(&mut self) -> CrewQuartersGunRackSaveData {
        self.crew_quarters_gun_rack.take().unwrap_or_else(|| CrewQuartersGunRackSaveData::new())
    }

    // repeated .OakSave.EchoLogSaveGameData unlocked_echo_logs = 36;


    pub fn get_unlocked_echo_logs(&self) -> &[EchoLogSaveGameData] {
        &self.unlocked_echo_logs
    }
    pub fn clear_unlocked_echo_logs(&mut self) {
        self.unlocked_echo_logs.clear();
    }

    // Param is passed by value, moved
    pub fn set_unlocked_echo_logs(&mut self, v: ::protobuf::RepeatedField<EchoLogSaveGameData>) {
        self.unlocked_echo_logs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unlocked_echo_logs(&mut self) -> &mut ::protobuf::RepeatedField<EchoLogSaveGameData> {
        &mut self.unlocked_echo_logs
    }

    // Take field
    pub fn take_unlocked_echo_logs(&mut self) -> ::protobuf::RepeatedField<EchoLogSaveGameData> {
        ::std::mem::replace(&mut self.unlocked_echo_logs, ::protobuf::RepeatedField::new())
    }

    // bool has_played_special_echo_log_insert_already = 37;


    pub fn get_has_played_special_echo_log_insert_already(&self) -> bool {
        self.has_played_special_echo_log_insert_already
    }
    pub fn clear_has_played_special_echo_log_insert_already(&mut self) {
        self.has_played_special_echo_log_insert_already = false;
    }

    // Param is passed by value, moved
    pub fn set_has_played_special_echo_log_insert_already(&mut self, v: bool) {
        self.has_played_special_echo_log_insert_already = v;
    }

    // repeated .OakSave.Character.NicknameMappingsEntry nickname_mappings = 38;


    pub fn get_nickname_mappings(&self) -> &[Character_NicknameMappingsEntry] {
        &self.nickname_mappings
    }
    pub fn clear_nickname_mappings(&mut self) {
        self.nickname_mappings.clear();
    }

    // Param is passed by value, moved
    pub fn set_nickname_mappings(&mut self, v: ::protobuf::RepeatedField<Character_NicknameMappingsEntry>) {
        self.nickname_mappings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nickname_mappings(&mut self) -> &mut ::protobuf::RepeatedField<Character_NicknameMappingsEntry> {
        &mut self.nickname_mappings
    }

    // Take field
    pub fn take_nickname_mappings(&mut self) -> ::protobuf::RepeatedField<Character_NicknameMappingsEntry> {
        ::std::mem::replace(&mut self.nickname_mappings, ::protobuf::RepeatedField::new())
    }

    // .OakSave.MapIDData last_traveled_map_id = 39;


    pub fn get_last_traveled_map_id(&self) -> &MapIDData {
        self.last_traveled_map_id.as_ref().unwrap_or_else(|| <MapIDData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_last_traveled_map_id(&mut self) {
        self.last_traveled_map_id.clear();
    }

    pub fn has_last_traveled_map_id(&self) -> bool {
        self.last_traveled_map_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_traveled_map_id(&mut self, v: MapIDData) {
        self.last_traveled_map_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_traveled_map_id(&mut self) -> &mut MapIDData {
        if self.last_traveled_map_id.is_none() {
            self.last_traveled_map_id.set_default();
        }
        self.last_traveled_map_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_traveled_map_id(&mut self) -> MapIDData {
        self.last_traveled_map_id.take().unwrap_or_else(|| MapIDData::new())
    }

    // .OakSave.ChallengeCategoryProgressSaveData challenge_category_completion_pcts = 40;


    pub fn get_challenge_category_completion_pcts(&self) -> &ChallengeCategoryProgressSaveData {
        self.challenge_category_completion_pcts.as_ref().unwrap_or_else(|| <ChallengeCategoryProgressSaveData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_challenge_category_completion_pcts(&mut self) {
        self.challenge_category_completion_pcts.clear();
    }

    pub fn has_challenge_category_completion_pcts(&self) -> bool {
        self.challenge_category_completion_pcts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_category_completion_pcts(&mut self, v: ChallengeCategoryProgressSaveData) {
        self.challenge_category_completion_pcts = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_challenge_category_completion_pcts(&mut self) -> &mut ChallengeCategoryProgressSaveData {
        if self.challenge_category_completion_pcts.is_none() {
            self.challenge_category_completion_pcts.set_default();
        }
        self.challenge_category_completion_pcts.as_mut().unwrap()
    }

    // Take field
    pub fn take_challenge_category_completion_pcts(&mut self) -> ChallengeCategoryProgressSaveData {
        self.challenge_category_completion_pcts.take().unwrap_or_else(|| ChallengeCategoryProgressSaveData::new())
    }

    // .OakSave.OakPlayerCharacterSlotSaveGameData character_slot_save_game_data = 41;


    pub fn get_character_slot_save_game_data(&self) -> &OakPlayerCharacterSlotSaveGameData {
        self.character_slot_save_game_data.as_ref().unwrap_or_else(|| <OakPlayerCharacterSlotSaveGameData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_character_slot_save_game_data(&mut self) {
        self.character_slot_save_game_data.clear();
    }

    pub fn has_character_slot_save_game_data(&self) -> bool {
        self.character_slot_save_game_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_character_slot_save_game_data(&mut self, v: OakPlayerCharacterSlotSaveGameData) {
        self.character_slot_save_game_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_character_slot_save_game_data(&mut self) -> &mut OakPlayerCharacterSlotSaveGameData {
        if self.character_slot_save_game_data.is_none() {
            self.character_slot_save_game_data.set_default();
        }
        self.character_slot_save_game_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_character_slot_save_game_data(&mut self) -> OakPlayerCharacterSlotSaveGameData {
        self.character_slot_save_game_data.take().unwrap_or_else(|| OakPlayerCharacterSlotSaveGameData::new())
    }

    // .OakSave.UITrackingSaveGameData ui_tracking_save_game_data = 42;


    pub fn get_ui_tracking_save_game_data(&self) -> &UITrackingSaveGameData {
        self.ui_tracking_save_game_data.as_ref().unwrap_or_else(|| <UITrackingSaveGameData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ui_tracking_save_game_data(&mut self) {
        self.ui_tracking_save_game_data.clear();
    }

    pub fn has_ui_tracking_save_game_data(&self) -> bool {
        self.ui_tracking_save_game_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ui_tracking_save_game_data(&mut self, v: UITrackingSaveGameData) {
        self.ui_tracking_save_game_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ui_tracking_save_game_data(&mut self) -> &mut UITrackingSaveGameData {
        if self.ui_tracking_save_game_data.is_none() {
            self.ui_tracking_save_game_data.set_default();
        }
        self.ui_tracking_save_game_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_ui_tracking_save_game_data(&mut self) -> UITrackingSaveGameData {
        self.ui_tracking_save_game_data.take().unwrap_or_else(|| UITrackingSaveGameData::new())
    }

    // string preferred_character_name = 43;


    pub fn get_preferred_character_name(&self) -> &str {
        &self.preferred_character_name
    }
    pub fn clear_preferred_character_name(&mut self) {
        self.preferred_character_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_preferred_character_name(&mut self, v: ::std::string::String) {
        self.preferred_character_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preferred_character_name(&mut self) -> &mut ::std::string::String {
        &mut self.preferred_character_name
    }

    // Take field
    pub fn take_preferred_character_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.preferred_character_name, ::std::string::String::new())
    }

    // int32 name_character_limit = 44;


    pub fn get_name_character_limit(&self) -> i32 {
        self.name_character_limit
    }
    pub fn clear_name_character_limit(&mut self) {
        self.name_character_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_name_character_limit(&mut self, v: i32) {
        self.name_character_limit = v;
    }

    // uint32 preferred_group_mode = 45;


    pub fn get_preferred_group_mode(&self) -> u32 {
        self.preferred_group_mode
    }
    pub fn clear_preferred_group_mode(&mut self) {
        self.preferred_group_mode = 0;
    }

    // Param is passed by value, moved
    pub fn set_preferred_group_mode(&mut self, v: u32) {
        self.preferred_group_mode = v;
    }

    // .OakSave.TimeOfDaySaveGameData time_of_day_save_game_data = 46;


    pub fn get_time_of_day_save_game_data(&self) -> &TimeOfDaySaveGameData {
        self.time_of_day_save_game_data.as_ref().unwrap_or_else(|| <TimeOfDaySaveGameData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_time_of_day_save_game_data(&mut self) {
        self.time_of_day_save_game_data.clear();
    }

    pub fn has_time_of_day_save_game_data(&self) -> bool {
        self.time_of_day_save_game_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_of_day_save_game_data(&mut self, v: TimeOfDaySaveGameData) {
        self.time_of_day_save_game_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time_of_day_save_game_data(&mut self) -> &mut TimeOfDaySaveGameData {
        if self.time_of_day_save_game_data.is_none() {
            self.time_of_day_save_game_data.set_default();
        }
        self.time_of_day_save_game_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_time_of_day_save_game_data(&mut self) -> TimeOfDaySaveGameData {
        self.time_of_day_save_game_data.take().unwrap_or_else(|| TimeOfDaySaveGameData::new())
    }

    // repeated .OakSave.LevelPersistence_Level_SaveGameData level_persistence_data = 47;


    pub fn get_level_persistence_data(&self) -> &[LevelPersistence_Level_SaveGameData] {
        &self.level_persistence_data
    }
    pub fn clear_level_persistence_data(&mut self) {
        self.level_persistence_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_level_persistence_data(&mut self, v: ::protobuf::RepeatedField<LevelPersistence_Level_SaveGameData>) {
        self.level_persistence_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_level_persistence_data(&mut self) -> &mut ::protobuf::RepeatedField<LevelPersistence_Level_SaveGameData> {
        &mut self.level_persistence_data
    }

    // Take field
    pub fn take_level_persistence_data(&mut self) -> ::protobuf::RepeatedField<LevelPersistence_Level_SaveGameData> {
        ::std::mem::replace(&mut self.level_persistence_data, ::protobuf::RepeatedField::new())
    }

    // uint32 accumulated_level_persistence_reset_timer_seconds = 48;


    pub fn get_accumulated_level_persistence_reset_timer_seconds(&self) -> u32 {
        self.accumulated_level_persistence_reset_timer_seconds
    }
    pub fn clear_accumulated_level_persistence_reset_timer_seconds(&mut self) {
        self.accumulated_level_persistence_reset_timer_seconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_accumulated_level_persistence_reset_timer_seconds(&mut self, v: u32) {
        self.accumulated_level_persistence_reset_timer_seconds = v;
    }

    // uint32 mayhem_level = 49;


    pub fn get_mayhem_level(&self) -> u32 {
        self.mayhem_level
    }
    pub fn clear_mayhem_level(&mut self) {
        self.mayhem_level = 0;
    }

    // Param is passed by value, moved
    pub fn set_mayhem_level(&mut self, v: u32) {
        self.mayhem_level = v;
    }

    // .OakSave.GbxZoneMapFODSaveGameData gbx_zone_map_fod_save_game_data = 50;


    pub fn get_gbx_zone_map_fod_save_game_data(&self) -> &GbxZoneMapFODSaveGameData {
        self.gbx_zone_map_fod_save_game_data.as_ref().unwrap_or_else(|| <GbxZoneMapFODSaveGameData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_gbx_zone_map_fod_save_game_data(&mut self) {
        self.gbx_zone_map_fod_save_game_data.clear();
    }

    pub fn has_gbx_zone_map_fod_save_game_data(&self) -> bool {
        self.gbx_zone_map_fod_save_game_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gbx_zone_map_fod_save_game_data(&mut self, v: GbxZoneMapFODSaveGameData) {
        self.gbx_zone_map_fod_save_game_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gbx_zone_map_fod_save_game_data(&mut self) -> &mut GbxZoneMapFODSaveGameData {
        if self.gbx_zone_map_fod_save_game_data.is_none() {
            self.gbx_zone_map_fod_save_game_data.set_default();
        }
        self.gbx_zone_map_fod_save_game_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_gbx_zone_map_fod_save_game_data(&mut self) -> GbxZoneMapFODSaveGameData {
        self.gbx_zone_map_fod_save_game_data.take().unwrap_or_else(|| GbxZoneMapFODSaveGameData::new())
    }

    // repeated .OakSave.ActiveFastTravelSaveData active_or_blacklisted_travel_stations = 51;


    pub fn get_active_or_blacklisted_travel_stations(&self) -> &[ActiveFastTravelSaveData] {
        &self.active_or_blacklisted_travel_stations
    }
    pub fn clear_active_or_blacklisted_travel_stations(&mut self) {
        self.active_or_blacklisted_travel_stations.clear();
    }

    // Param is passed by value, moved
    pub fn set_active_or_blacklisted_travel_stations(&mut self, v: ::protobuf::RepeatedField<ActiveFastTravelSaveData>) {
        self.active_or_blacklisted_travel_stations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_active_or_blacklisted_travel_stations(&mut self) -> &mut ::protobuf::RepeatedField<ActiveFastTravelSaveData> {
        &mut self.active_or_blacklisted_travel_stations
    }

    // Take field
    pub fn take_active_or_blacklisted_travel_stations(&mut self) -> ::protobuf::RepeatedField<ActiveFastTravelSaveData> {
        ::std::mem::replace(&mut self.active_or_blacklisted_travel_stations, ::protobuf::RepeatedField::new())
    }

    // repeated string last_active_travel_station_for_playthrough = 52;


    pub fn get_last_active_travel_station_for_playthrough(&self) -> &[::std::string::String] {
        &self.last_active_travel_station_for_playthrough
    }
    pub fn clear_last_active_travel_station_for_playthrough(&mut self) {
        self.last_active_travel_station_for_playthrough.clear();
    }

    // Param is passed by value, moved
    pub fn set_last_active_travel_station_for_playthrough(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.last_active_travel_station_for_playthrough = v;
    }

    // Mutable pointer to the field.
    pub fn mut_last_active_travel_station_for_playthrough(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.last_active_travel_station_for_playthrough
    }

    // Take field
    pub fn take_last_active_travel_station_for_playthrough(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.last_active_travel_station_for_playthrough, ::protobuf::RepeatedField::new())
    }

    // repeated .OakSave.GameStateSaveData game_state_save_data_for_playthrough = 53;


    pub fn get_game_state_save_data_for_playthrough(&self) -> &[GameStateSaveData] {
        &self.game_state_save_data_for_playthrough
    }
    pub fn clear_game_state_save_data_for_playthrough(&mut self) {
        self.game_state_save_data_for_playthrough.clear();
    }

    // Param is passed by value, moved
    pub fn set_game_state_save_data_for_playthrough(&mut self, v: ::protobuf::RepeatedField<GameStateSaveData>) {
        self.game_state_save_data_for_playthrough = v;
    }

    // Mutable pointer to the field.
    pub fn mut_game_state_save_data_for_playthrough(&mut self) -> &mut ::protobuf::RepeatedField<GameStateSaveData> {
        &mut self.game_state_save_data_for_playthrough
    }

    // Take field
    pub fn take_game_state_save_data_for_playthrough(&mut self) -> ::protobuf::RepeatedField<GameStateSaveData> {
        ::std::mem::replace(&mut self.game_state_save_data_for_playthrough, ::protobuf::RepeatedField::new())
    }

    // repeated .OakSave.RegisteredDownloadableEntitlements registered_downloadable_entitlements = 54;


    pub fn get_registered_downloadable_entitlements(&self) -> &[super::oak_shared::RegisteredDownloadableEntitlements] {
        &self.registered_downloadable_entitlements
    }
    pub fn clear_registered_downloadable_entitlements(&mut self) {
        self.registered_downloadable_entitlements.clear();
    }

    // Param is passed by value, moved
    pub fn set_registered_downloadable_entitlements(&mut self, v: ::protobuf::RepeatedField<super::oak_shared::RegisteredDownloadableEntitlements>) {
        self.registered_downloadable_entitlements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_registered_downloadable_entitlements(&mut self) -> &mut ::protobuf::RepeatedField<super::oak_shared::RegisteredDownloadableEntitlements> {
        &mut self.registered_downloadable_entitlements
    }

    // Take field
    pub fn take_registered_downloadable_entitlements(&mut self) -> ::protobuf::RepeatedField<super::oak_shared::RegisteredDownloadableEntitlements> {
        ::std::mem::replace(&mut self.registered_downloadable_entitlements, ::protobuf::RepeatedField::new())
    }

    // repeated .OakSave.PlaythroughActiveFastTravelSaveData active_travel_stations_for_playthrough = 55;


    pub fn get_active_travel_stations_for_playthrough(&self) -> &[PlaythroughActiveFastTravelSaveData] {
        &self.active_travel_stations_for_playthrough
    }
    pub fn clear_active_travel_stations_for_playthrough(&mut self) {
        self.active_travel_stations_for_playthrough.clear();
    }

    // Param is passed by value, moved
    pub fn set_active_travel_stations_for_playthrough(&mut self, v: ::protobuf::RepeatedField<PlaythroughActiveFastTravelSaveData>) {
        self.active_travel_stations_for_playthrough = v;
    }

    // Mutable pointer to the field.
    pub fn mut_active_travel_stations_for_playthrough(&mut self) -> &mut ::protobuf::RepeatedField<PlaythroughActiveFastTravelSaveData> {
        &mut self.active_travel_stations_for_playthrough
    }

    // Take field
    pub fn take_active_travel_stations_for_playthrough(&mut self) -> ::protobuf::RepeatedField<PlaythroughActiveFastTravelSaveData> {
        ::std::mem::replace(&mut self.active_travel_stations_for_playthrough, ::protobuf::RepeatedField::new())
    }

    // string save_game_guid = 56;


    pub fn get_save_game_guid(&self) -> &str {
        &self.save_game_guid
    }
    pub fn clear_save_game_guid(&mut self) {
        self.save_game_guid.clear();
    }

    // Param is passed by value, moved
    pub fn set_save_game_guid(&mut self, v: ::std::string::String) {
        self.save_game_guid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_save_game_guid(&mut self) -> &mut ::std::string::String {
        &mut self.save_game_guid
    }

    // Take field
    pub fn take_save_game_guid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.save_game_guid, ::std::string::String::new())
    }

    // .OakSave.GuardianRankCharacterSaveGameData guardian_rank_character_data = 57;


    pub fn get_guardian_rank_character_data(&self) -> &GuardianRankCharacterSaveGameData {
        self.guardian_rank_character_data.as_ref().unwrap_or_else(|| <GuardianRankCharacterSaveGameData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_guardian_rank_character_data(&mut self) {
        self.guardian_rank_character_data.clear();
    }

    pub fn has_guardian_rank_character_data(&self) -> bool {
        self.guardian_rank_character_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guardian_rank_character_data(&mut self, v: GuardianRankCharacterSaveGameData) {
        self.guardian_rank_character_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guardian_rank_character_data(&mut self) -> &mut GuardianRankCharacterSaveGameData {
        if self.guardian_rank_character_data.is_none() {
            self.guardian_rank_character_data.set_default();
        }
        self.guardian_rank_character_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_guardian_rank_character_data(&mut self) -> GuardianRankCharacterSaveGameData {
        self.guardian_rank_character_data.take().unwrap_or_else(|| GuardianRankCharacterSaveGameData::new())
    }

    // bool optional_objective_reward_fixup_applied = 58;


    pub fn get_optional_objective_reward_fixup_applied(&self) -> bool {
        self.optional_objective_reward_fixup_applied
    }
    pub fn clear_optional_objective_reward_fixup_applied(&mut self) {
        self.optional_objective_reward_fixup_applied = false;
    }

    // Param is passed by value, moved
    pub fn set_optional_objective_reward_fixup_applied(&mut self, v: bool) {
        self.optional_objective_reward_fixup_applied = v;
    }

    // bool vehicle_part_rewards_fixup_applied = 59;


    pub fn get_vehicle_part_rewards_fixup_applied(&self) -> bool {
        self.vehicle_part_rewards_fixup_applied
    }
    pub fn clear_vehicle_part_rewards_fixup_applied(&mut self) {
        self.vehicle_part_rewards_fixup_applied = false;
    }

    // Param is passed by value, moved
    pub fn set_vehicle_part_rewards_fixup_applied(&mut self, v: bool) {
        self.vehicle_part_rewards_fixup_applied = v;
    }

    // uint32 last_active_league = 60;


    pub fn get_last_active_league(&self) -> u32 {
        self.last_active_league
    }
    pub fn clear_last_active_league(&mut self) {
        self.last_active_league = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_active_league(&mut self, v: u32) {
        self.last_active_league = v;
    }

    // uint32 last_active_league_instance = 61;


    pub fn get_last_active_league_instance(&self) -> u32 {
        self.last_active_league_instance
    }
    pub fn clear_last_active_league_instance(&mut self) {
        self.last_active_league_instance = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_active_league_instance(&mut self, v: u32) {
        self.last_active_league_instance = v;
    }

    // repeated .OakSave.Character.ActiveLeagueInstanceForEventEntry active_league_instance_for_event = 62;


    pub fn get_active_league_instance_for_event(&self) -> &[Character_ActiveLeagueInstanceForEventEntry] {
        &self.active_league_instance_for_event
    }
    pub fn clear_active_league_instance_for_event(&mut self) {
        self.active_league_instance_for_event.clear();
    }

    // Param is passed by value, moved
    pub fn set_active_league_instance_for_event(&mut self, v: ::protobuf::RepeatedField<Character_ActiveLeagueInstanceForEventEntry>) {
        self.active_league_instance_for_event = v;
    }

    // Mutable pointer to the field.
    pub fn mut_active_league_instance_for_event(&mut self) -> &mut ::protobuf::RepeatedField<Character_ActiveLeagueInstanceForEventEntry> {
        &mut self.active_league_instance_for_event
    }

    // Take field
    pub fn take_active_league_instance_for_event(&mut self) -> ::protobuf::RepeatedField<Character_ActiveLeagueInstanceForEventEntry> {
        ::std::mem::replace(&mut self.active_league_instance_for_event, ::protobuf::RepeatedField::new())
    }

    // bool levelled_save_vehicle_part_rewards_fixup_applied = 63;


    pub fn get_levelled_save_vehicle_part_rewards_fixup_applied(&self) -> bool {
        self.levelled_save_vehicle_part_rewards_fixup_applied
    }
    pub fn clear_levelled_save_vehicle_part_rewards_fixup_applied(&mut self) {
        self.levelled_save_vehicle_part_rewards_fixup_applied = false;
    }

    // Param is passed by value, moved
    pub fn set_levelled_save_vehicle_part_rewards_fixup_applied(&mut self, v: bool) {
        self.levelled_save_vehicle_part_rewards_fixup_applied = v;
    }

    // .OakSave.OakProfileCloudData profile_cloud_data = 64;


    pub fn get_profile_cloud_data(&self) -> &OakProfileCloudData {
        self.profile_cloud_data.as_ref().unwrap_or_else(|| <OakProfileCloudData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_profile_cloud_data(&mut self) {
        self.profile_cloud_data.clear();
    }

    pub fn has_profile_cloud_data(&self) -> bool {
        self.profile_cloud_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_profile_cloud_data(&mut self, v: OakProfileCloudData) {
        self.profile_cloud_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_profile_cloud_data(&mut self) -> &mut OakProfileCloudData {
        if self.profile_cloud_data.is_none() {
            self.profile_cloud_data.set_default();
        }
        self.profile_cloud_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_profile_cloud_data(&mut self) -> OakProfileCloudData {
        self.profile_cloud_data.take().unwrap_or_else(|| OakProfileCloudData::new())
    }
}

impl ::protobuf::Message for Character {
    fn is_initialized(&self) -> bool {
        for v in &self.player_class_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.resource_pools {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.saved_regions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.game_stats_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inventory_category_list {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inventory_items {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.equipped_inventory_list {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ability_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mission_playthroughs_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.discovery_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vehicles_unlocked_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vehicle_loadouts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.challenge_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sdu_list {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.selected_color_customizations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.guardian_rank {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.crew_quarters_room {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.crew_quarters_gun_rack {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unlocked_echo_logs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.nickname_mappings {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.last_traveled_map_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.challenge_category_completion_pcts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.character_slot_save_game_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ui_tracking_save_game_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.time_of_day_save_game_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.level_persistence_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.gbx_zone_map_fod_save_game_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.active_or_blacklisted_travel_stations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.game_state_save_data_for_playthrough {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.registered_downloadable_entitlements {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.active_travel_stations_for_playthrough {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.guardian_rank_character_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.active_league_instance_for_event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.profile_cloud_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.save_game_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.last_save_timestamp = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_played_seconds = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.player_class_data)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resource_pools)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.saved_regions)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.experience_points = tmp;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.game_stats_data)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.inventory_category_list)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.inventory_items)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.equipped_inventory_list)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.active_weapon_list)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ability_data)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.last_play_through_index = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.playthroughs_completed = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.show_new_playthrough_notification = tmp;
                },
                17 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.mission_playthroughs_data)?;
                },
                21 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.active_travel_stations)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.discovery_data)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.last_active_travel_station)?;
                },
                24 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.vehicles_unlocked_data)?;
                },
                25 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.vehicle_parts_unlocked)?;
                },
                26 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.vehicle_loadouts)?;
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.vehicle_last_loadout_index = tmp;
                },
                28 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.challenge_data)?;
                },
                29 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sdu_list)?;
                },
                30 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.selected_customizations)?;
                },
                31 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.equipped_emote_customizations)?;
                },
                32 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.selected_color_customizations)?;
                },
                33 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.guardian_rank)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.crew_quarters_room)?;
                },
                35 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.crew_quarters_gun_rack)?;
                },
                36 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.unlocked_echo_logs)?;
                },
                37 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_played_special_echo_log_insert_already = tmp;
                },
                38 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nickname_mappings)?;
                },
                39 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last_traveled_map_id)?;
                },
                40 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.challenge_category_completion_pcts)?;
                },
                41 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.character_slot_save_game_data)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ui_tracking_save_game_data)?;
                },
                43 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.preferred_character_name)?;
                },
                44 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.name_character_limit = tmp;
                },
                45 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.preferred_group_mode = tmp;
                },
                46 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time_of_day_save_game_data)?;
                },
                47 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.level_persistence_data)?;
                },
                48 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accumulated_level_persistence_reset_timer_seconds = tmp;
                },
                49 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mayhem_level = tmp;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.gbx_zone_map_fod_save_game_data)?;
                },
                51 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.active_or_blacklisted_travel_stations)?;
                },
                52 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.last_active_travel_station_for_playthrough)?;
                },
                53 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.game_state_save_data_for_playthrough)?;
                },
                54 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.registered_downloadable_entitlements)?;
                },
                55 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.active_travel_stations_for_playthrough)?;
                },
                56 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.save_game_guid)?;
                },
                57 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.guardian_rank_character_data)?;
                },
                58 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.optional_objective_reward_fixup_applied = tmp;
                },
                59 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.vehicle_part_rewards_fixup_applied = tmp;
                },
                60 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_active_league = tmp;
                },
                61 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_active_league_instance = tmp;
                },
                62 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.active_league_instance_for_event)?;
                },
                63 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.levelled_save_vehicle_part_rewards_fixup_applied = tmp;
                },
                64 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.profile_cloud_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.save_game_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.save_game_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.last_save_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(2, self.last_save_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.time_played_seconds != 0 {
            my_size += ::protobuf::rt::value_size(3, self.time_played_seconds, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.player_class_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.resource_pools {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.saved_regions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.experience_points != 0 {
            my_size += ::protobuf::rt::value_size(7, self.experience_points, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.game_stats_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.inventory_category_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.inventory_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.equipped_inventory_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.active_weapon_list {
            my_size += ::protobuf::rt::value_size(12, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.ability_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.last_play_through_index != 0 {
            my_size += ::protobuf::rt::value_size(14, self.last_play_through_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.playthroughs_completed != 0 {
            my_size += ::protobuf::rt::value_size(15, self.playthroughs_completed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.show_new_playthrough_notification != false {
            my_size += 3;
        }
        for value in &self.mission_playthroughs_data {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.active_travel_stations {
            my_size += ::protobuf::rt::string_size(21, &value);
        };
        if let Some(ref v) = self.discovery_data.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.last_active_travel_station.is_empty() {
            my_size += ::protobuf::rt::string_size(23, &self.last_active_travel_station);
        }
        for value in &self.vehicles_unlocked_data {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.vehicle_parts_unlocked {
            my_size += ::protobuf::rt::string_size(25, &value);
        };
        for value in &self.vehicle_loadouts {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.vehicle_last_loadout_index != 0 {
            my_size += ::protobuf::rt::value_size(27, self.vehicle_last_loadout_index, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.challenge_data {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.sdu_list {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.selected_customizations {
            my_size += ::protobuf::rt::string_size(30, &value);
        };
        for value in &self.equipped_emote_customizations {
            my_size += ::protobuf::rt::value_size(31, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.selected_color_customizations {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.guardian_rank.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.crew_quarters_room.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.crew_quarters_gun_rack.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.unlocked_echo_logs {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.has_played_special_echo_log_insert_already != false {
            my_size += 3;
        }
        for value in &self.nickname_mappings {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.last_traveled_map_id.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.challenge_category_completion_pcts.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.character_slot_save_game_data.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ui_tracking_save_game_data.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.preferred_character_name.is_empty() {
            my_size += ::protobuf::rt::string_size(43, &self.preferred_character_name);
        }
        if self.name_character_limit != 0 {
            my_size += ::protobuf::rt::value_size(44, self.name_character_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.preferred_group_mode != 0 {
            my_size += ::protobuf::rt::value_size(45, self.preferred_group_mode, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.time_of_day_save_game_data.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.level_persistence_data {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.accumulated_level_persistence_reset_timer_seconds != 0 {
            my_size += ::protobuf::rt::value_size(48, self.accumulated_level_persistence_reset_timer_seconds, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.mayhem_level != 0 {
            my_size += ::protobuf::rt::value_size(49, self.mayhem_level, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.gbx_zone_map_fod_save_game_data.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.active_or_blacklisted_travel_stations {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.last_active_travel_station_for_playthrough {
            my_size += ::protobuf::rt::string_size(52, &value);
        };
        for value in &self.game_state_save_data_for_playthrough {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.registered_downloadable_entitlements {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.active_travel_stations_for_playthrough {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.save_game_guid.is_empty() {
            my_size += ::protobuf::rt::string_size(56, &self.save_game_guid);
        }
        if let Some(ref v) = self.guardian_rank_character_data.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.optional_objective_reward_fixup_applied != false {
            my_size += 3;
        }
        if self.vehicle_part_rewards_fixup_applied != false {
            my_size += 3;
        }
        if self.last_active_league != 0 {
            my_size += ::protobuf::rt::value_size(60, self.last_active_league, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.last_active_league_instance != 0 {
            my_size += ::protobuf::rt::value_size(61, self.last_active_league_instance, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.active_league_instance_for_event {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.levelled_save_vehicle_part_rewards_fixup_applied != false {
            my_size += 3;
        }
        if let Some(ref v) = self.profile_cloud_data.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.save_game_id != 0 {
            os.write_uint32(1, self.save_game_id)?;
        }
        if self.last_save_timestamp != 0 {
            os.write_int64(2, self.last_save_timestamp)?;
        }
        if self.time_played_seconds != 0 {
            os.write_uint32(3, self.time_played_seconds)?;
        }
        if let Some(ref v) = self.player_class_data.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.resource_pools {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.saved_regions {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.experience_points != 0 {
            os.write_int32(7, self.experience_points)?;
        }
        for v in &self.game_stats_data {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.inventory_category_list {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.inventory_items {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.equipped_inventory_list {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.active_weapon_list {
            os.write_int32(12, *v)?;
        };
        if let Some(ref v) = self.ability_data.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.last_play_through_index != 0 {
            os.write_int32(14, self.last_play_through_index)?;
        }
        if self.playthroughs_completed != 0 {
            os.write_int32(15, self.playthroughs_completed)?;
        }
        if self.show_new_playthrough_notification != false {
            os.write_bool(16, self.show_new_playthrough_notification)?;
        }
        for v in &self.mission_playthroughs_data {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.active_travel_stations {
            os.write_string(21, &v)?;
        };
        if let Some(ref v) = self.discovery_data.as_ref() {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.last_active_travel_station.is_empty() {
            os.write_string(23, &self.last_active_travel_station)?;
        }
        for v in &self.vehicles_unlocked_data {
            os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.vehicle_parts_unlocked {
            os.write_string(25, &v)?;
        };
        for v in &self.vehicle_loadouts {
            os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.vehicle_last_loadout_index != 0 {
            os.write_int32(27, self.vehicle_last_loadout_index)?;
        }
        for v in &self.challenge_data {
            os.write_tag(28, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.sdu_list {
            os.write_tag(29, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.selected_customizations {
            os.write_string(30, &v)?;
        };
        for v in &self.equipped_emote_customizations {
            os.write_int32(31, *v)?;
        };
        for v in &self.selected_color_customizations {
            os.write_tag(32, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.guardian_rank.as_ref() {
            os.write_tag(33, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.crew_quarters_room.as_ref() {
            os.write_tag(34, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.crew_quarters_gun_rack.as_ref() {
            os.write_tag(35, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.unlocked_echo_logs {
            os.write_tag(36, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.has_played_special_echo_log_insert_already != false {
            os.write_bool(37, self.has_played_special_echo_log_insert_already)?;
        }
        for v in &self.nickname_mappings {
            os.write_tag(38, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.last_traveled_map_id.as_ref() {
            os.write_tag(39, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.challenge_category_completion_pcts.as_ref() {
            os.write_tag(40, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.character_slot_save_game_data.as_ref() {
            os.write_tag(41, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ui_tracking_save_game_data.as_ref() {
            os.write_tag(42, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.preferred_character_name.is_empty() {
            os.write_string(43, &self.preferred_character_name)?;
        }
        if self.name_character_limit != 0 {
            os.write_int32(44, self.name_character_limit)?;
        }
        if self.preferred_group_mode != 0 {
            os.write_uint32(45, self.preferred_group_mode)?;
        }
        if let Some(ref v) = self.time_of_day_save_game_data.as_ref() {
            os.write_tag(46, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.level_persistence_data {
            os.write_tag(47, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.accumulated_level_persistence_reset_timer_seconds != 0 {
            os.write_uint32(48, self.accumulated_level_persistence_reset_timer_seconds)?;
        }
        if self.mayhem_level != 0 {
            os.write_uint32(49, self.mayhem_level)?;
        }
        if let Some(ref v) = self.gbx_zone_map_fod_save_game_data.as_ref() {
            os.write_tag(50, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.active_or_blacklisted_travel_stations {
            os.write_tag(51, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.last_active_travel_station_for_playthrough {
            os.write_string(52, &v)?;
        };
        for v in &self.game_state_save_data_for_playthrough {
            os.write_tag(53, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.registered_downloadable_entitlements {
            os.write_tag(54, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.active_travel_stations_for_playthrough {
            os.write_tag(55, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.save_game_guid.is_empty() {
            os.write_string(56, &self.save_game_guid)?;
        }
        if let Some(ref v) = self.guardian_rank_character_data.as_ref() {
            os.write_tag(57, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.optional_objective_reward_fixup_applied != false {
            os.write_bool(58, self.optional_objective_reward_fixup_applied)?;
        }
        if self.vehicle_part_rewards_fixup_applied != false {
            os.write_bool(59, self.vehicle_part_rewards_fixup_applied)?;
        }
        if self.last_active_league != 0 {
            os.write_uint32(60, self.last_active_league)?;
        }
        if self.last_active_league_instance != 0 {
            os.write_uint32(61, self.last_active_league_instance)?;
        }
        for v in &self.active_league_instance_for_event {
            os.write_tag(62, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.levelled_save_vehicle_part_rewards_fixup_applied != false {
            os.write_bool(63, self.levelled_save_vehicle_part_rewards_fixup_applied)?;
        }
        if let Some(ref v) = self.profile_cloud_data.as_ref() {
            os.write_tag(64, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Character {
        Character::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "save_game_id",
                |m: &Character| { &m.save_game_id },
                |m: &mut Character| { &mut m.save_game_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "last_save_timestamp",
                |m: &Character| { &m.last_save_timestamp },
                |m: &mut Character| { &mut m.last_save_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_played_seconds",
                |m: &Character| { &m.time_played_seconds },
                |m: &mut Character| { &mut m.time_played_seconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerClassSaveGameData>>(
                "player_class_data",
                |m: &Character| { &m.player_class_data },
                |m: &mut Character| { &mut m.player_class_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourcePoolSavegameData>>(
                "resource_pools",
                |m: &Character| { &m.resource_pools },
                |m: &mut Character| { &mut m.resource_pools },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RegionSaveGameData>>(
                "saved_regions",
                |m: &Character| { &m.saved_regions },
                |m: &mut Character| { &mut m.saved_regions },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "experience_points",
                |m: &Character| { &m.experience_points },
                |m: &mut Character| { &mut m.experience_points },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::oak_shared::GameStatSaveGameData>>(
                "game_stats_data",
                |m: &Character| { &m.game_stats_data },
                |m: &mut Character| { &mut m.game_stats_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::oak_shared::InventoryCategorySaveData>>(
                "inventory_category_list",
                |m: &Character| { &m.inventory_category_list },
                |m: &mut Character| { &mut m.inventory_category_list },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OakInventoryItemSaveGameData>>(
                "inventory_items",
                |m: &Character| { &m.inventory_items },
                |m: &mut Character| { &mut m.inventory_items },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EquippedInventorySaveGameData>>(
                "equipped_inventory_list",
                |m: &Character| { &m.equipped_inventory_list },
                |m: &mut Character| { &mut m.equipped_inventory_list },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "active_weapon_list",
                |m: &Character| { &m.active_weapon_list },
                |m: &mut Character| { &mut m.active_weapon_list },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OakPlayerAbilitySaveGameData>>(
                "ability_data",
                |m: &Character| { &m.ability_data },
                |m: &mut Character| { &mut m.ability_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "last_play_through_index",
                |m: &Character| { &m.last_play_through_index },
                |m: &mut Character| { &mut m.last_play_through_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "playthroughs_completed",
                |m: &Character| { &m.playthroughs_completed },
                |m: &mut Character| { &mut m.playthroughs_completed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "show_new_playthrough_notification",
                |m: &Character| { &m.show_new_playthrough_notification },
                |m: &mut Character| { &mut m.show_new_playthrough_notification },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MissionPlaythroughSaveGameData>>(
                "mission_playthroughs_data",
                |m: &Character| { &m.mission_playthroughs_data },
                |m: &mut Character| { &mut m.mission_playthroughs_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "active_travel_stations",
                |m: &Character| { &m.active_travel_stations },
                |m: &mut Character| { &mut m.active_travel_stations },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DiscoverySaveData>>(
                "discovery_data",
                |m: &Character| { &m.discovery_data },
                |m: &mut Character| { &mut m.discovery_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "last_active_travel_station",
                |m: &Character| { &m.last_active_travel_station },
                |m: &mut Character| { &mut m.last_active_travel_station },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VehicleUnlockedSaveGameData>>(
                "vehicles_unlocked_data",
                |m: &Character| { &m.vehicles_unlocked_data },
                |m: &mut Character| { &mut m.vehicles_unlocked_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "vehicle_parts_unlocked",
                |m: &Character| { &m.vehicle_parts_unlocked },
                |m: &mut Character| { &mut m.vehicle_parts_unlocked },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OakCARMenuVehicleConfigSaveData>>(
                "vehicle_loadouts",
                |m: &Character| { &m.vehicle_loadouts },
                |m: &mut Character| { &mut m.vehicle_loadouts },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "vehicle_last_loadout_index",
                |m: &Character| { &m.vehicle_last_loadout_index },
                |m: &mut Character| { &mut m.vehicle_last_loadout_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::oak_shared::ChallengeSaveGameData>>(
                "challenge_data",
                |m: &Character| { &m.challenge_data },
                |m: &mut Character| { &mut m.challenge_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::oak_shared::OakSDUSaveGameData>>(
                "sdu_list",
                |m: &Character| { &m.sdu_list },
                |m: &mut Character| { &mut m.sdu_list },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "selected_customizations",
                |m: &Character| { &m.selected_customizations },
                |m: &mut Character| { &mut m.selected_customizations },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "equipped_emote_customizations",
                |m: &Character| { &m.equipped_emote_customizations },
                |m: &mut Character| { &mut m.equipped_emote_customizations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CustomPlayerColorSaveGameData>>(
                "selected_color_customizations",
                |m: &Character| { &m.selected_color_customizations },
                |m: &mut Character| { &mut m.selected_color_customizations },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GuardianRankSaveGameData>>(
                "guardian_rank",
                |m: &Character| { &m.guardian_rank },
                |m: &mut Character| { &mut m.guardian_rank },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CrewQuartersSaveData>>(
                "crew_quarters_room",
                |m: &Character| { &m.crew_quarters_room },
                |m: &mut Character| { &mut m.crew_quarters_room },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CrewQuartersGunRackSaveData>>(
                "crew_quarters_gun_rack",
                |m: &Character| { &m.crew_quarters_gun_rack },
                |m: &mut Character| { &mut m.crew_quarters_gun_rack },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EchoLogSaveGameData>>(
                "unlocked_echo_logs",
                |m: &Character| { &m.unlocked_echo_logs },
                |m: &mut Character| { &mut m.unlocked_echo_logs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_played_special_echo_log_insert_already",
                |m: &Character| { &m.has_played_special_echo_log_insert_already },
                |m: &mut Character| { &mut m.has_played_special_echo_log_insert_already },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Character_NicknameMappingsEntry>>(
                "nickname_mappings",
                |m: &Character| { &m.nickname_mappings },
                |m: &mut Character| { &mut m.nickname_mappings },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MapIDData>>(
                "last_traveled_map_id",
                |m: &Character| { &m.last_traveled_map_id },
                |m: &mut Character| { &mut m.last_traveled_map_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChallengeCategoryProgressSaveData>>(
                "challenge_category_completion_pcts",
                |m: &Character| { &m.challenge_category_completion_pcts },
                |m: &mut Character| { &mut m.challenge_category_completion_pcts },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OakPlayerCharacterSlotSaveGameData>>(
                "character_slot_save_game_data",
                |m: &Character| { &m.character_slot_save_game_data },
                |m: &mut Character| { &mut m.character_slot_save_game_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UITrackingSaveGameData>>(
                "ui_tracking_save_game_data",
                |m: &Character| { &m.ui_tracking_save_game_data },
                |m: &mut Character| { &mut m.ui_tracking_save_game_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "preferred_character_name",
                |m: &Character| { &m.preferred_character_name },
                |m: &mut Character| { &mut m.preferred_character_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "name_character_limit",
                |m: &Character| { &m.name_character_limit },
                |m: &mut Character| { &mut m.name_character_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "preferred_group_mode",
                |m: &Character| { &m.preferred_group_mode },
                |m: &mut Character| { &mut m.preferred_group_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeOfDaySaveGameData>>(
                "time_of_day_save_game_data",
                |m: &Character| { &m.time_of_day_save_game_data },
                |m: &mut Character| { &mut m.time_of_day_save_game_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LevelPersistence_Level_SaveGameData>>(
                "level_persistence_data",
                |m: &Character| { &m.level_persistence_data },
                |m: &mut Character| { &mut m.level_persistence_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "accumulated_level_persistence_reset_timer_seconds",
                |m: &Character| { &m.accumulated_level_persistence_reset_timer_seconds },
                |m: &mut Character| { &mut m.accumulated_level_persistence_reset_timer_seconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "mayhem_level",
                |m: &Character| { &m.mayhem_level },
                |m: &mut Character| { &mut m.mayhem_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GbxZoneMapFODSaveGameData>>(
                "gbx_zone_map_fod_save_game_data",
                |m: &Character| { &m.gbx_zone_map_fod_save_game_data },
                |m: &mut Character| { &mut m.gbx_zone_map_fod_save_game_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ActiveFastTravelSaveData>>(
                "active_or_blacklisted_travel_stations",
                |m: &Character| { &m.active_or_blacklisted_travel_stations },
                |m: &mut Character| { &mut m.active_or_blacklisted_travel_stations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "last_active_travel_station_for_playthrough",
                |m: &Character| { &m.last_active_travel_station_for_playthrough },
                |m: &mut Character| { &mut m.last_active_travel_station_for_playthrough },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GameStateSaveData>>(
                "game_state_save_data_for_playthrough",
                |m: &Character| { &m.game_state_save_data_for_playthrough },
                |m: &mut Character| { &mut m.game_state_save_data_for_playthrough },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::oak_shared::RegisteredDownloadableEntitlements>>(
                "registered_downloadable_entitlements",
                |m: &Character| { &m.registered_downloadable_entitlements },
                |m: &mut Character| { &mut m.registered_downloadable_entitlements },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlaythroughActiveFastTravelSaveData>>(
                "active_travel_stations_for_playthrough",
                |m: &Character| { &m.active_travel_stations_for_playthrough },
                |m: &mut Character| { &mut m.active_travel_stations_for_playthrough },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "save_game_guid",
                |m: &Character| { &m.save_game_guid },
                |m: &mut Character| { &mut m.save_game_guid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GuardianRankCharacterSaveGameData>>(
                "guardian_rank_character_data",
                |m: &Character| { &m.guardian_rank_character_data },
                |m: &mut Character| { &mut m.guardian_rank_character_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "optional_objective_reward_fixup_applied",
                |m: &Character| { &m.optional_objective_reward_fixup_applied },
                |m: &mut Character| { &mut m.optional_objective_reward_fixup_applied },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "vehicle_part_rewards_fixup_applied",
                |m: &Character| { &m.vehicle_part_rewards_fixup_applied },
                |m: &mut Character| { &mut m.vehicle_part_rewards_fixup_applied },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_active_league",
                |m: &Character| { &m.last_active_league },
                |m: &mut Character| { &mut m.last_active_league },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_active_league_instance",
                |m: &Character| { &m.last_active_league_instance },
                |m: &mut Character| { &mut m.last_active_league_instance },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Character_ActiveLeagueInstanceForEventEntry>>(
                "active_league_instance_for_event",
                |m: &Character| { &m.active_league_instance_for_event },
                |m: &mut Character| { &mut m.active_league_instance_for_event },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "levelled_save_vehicle_part_rewards_fixup_applied",
                |m: &Character| { &m.levelled_save_vehicle_part_rewards_fixup_applied },
                |m: &mut Character| { &mut m.levelled_save_vehicle_part_rewards_fixup_applied },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OakProfileCloudData>>(
                "profile_cloud_data",
                |m: &Character| { &m.profile_cloud_data },
                |m: &mut Character| { &mut m.profile_cloud_data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Character>(
                "Character",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Character {
        static instance: ::protobuf::rt::LazyV2<Character> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Character::new)
    }
}

impl ::protobuf::Clear for Character {
    fn clear(&mut self) {
        self.save_game_id = 0;
        self.last_save_timestamp = 0;
        self.time_played_seconds = 0;
        self.player_class_data.clear();
        self.resource_pools.clear();
        self.saved_regions.clear();
        self.experience_points = 0;
        self.game_stats_data.clear();
        self.inventory_category_list.clear();
        self.inventory_items.clear();
        self.equipped_inventory_list.clear();
        self.active_weapon_list.clear();
        self.ability_data.clear();
        self.last_play_through_index = 0;
        self.playthroughs_completed = 0;
        self.show_new_playthrough_notification = false;
        self.mission_playthroughs_data.clear();
        self.active_travel_stations.clear();
        self.discovery_data.clear();
        self.last_active_travel_station.clear();
        self.vehicles_unlocked_data.clear();
        self.vehicle_parts_unlocked.clear();
        self.vehicle_loadouts.clear();
        self.vehicle_last_loadout_index = 0;
        self.challenge_data.clear();
        self.sdu_list.clear();
        self.selected_customizations.clear();
        self.equipped_emote_customizations.clear();
        self.selected_color_customizations.clear();
        self.guardian_rank.clear();
        self.crew_quarters_room.clear();
        self.crew_quarters_gun_rack.clear();
        self.unlocked_echo_logs.clear();
        self.has_played_special_echo_log_insert_already = false;
        self.nickname_mappings.clear();
        self.last_traveled_map_id.clear();
        self.challenge_category_completion_pcts.clear();
        self.character_slot_save_game_data.clear();
        self.ui_tracking_save_game_data.clear();
        self.preferred_character_name.clear();
        self.name_character_limit = 0;
        self.preferred_group_mode = 0;
        self.time_of_day_save_game_data.clear();
        self.level_persistence_data.clear();
        self.accumulated_level_persistence_reset_timer_seconds = 0;
        self.mayhem_level = 0;
        self.gbx_zone_map_fod_save_game_data.clear();
        self.active_or_blacklisted_travel_stations.clear();
        self.last_active_travel_station_for_playthrough.clear();
        self.game_state_save_data_for_playthrough.clear();
        self.registered_downloadable_entitlements.clear();
        self.active_travel_stations_for_playthrough.clear();
        self.save_game_guid.clear();
        self.guardian_rank_character_data.clear();
        self.optional_objective_reward_fixup_applied = false;
        self.vehicle_part_rewards_fixup_applied = false;
        self.last_active_league = 0;
        self.last_active_league_instance = 0;
        self.active_league_instance_for_event.clear();
        self.levelled_save_vehicle_part_rewards_fixup_applied = false;
        self.profile_cloud_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Character {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Character {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Character_NicknameMappingsEntry {
    // message fields
    pub key: ::std::string::String,
    pub value: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Character_NicknameMappingsEntry {
    fn default() -> &'a Character_NicknameMappingsEntry {
        <Character_NicknameMappingsEntry as ::protobuf::Message>::default_instance()
    }
}

impl Character_NicknameMappingsEntry {
    pub fn new() -> Character_NicknameMappingsEntry {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // string value = 2;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Character_NicknameMappingsEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Character_NicknameMappingsEntry {
        Character_NicknameMappingsEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &Character_NicknameMappingsEntry| { &m.key },
                |m: &mut Character_NicknameMappingsEntry| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &Character_NicknameMappingsEntry| { &m.value },
                |m: &mut Character_NicknameMappingsEntry| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Character_NicknameMappingsEntry>(
                "Character.NicknameMappingsEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Character_NicknameMappingsEntry {
        static instance: ::protobuf::rt::LazyV2<Character_NicknameMappingsEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Character_NicknameMappingsEntry::new)
    }
}

impl ::protobuf::Clear for Character_NicknameMappingsEntry {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Character_NicknameMappingsEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Character_NicknameMappingsEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Character_ActiveLeagueInstanceForEventEntry {
    // message fields
    pub key: u32,
    pub value: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Character_ActiveLeagueInstanceForEventEntry {
    fn default() -> &'a Character_ActiveLeagueInstanceForEventEntry {
        <Character_ActiveLeagueInstanceForEventEntry as ::protobuf::Message>::default_instance()
    }
}

impl Character_ActiveLeagueInstanceForEventEntry {
    pub fn new() -> Character_ActiveLeagueInstanceForEventEntry {
        ::std::default::Default::default()
    }

    // uint32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // uint32 value = 2;


    pub fn get_value(&self) -> u32 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = v;
    }
}

impl ::protobuf::Message for Character_ActiveLeagueInstanceForEventEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.key = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += ::protobuf::rt::value_size(1, self.key, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(2, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_uint32(1, self.key)?;
        }
        if self.value != 0 {
            os.write_uint32(2, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Character_ActiveLeagueInstanceForEventEntry {
        Character_ActiveLeagueInstanceForEventEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "key",
                |m: &Character_ActiveLeagueInstanceForEventEntry| { &m.key },
                |m: &mut Character_ActiveLeagueInstanceForEventEntry| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "value",
                |m: &Character_ActiveLeagueInstanceForEventEntry| { &m.value },
                |m: &mut Character_ActiveLeagueInstanceForEventEntry| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Character_ActiveLeagueInstanceForEventEntry>(
                "Character.ActiveLeagueInstanceForEventEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Character_ActiveLeagueInstanceForEventEntry {
        static instance: ::protobuf::rt::LazyV2<Character_ActiveLeagueInstanceForEventEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Character_ActiveLeagueInstanceForEventEntry::new)
    }
}

impl ::protobuf::Clear for Character_ActiveLeagueInstanceForEventEntry {
    fn clear(&mut self) {
        self.key = 0;
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Character_ActiveLeagueInstanceForEventEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Character_ActiveLeagueInstanceForEventEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0eoak_save.proto\x12\x07OakSave\x1a\x10oak_shared.proto\"q\n\x17Play\
    erClassSaveGameData\x12,\n\x11player_class_path\x18\x01\x20\x01(\tR\x0fp\
    layerClassPathB\0\x12&\n\x0edlc_package_id\x18\x02\x20\x01(\rR\x0cdlcPac\
    kageIdB\0:\0\"]\n\x18ResourcePoolSavegameData\x12\x18\n\x06amount\x18\
    \x01\x20\x01(\x02R\x06amountB\0\x12%\n\rresource_path\x18\x02\x20\x01(\t\
    R\x0cresourcePathB\0:\0\"\xae\x01\n\x12RegionSaveGameData\x12\x1f\n\ngam\
    e_stage\x18\x01\x20\x01(\x05R\tgameStageB\0\x12*\n\x10play_through_idx\
    \x18\x02\x20\x01(\x05R\x0eplayThroughIdxB\0\x12!\n\x0bregion_path\x18\
    \x03\x20\x01(\tR\nregionPathB\0\x12&\n\x0edlc_package_id\x18\x04\x20\x01\
    (\rR\x0cdlcPackageIdB\0:\0\"\x8e\x03\n'InventoryBalanceStateInitializati\
    onData\x12\x1f\n\ngame_stage\x18\x01\x20\x01(\x05R\tgameStageB\0\x12'\n\
    \x0einventory_data\x18\x02\x20\x01(\tR\rinventoryDataB\0\x126\n\x16inven\
    tory_balance_data\x18\x03\x20\x01(\tR\x14inventoryBalanceDataB\0\x12-\n\
    \x11manufacturer_data\x18\x04\x20\x01(\tR\x10manufacturerDataB\0\x12\x1d\
    \n\tpart_list\x18\x05\x20\x03(\tR\x08partListB\0\x12,\n\x11generic_part_\
    list\x18\x06\x20\x03(\tR\x0fgenericPartListB\0\x12)\n\x0fadditional_data\
    \x18\x07\x20\x01(\x0cR\x0eadditionalDataB\0\x128\n\x17customization_part\
    _list\x18\x08\x20\x03(\tR\x15customizationPartListB\0:\0\"\xac\x02\n\x1c\
    OakInventoryItemSaveGameData\x12.\n\x12item_serial_number\x18\x01\x20\
    \x01(\x0cR\x10itemSerialNumberB\0\x12.\n\x12pickup_order_index\x18\x02\
    \x20\x01(\x05R\x10pickupOrderIndexB\0\x12\x16\n\x05flags\x18\x03\x20\x01\
    (\x05R\x05flagsB\0\x12*\n\x10weapon_skin_path\x18\x04\x20\x01(\tR\x0ewea\
    ponSkinPathB\0\x12f\n\x15development_save_data\x18\x05\x20\x01(\x0b20.Oa\
    kSave.InventoryBalanceStateInitializationDataR\x13developmentSaveDataB\0\
    :\0\"\xc7\x01\n\x1dEquippedInventorySaveGameData\x122\n\x14inventory_lis\
    t_index\x18\x01\x20\x01(\x05R\x12inventoryListIndexB\0\x12\x1a\n\x07enab\
    led\x18\x02\x20\x01(\x08R\x07enabledB\0\x12&\n\x0eslot_data_path\x18\x03\
    \x20\x01(\tR\x0cslotDataPathB\0\x12,\n\x11trinket_data_path\x18\x04\x20\
    \x01(\tR\x0ftrinketDataPathB\0:\0\"\xb2\x01\n\x1eOakAbilityTreeItemSaveG\
    ameData\x12(\n\x0fitem_asset_path\x18\x01\x20\x01(\tR\ritemAssetPathB\0\
    \x12\x18\n\x06points\x18\x02\x20\x01(\x05R\x06pointsB\0\x12\x1f\n\nmax_p\
    oints\x18\x03\x20\x01(\x05R\tmaxPointsB\0\x12)\n\x0ftree_identifier\x18\
    \x04\x20\x01(\x05R\x0etreeIdentifierB\0:\0\"x\n\x1aOakAbilitySlotSaveGam\
    eData\x12.\n\x12ability_class_path\x18\x01\x20\x01(\tR\x10abilityClassPa\
    thB\0\x12(\n\x0fslot_asset_path\x18\x02\x20\x01(\tR\rslotAssetPathB\0:\0\
    \"\xbe\x01\n#OakActionAbilityAugmentSaveGameData\x12;\n\x19action_abilit\
    y_class_path\x18\x01\x20\x01(\tR\x16actionAbilityClassPathB\0\x12(\n\x0f\
    slot_asset_path\x18\x02\x20\x01(\tR\rslotAssetPathB\0\x12.\n\x12augment_\
    asset_path\x18\x03\x20\x01(\tR\x10augmentAssetPathB\0:\0\"\xed\x01\n0Oak\
    ActionAbilityAugmentConfigurationSaveGameData\x12.\n\x12ability_class_pa\
    th\x18\x01\x20\x01(\tR\x10abilityClassPathB\0\x12.\n\x12augment_asset_pa\
    th\x18\x02\x20\x01(\tR\x10augmentAssetPathB\0\x12/\n\x13mod_slot_asset_p\
    ath\x18\x03\x20\x01(\tR\x10modSlotAssetPathB\0\x12&\n\x0emod_asset_path\
    \x18\x04\x20\x01(\tR\x0cmodAssetPathB\0:\0\"\xe5\x03\n\x1cOakPlayerAbili\
    tySaveGameData\x12'\n\x0eability_points\x18\x01\x20\x01(\x05R\rabilityPo\
    intsB\0\x12O\n\x0etree_item_list\x18\x02\x20\x03(\x0b2'.OakSave.OakAbili\
    tyTreeItemSaveGameDataR\x0ctreeItemListB\0\x12Q\n\x11ability_slot_list\
    \x18\x03\x20\x03(\x0b2#.OakSave.OakAbilitySlotSaveGameDataR\x0fabilitySl\
    otListB\0\x12Z\n\x11augment_slot_list\x18\x04\x20\x03(\x0b2,.OakSave.Oak\
    ActionAbilityAugmentSaveGameDataR\x0faugmentSlotListB\0\x12y\n\x1aaugmen\
    t_configuration_list\x18\x05\x20\x03(\x0b29.OakSave.OakActionAbilityAugm\
    entConfigurationSaveGameDataR\x18augmentConfigurationListB\0\x12\x1f\n\n\
    tree_grade\x18\x06\x20\x01(\x05R\ttreeGradeB\0:\0\"\xaa\x04\n\x1fMission\
    StatusPlayerSaveGameData\x12O\n\x06status\x18\x01\x20\x01(\x0e25.OakSave\
    .MissionStatusPlayerSaveGameData.MissionStateR\x06statusB\0\x124\n\x16ha\
    s_been_viewed_in_log\x18\x02\x20\x01(\x08R\x12hasBeenViewedInLogB\0\x121\
    \n\x13objectives_progress\x18\x03\x20\x03(\x05R\x12objectivesProgressB\0\
    \x12.\n\x12mission_class_path\x18\x04\x20\x01(\tR\x10missionClassPathB\0\
    \x12;\n\x19active_objective_set_path\x18\x05\x20\x01(\tR\x16activeObject\
    iveSetPathB\0\x12&\n\x0edlc_package_id\x18\x06\x20\x01(\rR\x0cdlcPackage\
    IdB\0\x12'\n\x0ekickoff_played\x18\x07\x20\x01(\x08R\rkickoffPlayedB\0\
    \x12)\n\x0fleague_instance\x18\x08\x20\x01(\rR\x0eleagueInstanceB\0\"b\n\
    \x0cMissionState\x12\x11\n\rMS_NotStarted\x10\0\x12\r\n\tMS_Active\x10\
    \x01\x12\x0f\n\x0bMS_Complete\x10\x02\x12\r\n\tMS_Failed\x10\x03\x12\x0e\
    \n\nMS_Unknown\x10\x04\x1a\0:\0\"\xb0\x01\n\x1eMissionPlaythroughSaveGam\
    eData\x12M\n\x0cmission_list\x18\x01\x20\x03(\x0b2(.OakSave.MissionStatu\
    sPlayerSaveGameDataR\x0bmissionListB\0\x12=\n\x1atracked_mission_class_p\
    ath\x18\x02\x20\x01(\tR\x17trackedMissionClassPathB\0:\0\"\x7f\n\x18Acti\
    veFastTravelSaveData\x12=\n\x1aactive_travel_station_name\x18\x01\x20\
    \x01(\tR\x17activeTravelStationNameB\0\x12\"\n\x0bblacklisted\x18\x02\
    \x20\x01(\x08R\x0bblacklistedB\0:\0\"\x82\x01\n#PlaythroughActiveFastTra\
    velSaveData\x12Y\n\x16active_travel_stations\x18\x01\x20\x03(\x0b2!.OakS\
    ave.ActiveFastTravelSaveDataR\x14activeTravelStationsB\0:\0\"\x85\x01\n\
    \x12DiscoveredAreaInfo\x122\n\x14discovered_area_name\x18\x01\x20\x01(\t\
    R\x12discoveredAreaNameB\0\x129\n\x17discovered_playthroughs\x18\x02\x20\
    \x01(\rR\x16discoveredPlaythroughsB\0:\0\"\xd9\x01\n\x13DiscoveredLevelI\
    nfo\x124\n\x15discovered_level_name\x18\x01\x20\x01(\tR\x13discoveredLev\
    elNameB\0\x129\n\x17discovered_playthroughs\x18\x03\x20\x01(\rR\x16disco\
    veredPlaythroughsB\0\x12O\n\x14discovered_area_info\x18\x04\x20\x03(\x0b\
    2\x1b.OakSave.DiscoveredAreaInfoR\x12discoveredAreaInfoB\0:\0\"m\n\x14Di\
    scoveredPlanetInfo\x12-\n\x11discovered_planet\x18\x01\x20\x01(\tR\x10di\
    scoveredPlanetB\0\x12$\n\ris_new_planet\x18\x02\x20\x01(\x08R\x0bisNewPl\
    anetB\0:\0\"i\n\x11DiscoverySaveData\x12R\n\x15discovered_level_info\x18\
    \x01\x20\x03(\x0b2\x1c.OakSave.DiscoveredLevelInfoR\x13discoveredLevelIn\
    foB\0:\0\"g\n\x1bVehicleUnlockedSaveGameData\x12\x1f\n\nasset_path\x18\
    \x01\x20\x01(\tR\tassetPathB\0\x12%\n\rjust_unlocked\x18\x02\x20\x01(\
    \x08R\x0cjustUnlockedB\0:\0\"\x8d\x05\n\x1fOakCARMenuVehicleConfigSaveDa\
    ta\x12,\n\x11loadout_save_name\x18\x01\x20\x01(\tR\x0floadoutSaveNameB\0\
    \x12(\n\x0fbody_asset_path\x18\x02\x20\x01(\tR\rbodyAssetPathB\0\x12*\n\
    \x10wheel_asset_path\x18\x03\x20\x01(\tR\x0ewheelAssetPathB\0\x12*\n\x10\
    armor_asset_path\x18\x04\x20\x01(\tR\x0earmorAssetPathB\0\x12/\n\x13core\
    _mod_asset_path\x18\x05\x20\x01(\tR\x10coreModAssetPathB\0\x129\n\x18gun\
    ner_weapon_asset_path\x18\x06\x20\x01(\tR\x15gunnerWeaponAssetPathB\0\
    \x129\n\x18driver_weapon_asset_path\x18\x07\x20\x01(\tR\x15driverWeaponA\
    ssetPathB\0\x120\n\x13ornament_asset_path\x18\x08\x20\x01(\tR\x11ornamen\
    tAssetPathB\0\x12;\n\x19material_decal_asset_path\x18\t\x20\x01(\tR\x16m\
    aterialDecalAssetPathB\0\x120\n\x13material_asset_path\x18\n\x20\x01(\tR\
    \x11materialAssetPathB\0\x12$\n\rcolor_index_1\x18\x0b\x20\x01(\x05R\x0b\
    colorIndex1B\0\x12$\n\rcolor_index_2\x18\x0c\x20\x01(\x05R\x0bcolorIndex\
    2B\0\x12$\n\rcolor_index_3\x18\r\x20\x01(\x05R\x0bcolorIndex3B\0:\0\"\
    \x9b\x02\n\x1dCustomPlayerColorSaveGameData\x12)\n\x0fcolor_parameter\
    \x18\x01\x20\x01(\tR\x0ecolorParameterB\0\x124\n\rapplied_color\x18\x02\
    \x20\x01(\x0b2\r.OakSave.Vec3R\x0cappliedColorB\0\x120\n\x0bsplit_color\
    \x18\x03\x20\x01(\x0b2\r.OakSave.Vec3R\nsplitColorB\0\x12,\n\x11use_defa\
    ult_color\x18\x04\x20\x01(\x08R\x0fuseDefaultColorB\0\x127\n\x17use_defa\
    ult_split_color\x18\x05\x20\x01(\x08R\x14useDefaultSplitColorB\0:\0\"v\n\
    \x18GuardianRankSaveGameData\x12%\n\rguardian_rank\x18\x01\x20\x01(\x05R\
    \x0cguardianRankB\0\x121\n\x13guardian_experience\x18\x02\x20\x01(\x05R\
    \x12guardianExperienceB\0:\0\"\x99\x01\n'GuardianRankRewardCharacterSave\
    GameData\x12\x1f\n\nnum_tokens\x18\x01\x20\x01(\x05R\tnumTokensB\0\x12\
    \x1f\n\nis_enabled\x18\x02\x20\x01(\x08R\tisEnabledB\0\x12*\n\x10reward_\
    data_path\x18\x03\x20\x01(\tR\x0erewardDataPathB\0:\0\"r\n%GuardianRankP\
    erkCharacterSaveGameData\x12\x1f\n\nis_enabled\x18\x01\x20\x01(\x08R\tis\
    EnabledB\0\x12&\n\x0eperk_data_path\x18\x02\x20\x01(\tR\x0cperkDataPathB\
    \0:\0\"\x97\x04\n!GuardianRankCharacterSaveGameData\x12<\n\x19guardian_a\
    vailable_tokens\x18\x01\x20\x01(\x05R\x17guardianAvailableTokensB\0\x12%\
    \n\rguardian_rank\x18\x02\x20\x01(\x05R\x0cguardianRankB\0\x121\n\x13gua\
    rdian_experience\x18\x03\x20\x01(\x05R\x12guardianExperienceB\0\x12U\n\
    \x0crank_rewards\x18\x04\x20\x03(\x0b20.OakSave.GuardianRankRewardCharac\
    terSaveGameDataR\x0brankRewardsB\0\x12O\n\nrank_perks\x18\x05\x20\x03(\
    \x0b2..OakSave.GuardianRankPerkCharacterSaveGameDataR\trankPerksB\0\x12?\
    \n\x1bguardian_reward_random_seed\x18\x06\x20\x01(\x05R\x18guardianRewar\
    dRandomSeedB\0\x128\n\x17new_guardian_experience\x18\x07\x20\x01(\x03R\
    \x15newGuardianExperienceB\0\x125\n\x16is_rank_system_enabled\x18\x08\
    \x20\x01(\x08R\x13isRankSystemEnabledB\0:\0\"\x83\x01\n\x1eCrewQuartersD\
    ecorationSaveData\x12+\n\x10decoration_index\x18\x01\x20\x01(\x05R\x0fde\
    corationIndexB\0\x122\n\x14decoration_data_path\x18\x02\x20\x01(\tR\x12d\
    ecorationDataPathB\0:\0\"\xcb\x01\n\x14CrewQuartersSaveData\x12<\n\x19pr\
    eferred_room_assignment\x18\x01\x20\x01(\x05R\x17preferredRoomAssignment\
    B\0\x12K\n\x0bdecorations\x18\x02\x20\x03(\x0b2'.OakSave.CrewQuartersDec\
    orationSaveDataR\x0bdecorationsB\0\x12&\n\x0eroom_data_path\x18\x03\x20\
    \x01(\tR\x0croomDataPathB\0:\0\"\xef\x01\n\x1fCrewQuartersGunRackItemSav\
    eData\x128\n\x17encrypted_serial_number\x18\x01\x20\x01(\x0cR\x15encrypt\
    edSerialNumberB\0\x12(\n\x0fslot_asset_path\x18\x02\x20\x01(\tR\rslotAss\
    etPathB\0\x12f\n\x15development_save_data\x18\x03\x20\x01(\x0b20.OakSave\
    .InventoryBalanceStateInitializationDataR\x13developmentSaveDataB\0:\0\"\
    q\n\x1bCrewQuartersGunRackSaveData\x12P\n\x0erack_save_data\x18\x01\x20\
    \x03(\x0b2(.OakSave.CrewQuartersGunRackItemSaveDataR\x0crackSaveDataB\0:\
    \0\"o\n\x13EchoLogSaveGameData\x120\n\x14has_been_seen_in_log\x18\x01\
    \x20\x01(\x08R\x10hasBeenSeenInLogB\0\x12$\n\recho_log_path\x18\x02\x20\
    \x01(\tR\x0bechoLogPathB\0:\0\"S\n\tMapIDData\x12\"\n\x0czone_name_id\
    \x18\x01\x20\x01(\rR\nzoneNameIdB\0\x12\x20\n\x0bmap_name_id\x18\x02\x20\
    \x01(\rR\tmapNameIdB\0:\0\"\xb1\x01\n\x11GameStateSaveData\x12E\n\x14las\
    t_traveled_map_id\x18\x01\x20\x01(\x0b2\x12.OakSave.MapIDDataR\x11lastTr\
    aveledMapIdB\0\x12#\n\x0cmayhem_level\x18\x02\x20\x01(\x05R\x0bmayhemLev\
    elB\0\x12.\n\x12mayhem_random_seed\x18\x03\x20\x01(\x05R\x10mayhemRandom\
    SeedB\0:\0\"T\n!ChallengeCategoryProgressSaveData\x12-\n\x11category_pro\
    gress\x18\x01\x20\x01(\x0cR\x10categoryProgressB\0:\0\"\x83\x01\n%OakPla\
    yerCharacterAugmentSaveGameData\x12(\n\x0fslot_asset_path\x18\x01\x20\
    \x01(\tR\rslotAssetPathB\0\x12.\n\x12augment_asset_path\x18\x02\x20\x01(\
    \tR\x10augmentAssetPathB\0:\0\"\x84\x01\n\"OakPlayerCharacterSlotSaveGam\
    eData\x12\\\n\x11augment_slot_list\x18\x01\x20\x03(\x0b2..OakSave.OakPla\
    yerCharacterAugmentSaveGameDataR\x0faugmentSlotListB\0:\0\"\x99\x04\n\
    \x16UITrackingSaveGameData\x12<\n\x1ahas_seen_skill_menu_unlock\x18\x01\
    \x20\x01(\x08R\x16hasSeenSkillMenuUnlockB\0\x12K\n\"has_seen_guardian_ra\
    nk_menu_unlock\x18\x02\x20\x01(\x08R\x1dhasSeenGuardianRankMenuUnlockB\0\
    \x12=\n\x1bhas_seen_echo_boot_ammo_bar\x18\x03\x20\x01(\x08R\x16hasSeenE\
    choBootAmmoBarB\0\x12A\n\x1dhas_seen_echo_boot_shield_bar\x18\x04\x20\
    \x01(\x08R\x18hasSeenEchoBootShieldBarB\0\x12>\n\x1bhas_seen_echo_boot_g\
    renades\x18\x05\x20\x01(\x08R\x17hasSeenEchoBootGrenadesB\0\x12A\n\x1chi\
    ghest_thvm_breadcrumb_seen\x18\x06\x20\x01(\x05R\x19highestThvmBreadcrum\
    bSeenB\0\x12?\n\x1binventory_slot_unlocks_seen\x18\x07\x20\x03(\tR\x18in\
    ventorySlotUnlocksSeenB\0\x12,\n\x11saved_spin_offset\x18\x08\x20\x01(\
    \x05R\x0fsavedSpinOffsetB\0:\0\"\x87\x01\n\x0fPlanetCycleInfo\x12!\n\x0b\
    planet_name\x18\x01\x20\x01(\tR\nplanetNameB\0\x12#\n\x0ccycle_length\
    \x18\x02\x20\x01(\x02R\x0bcycleLengthB\0\x12*\n\x10last_cached_time\x18\
    \x03\x20\x01(\x02R\x0elastCachedTimeB\0:\0\"\x86\x01\n\x15TimeOfDaySaveG\
    ameData\x12F\n\x11planet_cycle_info\x18\x01\x20\x03(\x0b2\x18.OakSave.Pl\
    anetCycleInfoR\x0fplanetCycleInfoB\0\x12#\n\x0cplanet_cycle\x18\x02\x20\
    \x01(\tR\x0bplanetCycleB\0:\0\"s\n#LevelPersistence_Actor_SaveGameData\
    \x12\x1f\n\nactor_name\x18\x01\x20\x01(\tR\tactorNameB\0\x12)\n\x0ftimer\
    _remaining\x18\x02\x20\x01(\x05R\x0etimerRemainingB\0:\0\"\x9b\x01\n#Lev\
    elPersistence_Level_SaveGameData\x12\x1f\n\nlevel_name\x18\x01\x20\x01(\
    \tR\tlevelNameB\0\x12Q\n\x0csaved_actors\x18\x02\x20\x03(\x0b2,.OakSave.\
    LevelPersistence_Actor_SaveGameDataR\x0bsavedActorsB\0:\0\"\xa7\x02\n\
    \x1bGbxZoneMapFODSavedLevelData\x12\x1f\n\nlevel_name\x18\x01\x20\x01(\t\
    R\tlevelNameB\0\x12*\n\x10fod_texture_size\x18\x02\x20\x01(\rR\x0efodTex\
    tureSizeB\0\x12\x1f\n\nnum_chunks\x18\x03\x20\x01(\rR\tnumChunksB\0\x123\
    \n\x14discovery_percentage\x18\x04\x20\x01(\x02R\x13discoveryPercentageB\
    \0\x12\x1f\n\ndata_state\x18\x05\x20\x01(\rR\tdataStateB\0\x12%\n\rdata_\
    revision\x18\x06\x20\x01(\rR\x0cdataRevisionB\0\x12\x1b\n\x08fod_data\
    \x18\x07\x20\x01(\x0cR\x07fodDataB\0:\0\"d\n\x19GbxZoneMapFODSaveGameDat\
    a\x12E\n\nlevel_data\x18\x01\x20\x03(\x0b2$.OakSave.GbxZoneMapFODSavedLe\
    velDataR\tlevelDataB\0:\0\"\xac\n\n\x13OakProfileCloudData\x12M\n\x12pro\
    file_stats_data\x18\x01\x20\x03(\x0b2\x1d.OakSave.GameStatSaveGameDataR\
    \x10profileStatsDataB\0\x120\n\x13bank_inventory_list\x18\x02\x20\x03(\
    \x0cR\x11bankInventoryListB\0\x129\n\x18lost_loot_inventory_list\x18\x03\
    \x20\x03(\x0cR\x15lostLootInventoryListB\0\x12<\n\x0enpc_mail_items\x18\
    \x04\x20\x03(\x0b2\x14.OakSave.OakMailItemR\x0cnpcMailItemsB\0\x12G\n\
    \x10profile_sdu_list\x18\x05\x20\x03(\x0b2\x1b.OakSave.OakSDUSaveGameDat\
    aR\x0eprofileSduListB\0\x12`\n\x17unlocked_customizations\x18\x06\x20\
    \x03(\x0b2%.OakSave.OakCustomizationSaveGameDataR\x16unlockedCustomizati\
    onsB\0\x12\x81\x01\n&unlocked_inventory_customization_parts\x18\x07\x20\
    \x03(\x0b2*.OakSave.OakInventoryCustomizationPartInfoR#unlockedInventory\
    CustomizationPartsB\0\x121\n\x13guardian_experience\x18\x08\x20\x01(\x03\
    R\x12guardianExperienceB\0\x12~\n\"unlocked_crew_quarters_decorations\
    \x18\t\x20\x03(\x0b2/.OakSave.CrewQuartersDecorationItemSaveGameDataR\
    \x1funlockedCrewQuartersDecorationsB\0\x12l\n\x1cunlocked_crew_quarters_\
    rooms\x18\n\x20\x03(\x0b2).OakSave.CrewQuartersRoomItemSaveGameDataR\x19\
    unlockedCrewQuartersRoomsB\0\x12G\n\x0echallenge_data\x18\x0b\x20\x03(\
    \x0b2\x1e.OakSave.ChallengeSaveGameDataR\rchallengeDataB\0\x12\x1f\n\nma\
    il_guids\x18\x0c\x20\x03(\tR\tmailGuidsB\0\x12H\n\x1eCitizenScienceLevel\
    Progression\x18\r\x20\x03(\x05R\x1eCitizenScienceLevelProgressionB\0\x12\
    B\n\x1bCitizenScienceCSBucksAmount\x18\x0e\x20\x01(\x05R\x1bCitizenScien\
    ceCSBucksAmountB\0\x12?\n\nvault_card\x18\x0f\x20\x01(\x0b2\x1e.OakSave.\
    VaultCardSaveGameDataR\tvaultCardB\0\x12L\n\x20bCitizenScienceHasSeenInt\
    roVideo\x18\x19\x20\x01(\x08R\x20bCitizenScienceHasSeenIntroVideoB\0\x12\
    B\n\x1bbCitizenScienceTutorialDone\x18\x1a\x20\x01(\x08R\x1bbCitizenScie\
    nceTutorialDoneB\0:\0\"\xac'\n\tCharacter\x12\"\n\x0csave_game_id\x18\
    \x01\x20\x01(\rR\nsaveGameIdB\0\x120\n\x13last_save_timestamp\x18\x02\
    \x20\x01(\x03R\x11lastSaveTimestampB\0\x120\n\x13time_played_seconds\x18\
    \x03\x20\x01(\rR\x11timePlayedSecondsB\0\x12N\n\x11player_class_data\x18\
    \x04\x20\x01(\x0b2\x20.OakSave.PlayerClassSaveGameDataR\x0fplayerClassDa\
    taB\0\x12J\n\x0eresource_pools\x18\x05\x20\x03(\x0b2!.OakSave.ResourcePo\
    olSavegameDataR\rresourcePoolsB\0\x12B\n\rsaved_regions\x18\x06\x20\x03(\
    \x0b2\x1b.OakSave.RegionSaveGameDataR\x0csavedRegionsB\0\x12-\n\x11exper\
    ience_points\x18\x07\x20\x01(\x05R\x10experiencePointsB\0\x12G\n\x0fgame\
    _stats_data\x18\x08\x20\x03(\x0b2\x1d.OakSave.GameStatSaveGameDataR\rgam\
    eStatsDataB\0\x12\\\n\x17inventory_category_list\x18\t\x20\x03(\x0b2\".O\
    akSave.InventoryCategorySaveDataR\x15inventoryCategoryListB\0\x12P\n\x0f\
    inventory_items\x18\n\x20\x03(\x0b2%.OakSave.OakInventoryItemSaveGameDat\
    aR\x0einventoryItemsB\0\x12`\n\x17equipped_inventory_list\x18\x0b\x20\
    \x03(\x0b2&.OakSave.EquippedInventorySaveGameDataR\x15equippedInventoryL\
    istB\0\x12.\n\x12active_weapon_list\x18\x0c\x20\x03(\x05R\x10activeWeapo\
    nListB\0\x12J\n\x0cability_data\x18\r\x20\x01(\x0b2%.OakSave.OakPlayerAb\
    ilitySaveGameDataR\x0babilityDataB\0\x127\n\x17last_play_through_index\
    \x18\x0e\x20\x01(\x05R\x14lastPlayThroughIndexB\0\x127\n\x16playthroughs\
    _completed\x18\x0f\x20\x01(\x05R\x15playthroughsCompletedB\0\x12K\n!show\
    _new_playthrough_notification\x18\x10\x20\x01(\x08R\x1eshowNewPlaythroug\
    hNotificationB\0\x12e\n\x19mission_playthroughs_data\x18\x11\x20\x03(\
    \x0b2'.OakSave.MissionPlaythroughSaveGameDataR\x17missionPlaythroughsDat\
    aB\0\x126\n\x16active_travel_stations\x18\x15\x20\x03(\tR\x14activeTrave\
    lStationsB\0\x12C\n\x0ediscovery_data\x18\x16\x20\x01(\x0b2\x1a.OakSave.\
    DiscoverySaveDataR\rdiscoveryDataB\0\x12=\n\x1alast_active_travel_statio\
    n\x18\x17\x20\x01(\tR\x17lastActiveTravelStationB\0\x12\\\n\x16vehicles_\
    unlocked_data\x18\x18\x20\x03(\x0b2$.OakSave.VehicleUnlockedSaveGameData\
    R\x14vehiclesUnlockedDataB\0\x126\n\x16vehicle_parts_unlocked\x18\x19\
    \x20\x03(\tR\x14vehiclePartsUnlockedB\0\x12U\n\x10vehicle_loadouts\x18\
    \x1a\x20\x03(\x0b2(.OakSave.OakCARMenuVehicleConfigSaveDataR\x0fvehicleL\
    oadoutsB\0\x12=\n\x1avehicle_last_loadout_index\x18\x1b\x20\x01(\x05R\
    \x17vehicleLastLoadoutIndexB\0\x12G\n\x0echallenge_data\x18\x1c\x20\x03(\
    \x0b2\x1e.OakSave.ChallengeSaveGameDataR\rchallengeDataB\0\x128\n\x08sdu\
    _list\x18\x1d\x20\x03(\x0b2\x1b.OakSave.OakSDUSaveGameDataR\x07sduListB\
    \0\x129\n\x17selected_customizations\x18\x1e\x20\x03(\tR\x16selectedCust\
    omizationsB\0\x12D\n\x1dequipped_emote_customizations\x18\x1f\x20\x03(\
    \x05R\x1bequippedEmoteCustomizationsB\0\x12l\n\x1dselected_color_customi\
    zations\x18\x20\x20\x03(\x0b2&.OakSave.CustomPlayerColorSaveGameDataR\
    \x1bselectedColorCustomizationsB\0\x12H\n\rguardian_rank\x18!\x20\x01(\
    \x0b2!.OakSave.GuardianRankSaveGameDataR\x0cguardianRankB\0\x12M\n\x12cr\
    ew_quarters_room\x18\"\x20\x01(\x0b2\x1d.OakSave.CrewQuartersSaveDataR\
    \x10crewQuartersRoomB\0\x12[\n\x16crew_quarters_gun_rack\x18#\x20\x01(\
    \x0b2$.OakSave.CrewQuartersGunRackSaveDataR\x13crewQuartersGunRackB\0\
    \x12L\n\x12unlocked_echo_logs\x18$\x20\x03(\x0b2\x1c.OakSave.EchoLogSave\
    GameDataR\x10unlockedEchoLogsB\0\x12Z\n*has_played_special_echo_log_inse\
    rt_already\x18%\x20\x01(\x08R$hasPlayedSpecialEchoLogInsertAlreadyB\0\
    \x12W\n\x11nickname_mappings\x18&\x20\x03(\x0b2(.OakSave.Character.Nickn\
    ameMappingsEntryR\x10nicknameMappingsB\0\x12E\n\x14last_traveled_map_id\
    \x18'\x20\x01(\x0b2\x12.OakSave.MapIDDataR\x11lastTraveledMapIdB\0\x12y\
    \n\"challenge_category_completion_pcts\x18(\x20\x01(\x0b2*.OakSave.Chall\
    engeCategoryProgressSaveDataR\x1fchallengeCategoryCompletionPctsB\0\x12o\
    \n\x1dcharacter_slot_save_game_data\x18)\x20\x01(\x0b2+.OakSave.OakPlaye\
    rCharacterSlotSaveGameDataR\x19characterSlotSaveGameDataB\0\x12]\n\x1aui\
    _tracking_save_game_data\x18*\x20\x01(\x0b2\x1f.OakSave.UITrackingSaveGa\
    meDataR\x16uiTrackingSaveGameDataB\0\x12:\n\x18preferred_character_name\
    \x18+\x20\x01(\tR\x16preferredCharacterNameB\0\x122\n\x14name_character_\
    limit\x18,\x20\x01(\x05R\x12nameCharacterLimitB\0\x122\n\x14preferred_gr\
    oup_mode\x18-\x20\x01(\rR\x12preferredGroupModeB\0\x12[\n\x1atime_of_day\
    _save_game_data\x18.\x20\x01(\x0b2\x1e.OakSave.TimeOfDaySaveGameDataR\
    \x15timeOfDaySaveGameDataB\0\x12d\n\x16level_persistence_data\x18/\x20\
    \x03(\x0b2,.OakSave.LevelPersistence_Level_SaveGameDataR\x14levelPersist\
    enceDataB\0\x12i\n1accumulated_level_persistence_reset_timer_seconds\x18\
    0\x20\x01(\rR,accumulatedLevelPersistenceResetTimerSecondsB\0\x12#\n\x0c\
    mayhem_level\x181\x20\x01(\rR\x0bmayhemLevelB\0\x12h\n\x1fgbx_zone_map_f\
    od_save_game_data\x182\x20\x01(\x0b2\".OakSave.GbxZoneMapFODSaveGameData\
    R\x19gbxZoneMapFodSaveGameDataB\0\x12u\n%active_or_blacklisted_travel_st\
    ations\x183\x20\x03(\x0b2!.OakSave.ActiveFastTravelSaveDataR!activeOrBla\
    cklistedTravelStationsB\0\x12[\n*last_active_travel_station_for_playthro\
    ugh\x184\x20\x03(\tR%lastActiveTravelStationForPlaythroughB\0\x12k\n$gam\
    e_state_save_data_for_playthrough\x185\x20\x03(\x0b2\x1a.OakSave.GameSta\
    teSaveDataR\x1fgameStateSaveDataForPlaythroughB\0\x12\x7f\n$registered_d\
    ownloadable_entitlements\x186\x20\x03(\x0b2+.OakSave.RegisteredDownloada\
    bleEntitlementsR\"registeredDownloadableEntitlementsB\0\x12\x82\x01\n&ac\
    tive_travel_stations_for_playthrough\x187\x20\x03(\x0b2,.OakSave.Playthr\
    oughActiveFastTravelSaveDataR\"activeTravelStationsForPlaythroughB\0\x12\
    &\n\x0esave_game_guid\x188\x20\x01(\tR\x0csaveGameGuidB\0\x12m\n\x1cguar\
    dian_rank_character_data\x189\x20\x01(\x0b2*.OakSave.GuardianRankCharact\
    erSaveGameDataR\x19guardianRankCharacterDataB\0\x12V\n'optional_objectiv\
    e_reward_fixup_applied\x18:\x20\x01(\x08R#optionalObjectiveRewardFixupAp\
    pliedB\0\x12L\n\"vehicle_part_rewards_fixup_applied\x18;\x20\x01(\x08R\
    \x1evehiclePartRewardsFixupAppliedB\0\x12.\n\x12last_active_league\x18<\
    \x20\x01(\rR\x10lastActiveLeagueB\0\x12?\n\x1blast_active_league_instanc\
    e\x18=\x20\x01(\rR\x18lastActiveLeagueInstanceB\0\x12~\n\x20active_leagu\
    e_instance_for_event\x18>\x20\x03(\x0b24.OakSave.Character.ActiveLeagueI\
    nstanceForEventEntryR\x1cactiveLeagueInstanceForEventB\0\x12f\n0levelled\
    _save_vehicle_part_rewards_fixup_applied\x18?\x20\x01(\x08R*levelledSave\
    VehiclePartRewardsFixupAppliedB\0\x12L\n\x12profile_cloud_data\x18@\x20\
    \x01(\x0b2\x1c.OakSave.OakProfileCloudDataR\x10profileCloudDataB\0\x1aE\
    \n\x15NicknameMappingsEntry\x12\x12\n\x03key\x18\x01\x20\x01(\tR\x03keyB\
    \0\x12\x16\n\x05value\x18\x02\x20\x01(\tR\x05valueB\0:\0\x1aQ\n!ActiveLe\
    agueInstanceForEventEntry\x12\x12\n\x03key\x18\x01\x20\x01(\rR\x03keyB\0\
    \x12\x16\n\x05value\x18\x02\x20\x01(\rR\x05valueB\0:\0:\0B\0b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
